{"version":3,"file":"js/319.babylonBundle.js","mappings":"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","sources":["webpack://pro-racer/../lts/loaders/generated/glTF/glTFValidation.ts","webpack://pro-racer/../lts/loaders/generated/glTF/glTFFileLoader.ts","webpack://pro-racer/../lts/loaders/generated/glTF/1.0/glTFLoaderInterfaces.ts","webpack://pro-racer/../lts/loaders/generated/glTF/1.0/glTFLoaderUtils.ts","webpack://pro-racer/../lts/loaders/generated/glTF/1.0/glTFLoader.ts","webpack://pro-racer/../lts/loaders/generated/glTF/1.0/glTFBinaryExtension.ts","webpack://pro-racer/../lts/loaders/generated/glTF/1.0/glTFMaterialsCommonExtension.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/glTFLoaderAnimation.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/glTFLoader.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/EXT_lights_image_based.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/EXT_meshopt_compression.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/EXT_texture_webp.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_unlit.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_clearcoat.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_iridescence.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_sheen.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_specular.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_ior.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_variants.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_transmission.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_translucency.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_volume.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_mesh_quantization.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_texture_basisu.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_xmp_json_ld.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_animation_pointer.data.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/KHR_animation_pointer.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/MSFT_audio_emitter.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/MSFT_lod.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/MSFT_minecraftMesh.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/MSFT_sRGBFactors.ts","webpack://pro-racer/../lts/loaders/generated/glTF/2.0/Extensions/ExtrasAsMetadata.ts"],"sourcesContent":["import type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let GLTFValidator: GLTF2.IGLTFValidator;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction validateAsync(\r\n    data: string | ArrayBuffer,\r\n    rootUrl: string,\r\n    fileName: string,\r\n    getExternalResource: (uri: string) => Promise<ArrayBuffer>\r\n): Promise<GLTF2.IGLTFValidationResults> {\r\n    const options: GLTF2.IGLTFValidationOptions = {\r\n        externalResourceFunction: (uri) => getExternalResource(uri).then((value) => new Uint8Array(value)),\r\n    };\r\n\r\n    if (fileName) {\r\n        options.uri = rootUrl === \"file:\" ? fileName : rootUrl + fileName;\r\n    }\r\n\r\n    return data instanceof ArrayBuffer ? GLTFValidator.validateBytes(new Uint8Array(data), options) : GLTFValidator.validateString(data, options);\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction workerFunc(): void {\r\n    const pendingExternalResources: Array<{ resolve: (data: any) => void; reject: (reason: any) => void }> = [];\r\n\r\n    onmessage = (message) => {\r\n        const data = message.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                importScripts(data.url);\r\n                break;\r\n            }\r\n            case \"validate\": {\r\n                validateAsync(\r\n                    data.data,\r\n                    data.rootUrl,\r\n                    data.fileName,\r\n                    (uri) =>\r\n                        new Promise((resolve, reject) => {\r\n                            const index = pendingExternalResources.length;\r\n                            pendingExternalResources.push({ resolve, reject });\r\n                            postMessage({ id: \"getExternalResource\", index: index, uri: uri });\r\n                        })\r\n                ).then(\r\n                    (value) => {\r\n                        postMessage({ id: \"validate.resolve\", value: value });\r\n                    },\r\n                    (reason) => {\r\n                        postMessage({ id: \"validate.reject\", reason: reason });\r\n                    }\r\n                );\r\n                break;\r\n            }\r\n            case \"getExternalResource.resolve\": {\r\n                pendingExternalResources[data.index].resolve(data.value);\r\n                break;\r\n            }\r\n            case \"getExternalResource.reject\": {\r\n                pendingExternalResources[data.index].reject(data.reason);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for glTF validation\r\n */\r\nexport interface IGLTFValidationConfiguration {\r\n    /**\r\n     * The url of the glTF validator.\r\n     */\r\n    url: string;\r\n}\r\n\r\n/**\r\n * glTF validation\r\n */\r\nexport class GLTFValidation {\r\n    /**\r\n     * The configuration. Defaults to `{ url: \"https://preview.babylonjs.com/gltf_validator.js\" }`.\r\n     */\r\n    public static Configuration: IGLTFValidationConfiguration = {\r\n        url: \"https://preview.babylonjs.com/gltf_validator.js\",\r\n    };\r\n\r\n    private static _LoadScriptPromise: Promise<void>;\r\n\r\n    /**\r\n     * Validate a glTF asset using the glTF-Validator.\r\n     * @param data The JSON of a glTF or the array buffer of a binary glTF\r\n     * @param rootUrl The root url for the glTF\r\n     * @param fileName The file name for the glTF\r\n     * @param getExternalResource The callback to get external resources for the glTF validator\r\n     * @returns A promise that resolves with the glTF validation results once complete\r\n     */\r\n    public static ValidateAsync(\r\n        data: string | ArrayBuffer,\r\n        rootUrl: string,\r\n        fileName: string,\r\n        getExternalResource: (uri: string) => Promise<ArrayBuffer>\r\n    ): Promise<GLTF2.IGLTFValidationResults> {\r\n        if (typeof Worker === \"function\") {\r\n            return new Promise((resolve, reject) => {\r\n                const workerContent = `${validateAsync}(${workerFunc})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                const worker = new Worker(workerBlobUrl);\r\n\r\n                const onError = (error: ErrorEvent) => {\r\n                    worker.removeEventListener(\"error\", onError);\r\n                    worker.removeEventListener(\"message\", onMessage);\r\n                    reject(error);\r\n                };\r\n\r\n                const onMessage = (message: MessageEvent) => {\r\n                    const data = message.data;\r\n                    switch (data.id) {\r\n                        case \"getExternalResource\": {\r\n                            getExternalResource(data.uri).then(\r\n                                (value) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.resolve\", index: data.index, value: value }, [value]);\r\n                                },\r\n                                (reason) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.reject\", index: data.index, reason: reason });\r\n                                }\r\n                            );\r\n                            break;\r\n                        }\r\n                        case \"validate.resolve\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            resolve(data.value);\r\n                            worker.terminate();\r\n                            break;\r\n                        }\r\n                        case \"validate.reject\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(data.reason);\r\n                            worker.terminate();\r\n                        }\r\n                    }\r\n                };\r\n\r\n                worker.addEventListener(\"error\", onError);\r\n                worker.addEventListener(\"message\", onMessage);\r\n\r\n                worker.postMessage({ id: \"init\", url: this.Configuration.url });\r\n                worker.postMessage({ id: \"validate\", data: data, rootUrl: rootUrl, fileName: fileName });\r\n            });\r\n        } else {\r\n            if (!this._LoadScriptPromise) {\r\n                this._LoadScriptPromise = Tools.LoadScriptAsync(this.Configuration.url);\r\n            }\r\n\r\n            return this._LoadScriptPromise.then(() => {\r\n                return validateAsync(data, rootUrl, fileName, getExternalResource);\r\n            });\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type {\r\n    ISceneLoaderPluginFactory,\r\n    ISceneLoaderPlugin,\r\n    ISceneLoaderPluginAsync,\r\n    ISceneLoaderProgressEvent,\r\n    ISceneLoaderPluginExtensions,\r\n    ISceneLoaderAsyncResult,\r\n} from \"core/Loading/sceneLoader\";\r\nimport { SceneLoader } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene, IDisposable } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DataReader } from \"core/Misc/dataReader\";\r\nimport { GLTFValidation } from \"./glTFValidation\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport { DecodeBase64UrlToBinary } from \"core/Misc/fileTools\";\r\nimport { RuntimeError, ErrorCodes } from \"core/Misc/error\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\ninterface IFileRequestInfo extends IFileRequest {\r\n    _lengthComputable?: boolean;\r\n    _loaded?: number;\r\n    _total?: number;\r\n}\r\n\r\nfunction readAsync(arrayBuffer: ArrayBuffer, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    json: Object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<IDataBuffer>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines the order of this extension.\r\n     * The loader sorts the extensions using these values when loading.\r\n     */\r\n    order?: number;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    importMeshAsync: (\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ) => Promise<ISceneLoaderAsyncResult>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @internal */\r\n    public static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @internal */\r\n    public static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: (loaderData: IGLTFLoaderData) => void) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        this._onParsedObserver = this.onParsedObservable.add(callback);\r\n    }\r\n\r\n    // ----------\r\n    // V1 options\r\n    // ----------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @internal\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @internal\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n     * The animation start mode. Defaults to FIRST.\r\n     */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\r\n     * Enabling will disable offline support and glTF validator.\r\n     * Defaults to false.\r\n     */\r\n    public useRangeRequests = false;\r\n\r\n    /**\r\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\r\n     */\r\n    public createInstances = true;\r\n\r\n    /**\r\n     * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\r\n     */\r\n    public alwaysComputeBoundingBox = false;\r\n\r\n    /**\r\n     * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\r\n     */\r\n    public loadAllMaterials = false;\r\n\r\n    /**\r\n     * If true, load only the materials defined in the file. Defaults to false.\r\n     */\r\n    public loadOnlyMaterials = false;\r\n\r\n    /**\r\n     * If true, do not load any materials defined in the file. Defaults to false.\r\n     */\r\n    public skipMaterials = false;\r\n\r\n    /**\r\n     * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.\r\n     */\r\n    public useSRGBBuffers = true;\r\n\r\n    /**\r\n     * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.\r\n     */\r\n    public targetFps = 60;\r\n\r\n    /**\r\n     * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.\r\n     * Set this to true if loading assets with invalid `skin.skeleton` values.\r\n     */\r\n    public alwaysComputeSkeletonRootNode = false;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     * @param url\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public set onMeshLoaded(callback: (mesh: AbstractMesh) => void) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/divingDeeper/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     * @param node - the transform node that corresponds to the original glTF skin node used for animations\r\n     * @param skinnedNode - the transform node that is the skinned mesh itself or the parent of the skinned meshes\r\n     */\r\n    public readonly onSkinLoadedObservable = new Observable<{ node: TransformNode; skinnedNode: TransformNode }>();\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: (texture: BaseTexture) => void) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: (material: Material) => void) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: (camera: Camera) => void) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        } else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        } else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<GLTF2.IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<GLTF2.IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n    private _state: Nullable<GLTFLoaderState> = null;\r\n    private _progressCallback?: (event: ISceneLoaderProgressEvent) => void;\r\n    private _requests = new Array<IFileRequestInfo>();\r\n\r\n    private static _MagicBase64Encoded = \"Z2xURg\"; // \"glTF\" base64 encoded (without the quotes!)\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public name = \"gltf\";\r\n\r\n    /** @internal */\r\n    public extensions: ISceneLoaderPluginExtensions = {\r\n        \".gltf\": { isBinary: false },\r\n        \".glb\": { isBinary: true },\r\n    };\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        for (const request of this._requests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._requests.length = 0;\r\n\r\n        delete this._progressCallback;\r\n\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onSkinLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: any, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest {\r\n        this._progressCallback = onProgress;\r\n\r\n        const rootUrl = (fileOrUrl as File).name ? \"file:\" : Tools.GetFolderPath(fileOrUrl as string);\r\n        const fileName = (fileOrUrl as File).name || Tools.GetFilename(fileOrUrl as string);\r\n\r\n        if (useArrayBuffer) {\r\n            if (this.useRangeRequests) {\r\n                if (this.validate) {\r\n                    Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\r\n                }\r\n\r\n                const fileRequest: IFileRequest = {\r\n                    abort: () => {},\r\n                    onCompleteObservable: new Observable<IFileRequest>(),\r\n                };\r\n\r\n                const dataBuffer = {\r\n                    readAsync: (byteOffset: number, byteLength: number) => {\r\n                        return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                            this._loadFile(\r\n                                scene,\r\n                                fileOrUrl,\r\n                                (data) => {\r\n                                    resolve(new Uint8Array(data as ArrayBuffer));\r\n                                },\r\n                                true,\r\n                                (error) => {\r\n                                    reject(error);\r\n                                },\r\n                                (webRequest) => {\r\n                                    webRequest.setRequestHeader(\"Range\", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);\r\n                                }\r\n                            );\r\n                        });\r\n                    },\r\n                    byteLength: 0,\r\n                };\r\n\r\n                this._unpackBinaryAsync(new DataReader(dataBuffer)).then(\r\n                    (loaderData) => {\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                        onSuccess(loaderData);\r\n                    },\r\n                    onError ? (error) => onError(undefined, error) : undefined\r\n                );\r\n\r\n                return fileRequest;\r\n            }\r\n\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    this._validate(scene, data as ArrayBuffer, rootUrl, fileName);\r\n                    this._unpackBinaryAsync(\r\n                        new DataReader({\r\n                            readAsync: (byteOffset, byteLength) => readAsync(data as ArrayBuffer, byteOffset, byteLength),\r\n                            byteLength: (data as ArrayBuffer).byteLength,\r\n                        })\r\n                    ).then(\r\n                        (loaderData) => {\r\n                            onSuccess(loaderData);\r\n                        },\r\n                        onError ? (error) => onError(undefined, error) : undefined\r\n                    );\r\n                },\r\n                true,\r\n                onError\r\n            );\r\n        }\r\n\r\n        return this._loadFile(\r\n            scene,\r\n            fileOrUrl,\r\n            (data) => {\r\n                this._validate(scene, data, rootUrl, fileName);\r\n                onSuccess({ json: this._parseJson(data as string) });\r\n            },\r\n            useArrayBuffer,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n\r\n            // Prepare the asset container.\r\n            const container = new AssetContainer(scene);\r\n\r\n            // Get materials/textures when loading to add to container\r\n            const materials: Array<Material> = [];\r\n            this.onMaterialLoadedObservable.add((material) => {\r\n                materials.push(material);\r\n            });\r\n            const textures: Array<BaseTexture> = [];\r\n            this.onTextureLoadedObservable.add((texture) => {\r\n                textures.push(texture);\r\n            });\r\n            const cameras: Array<Camera> = [];\r\n            this.onCameraLoadedObservable.add((camera) => {\r\n                cameras.push(camera);\r\n            });\r\n\r\n            return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {\r\n                Array.prototype.push.apply(container.geometries, result.geometries);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                Array.prototype.push.apply(container.materials, materials);\r\n                Array.prototype.push.apply(container.textures, textures);\r\n                Array.prototype.push.apply(container.lights, result.lights);\r\n                Array.prototype.push.apply(container.transformNodes, result.transformNodes);\r\n                Array.prototype.push.apply(container.cameras, cameras);\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public canDirectLoad(data: string): boolean {\r\n        return (\r\n            (data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1) ||\r\n            data.startsWith(\"data:base64,\" + GLTFFileLoader._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\"data:;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\r\n            data.startsWith(\"data:application/octet-stream;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\r\n            data.startsWith(\"data:model/gltf-binary;base64,\" + GLTFFileLoader._MagicBase64Encoded)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public directLoad(scene: Scene, data: string): Promise<any> {\r\n        if (\r\n            data.startsWith(\"base64,\" + GLTFFileLoader._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\";base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\r\n            data.startsWith(\"application/octet-stream;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\r\n            data.startsWith(\"model/gltf-binary;base64,\" + GLTFFileLoader._MagicBase64Encoded)\r\n        ) {\r\n            const arrayBuffer = DecodeBase64UrlToBinary(data);\r\n\r\n            this._validate(scene, arrayBuffer);\r\n            return this._unpackBinaryAsync(\r\n                new DataReader({\r\n                    readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),\r\n                    byteLength: arrayBuffer.byteLength,\r\n                })\r\n            );\r\n        }\r\n\r\n        this._validate(scene, data);\r\n        return Promise.resolve({ json: this._parseJson(data) });\r\n    }\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    public rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n\r\n    /** @internal */\r\n    public createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader();\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader state changes.\r\n     */\r\n    public onLoaderStateChangedObservable = new Observable<Nullable<GLTFLoaderState>>();\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setState(state: GLTFLoaderState): void {\r\n        if (this._state === state) {\r\n            return;\r\n        }\r\n\r\n        this._state = state;\r\n        this.onLoaderStateChangedObservable.notifyObservers(this._state);\r\n        this._log(GLTFLoaderState[this._state]);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: string | ArrayBuffer) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest) => void,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): IFileRequest {\r\n        const request = scene._loadFile(\r\n            fileOrUrl,\r\n            onSuccess,\r\n            (event) => {\r\n                this._onProgress(event, request);\r\n            },\r\n            true,\r\n            useArrayBuffer,\r\n            onError,\r\n            onOpened\r\n        ) as IFileRequestInfo;\r\n        request.onCompleteObservable.add((request) => {\r\n            this._requests.splice(this._requests.indexOf(request), 1);\r\n        });\r\n        this._requests.push(request);\r\n        return request;\r\n    }\r\n\r\n    private _onProgress(event: ProgressEvent, request: IFileRequestInfo): void {\r\n        if (!this._progressCallback) {\r\n            return;\r\n        }\r\n\r\n        request._lengthComputable = event.lengthComputable;\r\n        request._loaded = event.loaded;\r\n        request._total = event.total;\r\n\r\n        let lengthComputable = true;\r\n        let loaded = 0;\r\n        let total = 0;\r\n        for (const request of this._requests) {\r\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\r\n                return;\r\n            }\r\n\r\n            lengthComputable = lengthComputable && request._lengthComputable;\r\n            loaded += request._loaded;\r\n            total += request._total;\r\n        }\r\n\r\n        this._progressCallback({\r\n            lengthComputable: lengthComputable,\r\n            loaded: loaded,\r\n            total: lengthComputable ? total : 0,\r\n        });\r\n    }\r\n\r\n    private _validate(scene: Scene, data: string | ArrayBuffer, rootUrl = \"\", fileName = \"\"): void {\r\n        if (!this.validate) {\r\n            return;\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n        GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {\r\n            return this.preprocessUrlAsync(rootUrl + uri).then((url) => scene._loadFileAsync(url, undefined, true, true) as Promise<ArrayBuffer>);\r\n        }).then(\r\n            (result) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                this.onValidatedObservable.notifyObservers(result);\r\n                this.onValidatedObservable.clear();\r\n            },\r\n            (reason) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                Tools.Warn(`Failed to validate: ${reason.message}`);\r\n                this.onValidatedObservable.clear();\r\n            }\r\n        );\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTF1Loader,\r\n            2: GLTFFileLoader._CreateGLTF2Loader,\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _parseJson(json: string): Object {\r\n        this._startPerformanceCounter(\"Parse JSON\");\r\n        this._log(`JSON length: ${json.length}`);\r\n        const parsed = JSON.parse(json);\r\n        this._endPerformanceCounter(\"Parse JSON\");\r\n        return parsed;\r\n    }\r\n\r\n    private _unpackBinaryAsync(dataReader: DataReader): Promise<IGLTFLoaderData> {\r\n        this._startPerformanceCounter(\"Unpack Binary\");\r\n\r\n        // Read magic + version + length + json length + json format\r\n        return dataReader.loadAsync(20).then(() => {\r\n            const Binary = {\r\n                Magic: 0x46546c67,\r\n            };\r\n\r\n            const magic = dataReader.readUint32();\r\n            if (magic !== Binary.Magic) {\r\n                throw new RuntimeError(\"Unexpected magic: \" + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);\r\n            }\r\n\r\n            const version = dataReader.readUint32();\r\n\r\n            if (this.loggingEnabled) {\r\n                this._log(`Binary version: ${version}`);\r\n            }\r\n\r\n            const length = dataReader.readUint32();\r\n            if (!this.useRangeRequests && length !== dataReader.buffer.byteLength) {\r\n                Logger.Warn(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);\r\n            }\r\n\r\n            let unpacked: Promise<IGLTFLoaderData>;\r\n            switch (version) {\r\n                case 1: {\r\n                    unpacked = this._unpackBinaryV1Async(dataReader, length);\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    unpacked = this._unpackBinaryV2Async(dataReader, length);\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(\"Unsupported version: \" + version);\r\n                }\r\n            }\r\n\r\n            this._endPerformanceCounter(\"Unpack Binary\");\r\n\r\n            return unpacked;\r\n        });\r\n    }\r\n\r\n    private _unpackBinaryV1Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ContentFormat = {\r\n            JSON: 0,\r\n        };\r\n\r\n        const contentLength = dataReader.readUint32();\r\n        const contentFormat = dataReader.readUint32();\r\n\r\n        if (contentFormat !== ContentFormat.JSON) {\r\n            throw new Error(`Unexpected content format: ${contentFormat}`);\r\n        }\r\n\r\n        const bodyLength = length - dataReader.byteOffset;\r\n\r\n        const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };\r\n        if (bodyLength !== 0) {\r\n            const startByteOffset = dataReader.byteOffset;\r\n            data.bin = {\r\n                readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                byteLength: bodyLength,\r\n            };\r\n        }\r\n\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    private _unpackBinaryV2Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ChunkFormat = {\r\n            JSON: 0x4e4f534a,\r\n            BIN: 0x004e4942,\r\n        };\r\n\r\n        // Read the JSON chunk header.\r\n        const chunkLength = dataReader.readUint32();\r\n        const chunkFormat = dataReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n\r\n        // Bail if there are no other chunks.\r\n        if (dataReader.byteOffset + chunkLength === length) {\r\n            return dataReader.loadAsync(chunkLength).then(() => {\r\n                return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n            });\r\n        }\r\n\r\n        // Read the JSON chunk and the length and type of the next chunk.\r\n        return dataReader.loadAsync(chunkLength + 8).then(() => {\r\n            const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n\r\n            const readAsync = (): Promise<IGLTFLoaderData> => {\r\n                const chunkLength = dataReader.readUint32();\r\n                const chunkFormat = dataReader.readUint32();\r\n\r\n                switch (chunkFormat) {\r\n                    case ChunkFormat.JSON: {\r\n                        throw new Error(\"Unexpected JSON chunk\");\r\n                    }\r\n                    case ChunkFormat.BIN: {\r\n                        const startByteOffset = dataReader.byteOffset;\r\n                        data.bin = {\r\n                            readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                            byteLength: chunkLength,\r\n                        };\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // ignore unrecognized chunkFormat\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (dataReader.byteOffset !== length) {\r\n                    return dataReader.loadAsync(8).then(readAsync);\r\n                }\r\n\r\n                return Promise.resolve(data);\r\n            };\r\n\r\n            return readAsync();\r\n        });\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number; minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0,\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2]),\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number; minor: number }, b: { major: number; minor: number }): number {\r\n        if (a.major > b.major) {\r\n            return 1;\r\n        }\r\n        if (a.major < b.major) {\r\n            return -1;\r\n        }\r\n        if (a.minor > b.minor) {\r\n            return 1;\r\n        }\r\n        if (a.minor < b.minor) {\r\n            return -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @internal */\r\n    public _log = this._logDisabled;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @internal */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);\r\n        Logger.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {}\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @internal */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @internal */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {}\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {}\r\n}\r\n\r\nif (SceneLoader) {\r\n    SceneLoader.RegisterPlugin(new GLTFFileLoader());\r\n}\r\n","import type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Skeleton } from \"core/Bones/skeleton\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Enums\r\n * @internal\r\n */\r\nexport enum EComponentType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    FLOAT = 5126,\r\n}\r\n\r\n/** @internal */\r\nexport enum EShaderType {\r\n    FRAGMENT = 35632,\r\n    VERTEX = 35633,\r\n}\r\n\r\n/** @internal */\r\nexport enum EParameterType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    INT = 5124,\r\n    UNSIGNED_INT = 5125,\r\n    FLOAT = 5126,\r\n    FLOAT_VEC2 = 35664,\r\n    FLOAT_VEC3 = 35665,\r\n    FLOAT_VEC4 = 35666,\r\n    INT_VEC2 = 35667,\r\n    INT_VEC3 = 35668,\r\n    INT_VEC4 = 35669,\r\n    BOOL = 35670,\r\n    BOOL_VEC2 = 35671,\r\n    BOOL_VEC3 = 35672,\r\n    BOOL_VEC4 = 35673,\r\n    FLOAT_MAT2 = 35674,\r\n    FLOAT_MAT3 = 35675,\r\n    FLOAT_MAT4 = 35676,\r\n    SAMPLER_2D = 35678,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureWrapMode {\r\n    CLAMP_TO_EDGE = 33071,\r\n    MIRRORED_REPEAT = 33648,\r\n    REPEAT = 10497,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFilterType {\r\n    NEAREST = 9728,\r\n    LINEAR = 9728,\r\n    NEAREST_MIPMAP_NEAREST = 9984,\r\n    LINEAR_MIPMAP_NEAREST = 9985,\r\n    NEAREST_MIPMAP_LINEAR = 9986,\r\n    LINEAR_MIPMAP_LINEAR = 9987,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFormat {\r\n    ALPHA = 6406,\r\n    RGB = 6407,\r\n    RGBA = 6408,\r\n    LUMINANCE = 6409,\r\n    LUMINANCE_ALPHA = 6410,\r\n}\r\n\r\n/** @internal */\r\nexport enum ECullingType {\r\n    FRONT = 1028,\r\n    BACK = 1029,\r\n    FRONT_AND_BACK = 1032,\r\n}\r\n\r\n/** @internal */\r\nexport enum EBlendingFunction {\r\n    ZERO = 0,\r\n    ONE = 1,\r\n    SRC_COLOR = 768,\r\n    ONE_MINUS_SRC_COLOR = 769,\r\n    DST_COLOR = 774,\r\n    ONE_MINUS_DST_COLOR = 775,\r\n    SRC_ALPHA = 770,\r\n    ONE_MINUS_SRC_ALPHA = 771,\r\n    DST_ALPHA = 772,\r\n    ONE_MINUS_DST_ALPHA = 773,\r\n    CONSTANT_COLOR = 32769,\r\n    ONE_MINUS_CONSTANT_COLOR = 32770,\r\n    CONSTANT_ALPHA = 32771,\r\n    ONE_MINUS_CONSTANT_ALPHA = 32772,\r\n    SRC_ALPHA_SATURATE = 776,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProperty {\r\n    extensions?: { [key: string]: any };\r\n    extras?: Object;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFChildRootProperty extends IGLTFProperty {\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAccessor extends IGLTFChildRootProperty {\r\n    bufferView: string;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    count: number;\r\n    type: string;\r\n    componentType: EComponentType;\r\n\r\n    max?: number[];\r\n    min?: number[];\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBufferView extends IGLTFChildRootProperty {\r\n    buffer: string;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    byteStride: number;\r\n\r\n    target?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBuffer extends IGLTFChildRootProperty {\r\n    uri: string;\r\n\r\n    byteLength?: number;\r\n    type?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFShader extends IGLTFChildRootProperty {\r\n    uri: string;\r\n    type: EShaderType;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProgram extends IGLTFChildRootProperty {\r\n    attributes: string[];\r\n    fragmentShader: string;\r\n    vertexShader: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueParameter {\r\n    type: number;\r\n\r\n    count?: number;\r\n    semantic?: string;\r\n    node?: string;\r\n    value?: number | boolean | string | Array<any>;\r\n    source?: string;\r\n\r\n    babylonValue?: any;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueCommonProfile {\r\n    lightingModel: string;\r\n    texcoordBindings: Object;\r\n\r\n    parameters?: Array<any>;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStatesFunctions {\r\n    blendColor?: number[];\r\n    blendEquationSeparate?: number[];\r\n    blendFuncSeparate?: number[];\r\n    colorMask: boolean[];\r\n    cullFace: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStates {\r\n    enable: number[];\r\n    functions: IGLTFTechniqueStatesFunctions;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechnique extends IGLTFChildRootProperty {\r\n    parameters: { [key: string]: IGLTFTechniqueParameter };\r\n    program: string;\r\n\r\n    attributes: { [key: string]: string };\r\n    uniforms: { [key: string]: string };\r\n    states: IGLTFTechniqueStates;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMaterial extends IGLTFChildRootProperty {\r\n    technique?: string;\r\n    values: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMeshPrimitive extends IGLTFProperty {\r\n    attributes: { [key: string]: string };\r\n    indices: string;\r\n    material: string;\r\n\r\n    mode?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMesh extends IGLTFChildRootProperty {\r\n    primitives: IGLTFMeshPrimitive[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFImage extends IGLTFChildRootProperty {\r\n    uri: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSampler extends IGLTFChildRootProperty {\r\n    magFilter?: number;\r\n    minFilter?: number;\r\n    wrapS?: number;\r\n    wrapT?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTexture extends IGLTFChildRootProperty {\r\n    sampler: string;\r\n    source: string;\r\n\r\n    format?: ETextureFormat;\r\n    internalFormat?: ETextureFormat;\r\n    target?: number;\r\n    type?: number;\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonTexture?: Texture;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAmbienLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFDirectionalLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFPointLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSpotLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    fallOfAngle?: number;\r\n    fallOffExponent?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLight extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraOrthographic {\r\n    xmag: number;\r\n    ymag: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraPerspective {\r\n    aspectRatio: number;\r\n    yfov: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCamera extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannelTarget {\r\n    id: string;\r\n    path: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannel {\r\n    sampler: string;\r\n    target: IGLTFAnimationChannelTarget;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationSampler {\r\n    input: string;\r\n    output: string;\r\n\r\n    interpolation?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimation extends IGLTFChildRootProperty {\r\n    channels?: IGLTFAnimationChannel[];\r\n    parameters?: { [key: string]: string };\r\n    samplers?: { [key: string]: IGLTFAnimationSampler };\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNodeInstanceSkin {\r\n    skeletons: string[];\r\n    skin: string;\r\n    meshes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSkins extends IGLTFChildRootProperty {\r\n    bindShapeMatrix: number[];\r\n    inverseBindMatrices: string;\r\n    jointNames: string[];\r\n\r\n    babylonSkeleton?: Skeleton;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNode extends IGLTFChildRootProperty {\r\n    camera?: string;\r\n    children: string[];\r\n    skin?: string;\r\n    jointName?: string;\r\n    light?: string;\r\n    matrix: number[];\r\n    mesh?: string;\r\n    meshes?: string[];\r\n    rotation?: number[];\r\n    scale?: number[];\r\n    translation?: number[];\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonNode?: Node;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFScene extends IGLTFChildRootProperty {\r\n    nodes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFRuntime {\r\n    extensions: { [key: string]: any };\r\n    accessors: { [key: string]: IGLTFAccessor };\r\n    buffers: { [key: string]: IGLTFBuffer };\r\n    bufferViews: { [key: string]: IGLTFBufferView };\r\n    meshes: { [key: string]: IGLTFMesh };\r\n    lights: { [key: string]: IGLTFLight };\r\n    cameras: { [key: string]: IGLTFCamera };\r\n    nodes: { [key: string]: IGLTFNode };\r\n    images: { [key: string]: IGLTFImage };\r\n    textures: { [key: string]: IGLTFTexture };\r\n    shaders: { [key: string]: IGLTFShader };\r\n    programs: { [key: string]: IGLTFProgram };\r\n    samplers: { [key: string]: IGLTFSampler };\r\n    techniques: { [key: string]: IGLTFTechnique };\r\n    materials: { [key: string]: IGLTFMaterial };\r\n    animations: { [key: string]: IGLTFAnimation };\r\n    skins: { [key: string]: IGLTFSkins };\r\n\r\n    currentScene?: Object;\r\n    scenes: { [key: string]: IGLTFScene }; // v1.1\r\n\r\n    extensionsUsed: string[];\r\n    extensionsRequired?: string[]; // v1.1\r\n\r\n    buffersCount: number;\r\n    shaderscount: number;\r\n\r\n    scene: Scene;\r\n    rootUrl: string;\r\n\r\n    loadedBufferCount: number;\r\n    loadedBufferViews: { [name: string]: ArrayBufferView };\r\n\r\n    loadedShaderCount: number;\r\n\r\n    importOnlyMeshes: boolean;\r\n    importMeshesNames?: string[];\r\n\r\n    dummyNodes: Node[];\r\n\r\n    assetContainer: Nullable<AssetContainer>;\r\n}\r\n\r\n/** @internal */\r\nexport interface INodeToRoot {\r\n    bone: Bone;\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IJointNode {\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n","import type { IGLTFTechniqueParameter, IGLTFAccessor, IGLTFRuntime, IGLTFBufferView } from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2, Vector3, Vector4, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * Utils functions for GLTF\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene the Scene object\r\n     * @param source the source node where to pick the matrix\r\n     * @param parameter the GLTF technique parameter\r\n     * @param uniformName the name of the shader's uniform\r\n     * @param shaderMaterial the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        let mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        } else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        } else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        } else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        } else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        } else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2:\r\n                    shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT3:\r\n                    shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT4:\r\n                    shaderMaterial.setMatrix(uniformName, mat);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial the shader material\r\n     * @param uniform the name of the shader's uniform\r\n     * @param value the value of the uniform\r\n     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT:\r\n                shaderMaterial.setFloat(uniform, value);\r\n                return true;\r\n            case EParameterType.FLOAT_VEC2:\r\n                shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC3:\r\n                shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC4:\r\n                shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the wrap mode of the texture\r\n     * @param mode the mode value\r\n     */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor the GLTF accessor objet\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        const type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n            default:\r\n                return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode the filter mode value\r\n     */\r\n    public static GetTextureFilterMode(mode: number): ETextureFilterType {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\r\n                return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\r\n                return Texture.NEAREST_SAMPLINGMODE;\r\n            default:\r\n                return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(\r\n        gltfRuntime: IGLTFRuntime,\r\n        bufferView: IGLTFBufferView,\r\n        byteOffset: number,\r\n        byteLength: number,\r\n        componentType: EComponentType\r\n    ): ArrayBufferView {\r\n        byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        const buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE:\r\n                return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE:\r\n                return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT:\r\n                return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT:\r\n                return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default:\r\n                return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime the GLTF runtime\r\n     * @param accessor the GLTF accessor\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view the buffer view\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        let result = \"\";\r\n        const length = view.byteLength;\r\n\r\n        for (let i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene the Babylon.js scene\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            const shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\",\r\n            };\r\n\r\n            const options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false,\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type {\r\n    IGLTFRuntime,\r\n    IGLTFTechniqueParameter,\r\n    IGLTFAnimation,\r\n    IGLTFAnimationSampler,\r\n    IGLTFNode,\r\n    IGLTFSkins,\r\n    INodeToRoot,\r\n    IJointNode,\r\n    IGLTFMesh,\r\n    IGLTFAccessor,\r\n    IGLTFLight,\r\n    IGLTFAmbienLight,\r\n    IGLTFDirectionalLight,\r\n    IGLTFPointLight,\r\n    IGLTFSpotLight,\r\n    IGLTFCamera,\r\n    IGLTFCameraPerspective,\r\n    IGLTFScene,\r\n    IGLTFTechnique,\r\n    IGLTFMaterial,\r\n    IGLTFProgram,\r\n    IGLTFBuffer,\r\n    IGLTFTexture,\r\n    IGLTFImage,\r\n    IGLTFSampler,\r\n    IGLTFShader,\r\n    IGLTFTechniqueStates,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader } from \"../glTFFileLoader\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n\r\n/**\r\n * Tokenizer. Used for shaders compatibility\r\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n */\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3,\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) {\r\n            return ETokenType.END_OF_INPUT;\r\n        }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n * Values\r\n */\r\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nconst babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nconst babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n * Parse\r\n * @param parsedBuffers\r\n * @param gltfRuntime\r\n */\r\nconst parseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const buf in parsedBuffers) {\r\n        const parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nconst parseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const sha in parsedShaders) {\r\n        const parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nconst parseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (const object in parsedObjects) {\r\n        const parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n * Utils\r\n * @param buffer\r\n */\r\nconst normalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nconst getAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Loads and creates animations\r\n * @param gltfRuntime\r\n */\r\nconst loadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (const anim in gltfRuntime.animations) {\r\n        const animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        let lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (let i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            const channel = animation.channels[i];\r\n            const sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            let inputData: Nullable<string> = null;\r\n            let outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            } else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            const targetId = channel.target.id;\r\n            let targetNode: any = gltfRuntime.scene.getNodeById(targetId);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetId);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            const isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            let targetPath = channel.target.path;\r\n            const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = babylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            let animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                } else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            let babylonAnimation: Nullable<Animation> = null;\r\n            const keys = [];\r\n            let arrayOffset = 0;\r\n            let modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (let j = 0; j < bufferInput.length; j++) {\r\n                let value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                } else {\r\n                    // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    const bone = <Bone>targetNode;\r\n                    let translation = Vector3.Zero();\r\n                    let rotationQuaternion = new Quaternion();\r\n                    let scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    let mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    } else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    } else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value,\r\n                    });\r\n                } else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Returns the bones transformation matrix\r\n * @param node\r\n */\r\nconst configureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    let mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        const position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    } else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n * Returns the parent bone\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param jointName\r\n * @param newSkeleton\r\n */\r\nconst getParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (let i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    const nodes = gltfRuntime.nodes;\r\n    for (const nde in nodes) {\r\n        const node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        const children = node.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                const mat = configureBoneTransformation(node);\r\n                const bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the appropriate root node\r\n * @param nodesToRoot\r\n * @param id\r\n */\r\nconst getNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n\r\n        for (let j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            const child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the node with the joint name\r\n * @param gltfRuntime\r\n * @param jointName\r\n */\r\nconst getJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    const nodes = gltfRuntime.nodes;\r\n    let node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName,\r\n        };\r\n    }\r\n\r\n    for (const nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde,\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Checks if a nodes is in joints\r\n * @param skins\r\n * @param id\r\n */\r\nconst nodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Fills the nodes to root for bones and builds hierarchy\r\n * @param gltfRuntime\r\n * @param newSkeleton\r\n * @param skins\r\n * @param nodesToRoot\r\n */\r\nconst getNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (const nde in gltfRuntime.nodes) {\r\n        const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        const id = nde;\r\n\r\n        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        const mat = configureBoneTransformation(node);\r\n        const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n        const children = nodeToRoot.node.children;\r\n\r\n        for (let j = 0; j < children.length; j++) {\r\n            let child: Nullable<INodeToRoot> = null;\r\n\r\n            for (let k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Imports a skeleton\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param mesh\r\n * @param newSkeleton\r\n */\r\nconst importSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined): Skeleton => {\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    const nodesToRoot: INodeToRoot[] = [];\r\n    const nodesToRootToAdd: Bone[] = [];\r\n\r\n    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        const node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        const id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        const existingBone = gltfRuntime.scene.getBoneById(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        let foundBone = false;\r\n        let parentBone: Nullable<Bone> = null;\r\n\r\n        for (let j = 0; j < i; j++) {\r\n            const jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            const joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            const children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (let k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        const mat = configureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = getNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    const bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (let j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (let i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n * Imports a mesh and its geometries\r\n * @param gltfRuntime\r\n * @param node\r\n * @param meshes\r\n * @param id\r\n * @param newMesh\r\n */\r\nconst importMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh._parentContainer = gltfRuntime.assetContainer;\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    let vertexData: Nullable<VertexData> = null;\r\n    const verticesStarts = new Array<number>();\r\n    const verticesCounts = new Array<number>();\r\n    const indexStarts = new Array<number>();\r\n    const indexCounts = new Array<number>();\r\n\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            const tempVertexData = new VertexData();\r\n\r\n            const primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            const attributes = primitive.attributes;\r\n            let accessor: Nullable<IGLTFAccessor> = null;\r\n            let buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (const semantic in attributes) {\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                } else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (let j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    } else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    const channel = Number(semantic.split(\"_\")[1]);\r\n                    const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\r\n                    const uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    normalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                } else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                } else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                } else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            } else {\r\n                // Set indices on the fly\r\n                const indices: number[] = [];\r\n                for (let j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            } else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            const material = gltfRuntime.scene.getMaterialById(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        (material as MultiMaterial).subMaterials = subMaterials;\r\n    } else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = subMaterials[0] as StandardMaterial;\r\n    }\r\n\r\n    material._parentContainer = gltfRuntime.assetContainer;\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    let index = 0;\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n * Configure node transformation from position, rotation and scaling\r\n * @param newNode\r\n * @param position\r\n * @param rotation\r\n * @param scaling\r\n */\r\nconst configureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n * Configures node from transformation matrix\r\n * @param newNode\r\n * @param node\r\n */\r\nconst configureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode) => {\r\n    if (node.matrix) {\r\n        const position = new Vector3(0, 0, 0);\r\n        const rotation = new Quaternion();\r\n        const scaling = new Vector3(0, 0, 0);\r\n        const mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        configureNode(newNode, position, rotation, scaling);\r\n    } else if (node.translation && node.rotation && node.scale) {\r\n        configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n * Imports a node\r\n * @param gltfRuntime\r\n * @param node\r\n * @param id\r\n */\r\nconst importNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string): Nullable<Node> => {\r\n    let lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            const skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            const newMesh = importMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    } else if (node.meshes) {\r\n        /**\r\n         * Improve meshes property\r\n         */\r\n        const newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                const ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            } else if (light.type === \"directional\") {\r\n                const directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            } else if (light.type === \"point\") {\r\n                const pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            } else if (light.type === \"spot\") {\r\n                const spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl();\r\n\r\n                lastNode = orthoCamera;\r\n\r\n                orthoCamera._parentContainer = gltfRuntime.assetContainer;\r\n            } else if (camera.type === \"perspective\") {\r\n                const perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl();\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n                persCamera._parentContainer = gltfRuntime.assetContainer;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        } else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            dummy._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            configureNodeFromMatrix(lastNode, node);\r\n        } else {\r\n            const translation = node.translation || [0, 0, 0];\r\n            const rotation = node.rotation || [0, 0, 0, 1];\r\n            const scale = node.scale || [1, 1, 1];\r\n            configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n * Traverses nodes and creates them\r\n * @param gltfRuntime\r\n * @param id\r\n * @param parent\r\n * @param meshIncluded\r\n */\r\nconst traverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    const node: IGLTFNode = gltfRuntime.nodes[id];\r\n    let newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        } else {\r\n            meshIncluded = false;\r\n        }\r\n    } else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = importNode(gltfRuntime, node, id);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n * @param gltfRuntime\r\n */\r\nconst postLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    let currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (let i = 0; i < currentScene.nodes.length; i++) {\r\n            traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    } else {\r\n        for (const thing in gltfRuntime.scenes) {\r\n            currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    loadAnimations(gltfRuntime);\r\n\r\n    for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        const skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n * onBind shaderrs callback to set uniforms and matrices\r\n * @param mesh\r\n * @param gltfRuntime\r\n * @param unTreatedUniforms\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param onSuccess\r\n */\r\nconst onBindShaderMaterial = (\r\n    mesh: AbstractMesh,\r\n    gltfRuntime: IGLTFRuntime,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            } else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n        } else {\r\n            const value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                (<Effect>shaderMaterial.getEffect()).setTexture(unif, texture);\r\n            } else {\r\n                GLTFUtils.SetUniform(<Effect>shaderMaterial.getEffect(), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n * Prepare uniforms to send the only one time\r\n * Loads the appropriate textures\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n */\r\nconst prepareShaderMaterialUniforms = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n    const techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n     * Prepare values here (not matrices)\r\n     */\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n        let value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        const onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Shader compilation failed\r\n * @param program\r\n * @param shaderMaterial\r\n * @param onError\r\n */\r\nconst onShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n * Shader compilation success\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param unTreatedUniforms\r\n * @param onSuccess\r\n */\r\nconst onShaderCompileSuccess = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    return (_: Effect) => {\r\n        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n * Returns the appropriate uniform if already handled by babylon\r\n * @param tokenizer\r\n * @param technique\r\n */\r\nconst parseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (const unif in technique.uniforms) {\r\n        const uniform = technique.uniforms[unif];\r\n        const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return babylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n * All shaders loaded. Create materials one by one\r\n * @param gltfRuntime\r\n */\r\nconst importMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (const mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(\r\n            gltfRuntime,\r\n            mat,\r\n            () => {},\r\n            () => {}\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Implementation of the base glTF spec\r\n * @internal\r\n */\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        const gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            assetContainer: null,\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            parseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            parseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            parseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            parseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            parseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            parseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            parseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            parseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            parseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        const buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + buffer.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                onProgress,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + source.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                undefined,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        const sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        const createMipMaps =\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\r\n\r\n        const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        const blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        const blobURL = URL.createObjectURL(blob);\r\n        const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            const shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        } else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        const program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        const states: IGLTFTechniqueStates = technique.states;\r\n\r\n        const vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        const pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        let newVertexShader = \"\";\r\n        let newPixelShader = \"\";\r\n\r\n        const vertexTokenizer = new Tokenizer(vertexShader);\r\n        const pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        const unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        const uniforms: string[] = [];\r\n        const attributes: string[] = [];\r\n        const samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (const unif in technique.uniforms) {\r\n            const uniform = technique.uniforms[unif];\r\n            const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(babylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                } else {\r\n                    uniforms.push(unif);\r\n                }\r\n            } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            } else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (const attr in technique.attributes) {\r\n            const attribute = technique.attributes[attr];\r\n            const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                const name = getAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            const tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            let foundAttribute = false;\r\n\r\n            for (const attr in technique.attributes) {\r\n                const attribute = technique.attributes[attr];\r\n                const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += getAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            const tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        const shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id,\r\n        };\r\n\r\n        const options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            const functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            const blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ONE &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ZERO &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.DST_COLOR &&\r\n                    blendFunc[1] === EBlendingFunction.ZERO &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * glTF V1 Loader\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    private _importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                gltfRuntime.assetContainer = assetContainer;\r\n                gltfRuntime.importOnlyMeshes = true;\r\n\r\n                if (meshesNames === \"\") {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                } else if (typeof meshesNames === \"string\") {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                    Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n                }\r\n\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                const meshes = new Array<AbstractMesh>();\r\n                const skeletons = new Array<Skeleton>();\r\n\r\n                // Fill arrays of meshes and skeletons\r\n                for (const nde in gltfRuntime.nodes) {\r\n                    const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                    if (node.babylonNode instanceof AbstractMesh) {\r\n                        meshes.push(<AbstractMesh>node.babylonNode);\r\n                    }\r\n                }\r\n\r\n                for (const skl in gltfRuntime.skins) {\r\n                    const skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                    if (skin.babylonSkeleton instanceof Skeleton) {\r\n                        skeletons.push(skin.babylonSkeleton);\r\n                    }\r\n                }\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        importMaterials(gltfRuntime);\r\n                        postLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                            onSuccess(meshes, skeletons);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                    onSuccess(meshes, skeletons);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param assetContainer defines the asset container to use (can be null)\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(\r\n                meshesNames,\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                assetContainer,\r\n                (meshes, skeletons) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: [],\r\n                        skeletons: skeletons,\r\n                        animationGroups: [],\r\n                        lights: [],\r\n                        transformNodes: [],\r\n                        geometries: [],\r\n                    });\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private _loadAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess: () => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                // Load runtime extensios\r\n                GLTFLoaderExtension.LoadRuntimeExtensionsAsync(\r\n                    gltfRuntime,\r\n                    () => {\r\n                        // Create nodes\r\n                        this._createNodes(gltfRuntime);\r\n\r\n                        // Load buffers, shaders, materials, etc.\r\n                        this._loadBuffersAsync(gltfRuntime, () => {\r\n                            this._loadShadersAsync(gltfRuntime, () => {\r\n                                importMaterials(gltfRuntime);\r\n                                postLoad(gltfRuntime);\r\n\r\n                                if (!GLTFFileLoader.IncrementalLoading) {\r\n                                    onSuccess();\r\n                                }\r\n                            });\r\n                        });\r\n\r\n                        if (GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    },\r\n                    onError\r\n                );\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from a loaded gltf file and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadAsync(\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        let hasShaders = false;\r\n\r\n        const processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(\r\n                gltfRuntime,\r\n                sha,\r\n                (shaderString) => {\r\n                    if (shaderString instanceof ArrayBuffer) {\r\n                        return;\r\n                    }\r\n\r\n                    gltfRuntime.loadedShaderCount++;\r\n\r\n                    if (shaderString) {\r\n                        Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                        onload();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            const shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            } else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void): void {\r\n        let hasBuffers = false;\r\n\r\n        const processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(\r\n                gltfRuntime,\r\n                buf,\r\n                (bufferView) => {\r\n                    gltfRuntime.loadedBufferCount++;\r\n\r\n                    if (bufferView) {\r\n                        if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                        }\r\n\r\n                        gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                        onLoad();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            const buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            } else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        let currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        } else {\r\n            // Load all scenes\r\n            for (const thing in gltfRuntime.scenes) {\r\n                currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n                for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading the runtime\r\n     * Return true to stop further extensions from loading the runtime\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     * @param gltfRuntime\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading buffers\r\n     * Return true to stop further extensions from loading this buffer\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @param onProgress\r\n     */\r\n    public loadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading texture buffers\r\n     * Return true to stop further extensions from loading this texture data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for creating textures\r\n     * Return true to stop further extensions from loading this texture\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param buffer\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading shader strings\r\n     * Return true to stop further extensions from loading this shader data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading materials\r\n     * Return true to stop further extensions from loading this material\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    public static LoadRuntimeAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess?: (gltfRuntime: IGLTFRuntime) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    if (!onSuccess) {\r\n                        return;\r\n                    }\r\n                    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    onSuccess();\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (bufferView: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _LoadTextureBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: Nullable<ArrayBufferView>) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _CreateTextureAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        buffer: ArrayBufferView,\r\n        onSuccess: (texture: Texture) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (const extensionName in GLTFLoader.Extensions) {\r\n            const loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n","import { GLTFLoaderExtension, GLTFLoader, GLTFLoaderBase } from \"./glTFLoader\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport type { IGLTFRuntime, IGLTFTexture, IGLTFImage, IGLTFBufferView, IGLTFShader } from \"./glTFLoaderInterfaces\";\r\nimport { EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\n\r\nconst BinaryExtensionBufferName = \"binary_glTF\";\r\n\r\ninterface IGLTFBinaryExtensionShader {\r\n    bufferView: string;\r\n}\r\n\r\ninterface IGLTFBinaryExtensionImage {\r\n    bufferView: string;\r\n    mimeType: string;\r\n    height: number;\r\n    width: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\r\n    private _bin: IDataBuffer;\r\n\r\n    public constructor() {\r\n        super(\"KHR_binary_glTF\");\r\n    }\r\n\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void): boolean {\r\n        const extensionsUsed = (<any>data.json).extensionsUsed;\r\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\r\n            return false;\r\n        }\r\n\r\n        this._bin = data.bin;\r\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n        return true;\r\n    }\r\n\r\n    public loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (id !== BinaryExtensionBufferName) {\r\n            return false;\r\n        }\r\n\r\n        this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));\r\n        return true;\r\n    }\r\n\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void): boolean {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n        if (!source.extensions || !(this.name in source.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const sourceExt: IGLTFBinaryExtensionImage = source.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\r\n        const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n        onSuccess(buffer);\r\n        return true;\r\n    }\r\n\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void): boolean {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n        if (!shader.extensions || !(this.name in shader.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const binaryExtensionShader: IGLTFBinaryExtensionShader = shader.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\r\n        const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n\r\n        setTimeout(() => {\r\n            const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\r\n            onSuccess(shaderString);\r\n        });\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFBinaryExtension());\r\n","import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader\";\r\n\r\nimport type { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\n\r\ninterface IGLTFMaterialsCommonExtensionValues {\r\n    ambient?: number[] | string;\r\n    diffuse?: number[] | string;\r\n    emission?: number[] | string;\r\n    specular?: number[] | string;\r\n    shininess?: number;\r\n    transparency?: number;\r\n}\r\n\r\ninterface IGLTFMaterialsCommonExtension {\r\n    technique: string;\r\n    transparent?: number;\r\n    doubleSided?: boolean;\r\n    values: IGLTFMaterialsCommonExtensionValues;\r\n}\r\n\r\ninterface IGLTFRuntimeCommonExtension {\r\n    lights: { [key: string]: IGLTFLightCommonExtension };\r\n}\r\n\r\ninterface IGLTFLightCommonExtension {\r\n    name: string;\r\n    type: string;\r\n\r\n    ambient?: IGLTFAmbientLightCommonExtension;\r\n    point?: IGLTFPointLightCommonExtension;\r\n    directional?: IGLTFDirectionalLightCommonExtension;\r\n    spot?: IGLTFSpotLightCommonExtension;\r\n}\r\n\r\ninterface IGLTFPointLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\ninterface IGLTFAmbientLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFDirectionalLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFSpotLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    fallOffAngle: number;\r\n    fallOffExponent: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\r\n    constructor() {\r\n        super(\"KHR_materials_common\");\r\n    }\r\n\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime): boolean {\r\n        if (!gltfRuntime.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        // Create lights\r\n        const lights = extension.lights;\r\n        if (lights) {\r\n            for (const thing in lights) {\r\n                const light: IGLTFLightCommonExtension = lights[thing];\r\n\r\n                switch (light.type) {\r\n                    case \"ambient\": {\r\n                        const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\r\n                        const ambient = light.ambient;\r\n                        if (ambient) {\r\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"point\": {\r\n                        const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\r\n                        const point = light.point;\r\n                        if (point) {\r\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"directional\": {\r\n                        const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\r\n                        const directional = light.directional;\r\n                        if (directional) {\r\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"spot\": {\r\n                        const spot = light.spot;\r\n                        if (spot) {\r\n                            const spotLight = new SpotLight(\r\n                                light.name,\r\n                                new Vector3(0, 10, 0),\r\n                                new Vector3(0, -1, 0),\r\n                                spot.fallOffAngle || Math.PI,\r\n                                spot.fallOffExponent || 0.0,\r\n                                gltfRuntime.scene\r\n                            );\r\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \"” not supported\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material || !material.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (extension.technique === \"CONSTANT\") {\r\n            standardMaterial.disableLighting = true;\r\n        }\r\n\r\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\r\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\r\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\r\n\r\n        // Ambient\r\n        if (typeof extension.values.ambient === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\r\n        } else {\r\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\r\n        }\r\n\r\n        // Diffuse\r\n        if (typeof extension.values.diffuse === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\r\n        } else {\r\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\r\n        }\r\n\r\n        // Emission\r\n        if (typeof extension.values.emission === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\r\n        } else {\r\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\r\n        }\r\n\r\n        // Specular\r\n        if (typeof extension.values.specular === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\r\n        } else {\r\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\r\n        // Create buffer from texture url\r\n        GLTFLoaderBase.LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                // Create texture from buffer\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => ((<any>material)[propertyPath] = texture));\r\n            },\r\n            onError\r\n        );\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\r\n","import { Animation } from \"core/Animations/animation\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { INode } from \"./glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\n\r\n/** @internal */\r\nexport type GetValueFn = (target: any, source: Float32Array, offset: number, scale: number) => any;\r\n\r\n/** @internal */\r\nexport function getVector3(_target: any, source: Float32Array, offset: number, scale: number): Vector3 {\r\n    return Vector3.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\nexport function getQuaternion(_target: any, source: Float32Array, offset: number, scale: number): Quaternion {\r\n    return Quaternion.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\nexport function getWeights(target: INode, source: Float32Array, offset: number, scale: number): Array<number> {\r\n    const value = new Array<number>(target._numMorphTargets!);\r\n    for (let i = 0; i < value.length; i++) {\r\n        value[i] = source[offset++] * scale;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport abstract class AnimationPropertyInfo {\r\n    /** @internal */\r\n    public constructor(public readonly type: number, public readonly name: string, public readonly getValue: GetValueFn, public readonly getStride: (target: any) => number) {}\r\n\r\n    protected _buildAnimation(name: string, fps: number, keys: any[]): Animation {\r\n        const babylonAnimation = new Animation(name, this.name, fps, this.type);\r\n        babylonAnimation.setKeys(keys);\r\n        return babylonAnimation;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract buildAnimations(target: any, name: string, fps: number, keys: any[], callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void): void;\r\n}\r\n\r\n/** @internal */\r\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[], callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void): void {\r\n        callback(target._babylonTransformNode!, this._buildAnimation(name, fps, keys));\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[], callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void): void {\r\n        if (target._numMorphTargets) {\r\n            for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\r\n                const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\r\n                babylonAnimation.setKeys(\r\n                    keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\r\n                        interpolation: key.interpolation,\r\n                    }))\r\n                );\r\n\r\n                if (target._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of target._primitiveBabylonMeshes) {\r\n                        if (babylonMesh.morphTargetManager) {\r\n                            const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\r\n                            const babylonAnimationClone = babylonAnimation.clone();\r\n                            morphTarget.animations.push(babylonAnimationClone);\r\n                            callback(morphTarget, babylonAnimationClone);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport const nodeAnimationData = {\r\n    translation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)],\r\n    rotation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)],\r\n    scale: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)],\r\n    weights: [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, (target) => target._numMorphTargets!)],\r\n};\r\n","import type { IndicesArray, Nullable } from \"core/types\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\nimport { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { ITextureCreationOptions } from \"core/Materials/Textures/texture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Buffer, VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport {\r\n    AnimationChannelTargetPath,\r\n    AnimationSamplerInterpolation,\r\n    AccessorType,\r\n    CameraType,\r\n    AccessorComponentType,\r\n    MaterialAlphaMode,\r\n    TextureMinFilter,\r\n    TextureWrapMode,\r\n    TextureMagFilter,\r\n    MeshPrimitiveMode,\r\n} from \"babylonjs-gltf2interface\";\r\nimport type {\r\n    IGLTF,\r\n    ISampler,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IAccessor,\r\n    ISkin,\r\n    ICamera,\r\n    IAnimation,\r\n    IBuffer,\r\n    IBufferView,\r\n    IMaterialPbrMetallicRoughness,\r\n    IMaterial,\r\n    ITextureInfo,\r\n    ITexture,\r\n    IImage,\r\n    IMeshPrimitive,\r\n    IArrayItem,\r\n    _ISamplerData,\r\n    IAnimationChannel,\r\n    IAnimationSampler,\r\n    _IAnimationSamplerData,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DecodeBase64UrlToBinary, IsBase64DataUrl, LoadFileError } from \"core/Misc/fileTools\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Light } from \"core/Lights/light\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { AnimationPropertyInfo } from \"./glTFLoaderAnimation\";\r\nimport { nodeAnimationData } from \"./glTFLoaderAnimation\";\r\n\r\ninterface TypedArrayLike extends ArrayBufferView {\r\n    readonly length: number;\r\n    [n: number]: number;\r\n}\r\n\r\ninterface TypedArrayConstructor {\r\n    new (length: number): TypedArrayLike;\r\n    new (buffer: ArrayBufferLike, byteOffset: number, length?: number): TypedArrayLike;\r\n}\r\n\r\ninterface ILoaderProperty extends IProperty {\r\n    _activeLoaderExtensionFunctions: {\r\n        [id: string]: boolean;\r\n    };\r\n}\r\n\r\ninterface IRegisteredExtension {\r\n    factory: (loader: GLTFLoader) => IGLTFLoaderExtension;\r\n}\r\n\r\ninterface IWithMetadata {\r\n    metadata: any;\r\n}\r\n\r\n// https://stackoverflow.com/a/48218209\r\nfunction mergeDeep(...objects: any[]): any {\r\n    const isObject = (obj: any) => obj && typeof obj === \"object\";\r\n\r\n    return objects.reduce((prev, obj) => {\r\n        Object.keys(obj).forEach((key) => {\r\n            const pVal = prev[key];\r\n            const oVal = obj[key];\r\n\r\n            if (Array.isArray(pVal) && Array.isArray(oVal)) {\r\n                prev[key] = pVal.concat(...oVal);\r\n            } else if (isObject(pVal) && isObject(oVal)) {\r\n                prev[key] = mergeDeep(pVal, oVal);\r\n            } else {\r\n                prev[key] = oVal;\r\n            }\r\n        });\r\n\r\n        return prev;\r\n    }, {});\r\n}\r\n\r\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\r\nexport class ArrayItem {\r\n    /**\r\n     * Gets an item from the given array.\r\n     * @param context The context when loading the asset\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item\r\n     */\r\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\r\n        if (!array || index == undefined || !array[index]) {\r\n            throw new Error(`${context}: Failed to find index (${index})`);\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Assign an `index` field to each item of the given array.\r\n     * @param array The array of items\r\n     */\r\n    public static Assign(array?: IArrayItem[]): void {\r\n        if (array) {\r\n            for (let index = 0; index < array.length; index++) {\r\n                array[index].index = index;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport interface IAnimationTargetInfo {\r\n    /** @internal */\r\n    target: any;\r\n\r\n    /** @internal */\r\n    properties: Array<AnimationPropertyInfo>;\r\n}\r\n\r\n/**\r\n * The glTF 2.0 loader\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    /** @internal */\r\n    public readonly _completePromises = new Array<Promise<any>>();\r\n\r\n    /** @internal */\r\n    public _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    /** Storage */\r\n    public _babylonLights: Light[] = [];\r\n\r\n    /** @internal */\r\n    public _disableInstancedMesh = 0;\r\n\r\n    private readonly _parent: GLTFFileLoader;\r\n    private readonly _extensions = new Array<IGLTFLoaderExtension>();\r\n    private _disposed = false;\r\n    private _rootUrl: Nullable<string> = null;\r\n    private _fileName: Nullable<string> = null;\r\n    private _uniqueRootUrl: Nullable<string> = null;\r\n    private _gltf: IGLTF;\r\n    private _bin: Nullable<IDataBuffer> = null;\r\n    private _babylonScene: Scene;\r\n    private _rootBabylonMesh: Nullable<Mesh> = null;\r\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\r\n    private readonly _postSceneLoadActions = new Array<() => void>();\r\n\r\n    private static _RegisteredExtensions: { [name: string]: IRegisteredExtension } = {};\r\n\r\n    /**\r\n     * The default glTF sampler.\r\n     */\r\n    public static readonly DefaultSampler: ISampler = { index: -1 };\r\n\r\n    /**\r\n     * Registers a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @param factory The factory function that creates the loader extension.\r\n     */\r\n    public static RegisterExtension(name: string, factory: (loader: GLTFLoader) => IGLTFLoaderExtension): void {\r\n        if (GLTFLoader.UnregisterExtension(name)) {\r\n            Logger.Warn(`Extension with the name '${name}' already exists`);\r\n        }\r\n\r\n        GLTFLoader._RegisteredExtensions[name] = {\r\n            factory: factory,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Unregisters a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @returns A boolean indicating whether the extension has been unregistered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFLoader._RegisteredExtensions[name]) {\r\n            return false;\r\n        }\r\n\r\n        delete GLTFLoader._RegisteredExtensions[name];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    public get gltf(): IGLTF {\r\n        if (!this._gltf) {\r\n            throw new Error(\"glTF JSON is not available\");\r\n        }\r\n\r\n        return this._gltf;\r\n    }\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    public get bin(): Nullable<IDataBuffer> {\r\n        return this._bin;\r\n    }\r\n\r\n    /**\r\n     * The parent file loader.\r\n     */\r\n    public get parent(): GLTFFileLoader {\r\n        return this._parent;\r\n    }\r\n\r\n    /**\r\n     * The Babylon scene when loading the asset.\r\n     */\r\n    public get babylonScene(): Scene {\r\n        if (!this._babylonScene) {\r\n            throw new Error(\"Scene is not available\");\r\n        }\r\n\r\n        return this._babylonScene;\r\n    }\r\n\r\n    /**\r\n     * The root Babylon mesh when loading the asset.\r\n     */\r\n    public get rootBabylonMesh(): Nullable<Mesh> {\r\n        return this._rootBabylonMesh;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(parent: GLTFFileLoader) {\r\n        this._parent = parent;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n\r\n        this._completePromises.length = 0;\r\n\r\n        this._extensions.forEach((extension) => extension.dispose && extension.dispose());\r\n        this._extensions.length = 0;\r\n\r\n        (this._gltf as Nullable<IGLTF>) = null; // TODO\r\n        this._bin = null;\r\n        (this._babylonScene as Nullable<Scene>) = null; // TODO\r\n        this._rootBabylonMesh = null;\r\n        this._defaultBabylonMaterialData = {};\r\n        this._postSceneLoadActions.length = 0;\r\n\r\n        this._parent.dispose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName = \"\"\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this._babylonScene = scene;\r\n            this._assetContainer = container;\r\n            this._loadData(data);\r\n\r\n            let nodes: Nullable<Array<number>> = null;\r\n\r\n            if (meshesNames) {\r\n                const nodeMap: { [name: string]: number } = {};\r\n                if (this._gltf.nodes) {\r\n                    for (const node of this._gltf.nodes) {\r\n                        if (node.name) {\r\n                            nodeMap[node.name] = node.index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const names = meshesNames instanceof Array ? meshesNames : [meshesNames];\r\n                nodes = names.map((name) => {\r\n                    const node = nodeMap[name];\r\n                    if (node === undefined) {\r\n                        throw new Error(`Failed to find node '${name}'`);\r\n                    }\r\n\r\n                    return node;\r\n                });\r\n            }\r\n\r\n            return this._loadAsync(rootUrl, fileName, nodes, () => {\r\n                return {\r\n                    meshes: this._getMeshes(),\r\n                    particleSystems: [],\r\n                    skeletons: this._getSkeletons(),\r\n                    animationGroups: this._getAnimationGroups(),\r\n                    lights: this._babylonLights,\r\n                    transformNodes: this._getTransformNodes(),\r\n                    geometries: this._getGeometries(),\r\n                };\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName = \"\"): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this._babylonScene = scene;\r\n            this._loadData(data);\r\n            return this._loadAsync(rootUrl, fileName, null, () => undefined);\r\n        });\r\n    }\r\n\r\n    private _loadAsync<T>(rootUrl: string, fileName: string, nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n                this._rootUrl = rootUrl;\r\n                this._uniqueRootUrl = !rootUrl.startsWith(\"file:\") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;\r\n                this._fileName = fileName;\r\n\r\n                this._loadExtensions();\r\n                this._checkExtensions();\r\n\r\n                const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\r\n                const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\r\n\r\n                this._parent._startPerformanceCounter(loadingToReadyCounterName);\r\n                this._parent._startPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                this._parent._setState(GLTFLoaderState.LOADING);\r\n                this._extensionsOnLoading();\r\n\r\n                const promises = new Array<Promise<any>>();\r\n\r\n                // Block the marking of materials dirty until the scene is loaded.\r\n                const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\r\n                this._babylonScene.blockMaterialDirtyMechanism = true;\r\n\r\n                if (!this.parent.loadOnlyMaterials) {\r\n                    if (nodes) {\r\n                        promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\r\n                    } else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\r\n                        const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\r\n                        promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\r\n                    }\r\n                }\r\n\r\n                if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {\r\n                    for (let m = 0; m < this._gltf.materials.length; ++m) {\r\n                        const material = this._gltf.materials[m];\r\n                        const context = \"/materials/\" + m;\r\n                        const babylonDrawMode = Material.TriangleFillMode;\r\n\r\n                        promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {}));\r\n                    }\r\n                }\r\n\r\n                // Restore the blocking of material dirty.\r\n                this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\r\n\r\n                if (this._parent.compileMaterials) {\r\n                    promises.push(this._compileMaterialsAsync());\r\n                }\r\n\r\n                if (this._parent.compileShadowGenerators) {\r\n                    promises.push(this._compileShadowGeneratorsAsync());\r\n                }\r\n\r\n                const resultPromise = Promise.all(promises).then(() => {\r\n                    if (this._rootBabylonMesh) {\r\n                        this._rootBabylonMesh.setEnabled(true);\r\n                    }\r\n\r\n                    this._extensionsOnReady();\r\n                    this._parent._setState(GLTFLoaderState.READY);\r\n\r\n                    this._startAnimations();\r\n\r\n                    return resultFunc();\r\n                });\r\n\r\n                return resultPromise.then((result) => {\r\n                    this._parent._endPerformanceCounter(loadingToReadyCounterName);\r\n\r\n                    Tools.SetImmediate(() => {\r\n                        if (!this._disposed) {\r\n                            Promise.all(this._completePromises).then(\r\n                                () => {\r\n                                    this._parent._endPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                                    this._parent._setState(GLTFLoaderState.COMPLETE);\r\n\r\n                                    this._parent.onCompleteObservable.notifyObservers(undefined);\r\n                                    this._parent.onCompleteObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                },\r\n                                (error) => {\r\n                                    this._parent.onErrorObservable.notifyObservers(error);\r\n                                    this._parent.onErrorObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                }\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    return result;\r\n                });\r\n            })\r\n            .catch((error) => {\r\n                if (!this._disposed) {\r\n                    this._parent.onErrorObservable.notifyObservers(error);\r\n                    this._parent.onErrorObservable.clear();\r\n\r\n                    this.dispose();\r\n                }\r\n\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    private _loadData(data: IGLTFLoaderData): void {\r\n        this._gltf = data.json as IGLTF;\r\n        this._setupData();\r\n\r\n        if (data.bin) {\r\n            const buffers = this._gltf.buffers;\r\n            if (buffers && buffers[0] && !buffers[0].uri) {\r\n                const binaryBuffer = buffers[0];\r\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\r\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\r\n                }\r\n\r\n                this._bin = data.bin;\r\n            } else {\r\n                Logger.Warn(\"Unexpected BIN chunk\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setupData(): void {\r\n        ArrayItem.Assign(this._gltf.accessors);\r\n        ArrayItem.Assign(this._gltf.animations);\r\n        ArrayItem.Assign(this._gltf.buffers);\r\n        ArrayItem.Assign(this._gltf.bufferViews);\r\n        ArrayItem.Assign(this._gltf.cameras);\r\n        ArrayItem.Assign(this._gltf.images);\r\n        ArrayItem.Assign(this._gltf.materials);\r\n        ArrayItem.Assign(this._gltf.meshes);\r\n        ArrayItem.Assign(this._gltf.nodes);\r\n        ArrayItem.Assign(this._gltf.samplers);\r\n        ArrayItem.Assign(this._gltf.scenes);\r\n        ArrayItem.Assign(this._gltf.skins);\r\n        ArrayItem.Assign(this._gltf.textures);\r\n\r\n        if (this._gltf.nodes) {\r\n            const nodeParents: { [index: number]: number } = {};\r\n            for (const node of this._gltf.nodes) {\r\n                if (node.children) {\r\n                    for (const index of node.children) {\r\n                        nodeParents[index] = node.index;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const rootNode = this._createRootNode();\r\n            for (const node of this._gltf.nodes) {\r\n                const parentIndex = nodeParents[node.index];\r\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name in GLTFLoader._RegisteredExtensions) {\r\n            const extension = GLTFLoader._RegisteredExtensions[name].factory(this);\r\n            if (extension.name !== name) {\r\n                Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\r\n            }\r\n\r\n            this._extensions.push(extension);\r\n            this._parent.onExtensionLoadedObservable.notifyObservers(extension);\r\n        }\r\n\r\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\r\n        this._parent.onExtensionLoadedObservable.clear();\r\n    }\r\n\r\n    private _checkExtensions(): void {\r\n        if (this._gltf.extensionsRequired) {\r\n            for (const name of this._gltf.extensionsRequired) {\r\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\r\n                if (!available) {\r\n                    throw new Error(`Require extension ${name} is not available`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createRootNode(): INode {\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\r\n        this._rootBabylonMesh._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        this._rootBabylonMesh.setEnabled(false);\r\n\r\n        const rootNode: INode = {\r\n            _babylonTransformNode: this._rootBabylonMesh,\r\n            index: -1,\r\n        };\r\n\r\n        switch (this._parent.coordinateSystemMode) {\r\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\r\n                if (!this._babylonScene.useRightHandedSystem) {\r\n                    rootNode.rotation = [0, 1, 0, 0];\r\n                    rootNode.scale = [1, 1, -1];\r\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\r\n                this._babylonScene.useRightHandedSystem = true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\r\n            }\r\n        }\r\n\r\n        this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF scene.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${scene.name || \"\"}`);\r\n\r\n        if (scene.nodes) {\r\n            for (const index of scene.nodes) {\r\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\r\n                promises.push(\r\n                    this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\r\n                        babylonMesh.parent = this._rootBabylonMesh;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        for (const action of this._postSceneLoadActions) {\r\n            action();\r\n        }\r\n\r\n        promises.push(this._loadAnimationsAsync());\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private _forEachPrimitive(node: INode, callback: (babylonMesh: AbstractMesh) => void): void {\r\n        if (node._primitiveBabylonMeshes) {\r\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                callback(babylonMesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGeometries(): Geometry[] {\r\n        const geometries = new Array<Geometry>();\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    const geometry = (babylonMesh as Mesh).geometry;\r\n                    if (geometry && geometries.indexOf(geometry) === -1) {\r\n                        geometries.push(geometry);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return geometries;\r\n    }\r\n\r\n    private _getMeshes(): AbstractMesh[] {\r\n        const meshes = new Array<AbstractMesh>();\r\n\r\n        // Root mesh is always first, if available.\r\n        if (this._rootBabylonMesh) {\r\n            meshes.push(this._rootBabylonMesh);\r\n        }\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    meshes.push(babylonMesh);\r\n                });\r\n            }\r\n        }\r\n\r\n        return meshes;\r\n    }\r\n\r\n    private _getTransformNodes(): TransformNode[] {\r\n        const transformNodes = new Array<TransformNode>();\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\r\n                    transformNodes.push(node._babylonTransformNode);\r\n                }\r\n                if (node._babylonTransformNodeForSkin) {\r\n                    transformNodes.push(node._babylonTransformNodeForSkin);\r\n                }\r\n            }\r\n        }\r\n\r\n        return transformNodes;\r\n    }\r\n\r\n    private _getSkeletons(): Skeleton[] {\r\n        const skeletons = new Array<Skeleton>();\r\n\r\n        const skins = this._gltf.skins;\r\n        if (skins) {\r\n            for (const skin of skins) {\r\n                if (skin._data) {\r\n                    skeletons.push(skin._data.babylonSkeleton);\r\n                }\r\n            }\r\n        }\r\n\r\n        return skeletons;\r\n    }\r\n\r\n    private _getAnimationGroups(): AnimationGroup[] {\r\n        const animationGroups = new Array<AnimationGroup>();\r\n\r\n        const animations = this._gltf.animations;\r\n        if (animations) {\r\n            for (const animation of animations) {\r\n                if (animation._babylonAnimationGroup) {\r\n                    animationGroups.push(animation._babylonAnimationGroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationGroups;\r\n    }\r\n\r\n    private _startAnimations(): void {\r\n        switch (this._parent.animationStartMode) {\r\n            case GLTFLoaderAnimationStartMode.NONE: {\r\n                // do nothing\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.FIRST: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                if (babylonAnimationGroups.length !== 0) {\r\n                    babylonAnimationGroups[0].start(true);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.ALL: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\r\n                    babylonAnimationGroup.start(true);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF node.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void = () => {}): Promise<TransformNode> {\r\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (node._babylonTransformNode) {\r\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${node.name || \"\"}`);\r\n\r\n        const loadNode = (babylonTransformNode: TransformNode) => {\r\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\r\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\r\n\r\n            if (node.camera != undefined) {\r\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\r\n                promises.push(\r\n                    this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\r\n                        babylonCamera.parent = babylonTransformNode;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (node.children) {\r\n                for (const index of node.children) {\r\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\r\n                    promises.push(\r\n                        this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\r\n                            childBabylonMesh.parent = babylonTransformNode;\r\n                        })\r\n                    );\r\n                }\r\n            }\r\n\r\n            assign(babylonTransformNode);\r\n        };\r\n\r\n        if (node.mesh == undefined || node.skin != undefined) {\r\n            const nodeName = node.name || `node${node.index}`;\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const transformNode = new TransformNode(nodeName, this._babylonScene);\r\n            transformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            if (node.mesh == undefined) {\r\n                node._babylonTransformNode = transformNode;\r\n            } else {\r\n                node._babylonTransformNodeForSkin = transformNode;\r\n            }\r\n            loadNode(transformNode);\r\n        }\r\n\r\n        if (node.mesh != undefined) {\r\n            if (node.skin == undefined) {\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\r\n            } else {\r\n                // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n                // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\r\n                // transform, which effectively ignores the transform of the skinned mesh, as per spec.\r\n\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(\r\n                    this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {\r\n                        const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin!;\r\n\r\n                        // Merge the metadata from the skin node to the skinned mesh in case a loader extension added metadata.\r\n                        babylonTransformNode.metadata = mergeDeep(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});\r\n\r\n                        const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\r\n                        promises.push(\r\n                            this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {\r\n                                this._forEachPrimitive(node, (babylonMesh) => {\r\n                                    babylonMesh.skeleton = babylonSkeleton;\r\n                                });\r\n\r\n                                // Wait until all the nodes are parented before parenting the skinned mesh.\r\n                                this._postSceneLoadActions.push(() => {\r\n                                    if (skin.skeleton != undefined) {\r\n                                        // Place the skinned mesh node as a sibling of the skeleton root node.\r\n                                        // Handle special case when the parent of the skeleton root is the skinned mesh.\r\n                                        const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent!;\r\n                                        if (node.index === parentNode.index) {\r\n                                            babylonTransformNode.parent = babylonTransformNodeForSkin.parent;\r\n                                        } else {\r\n                                            babylonTransformNode.parent = parentNode._babylonTransformNode!;\r\n                                        }\r\n                                    } else {\r\n                                        babylonTransformNode.parent = this._rootBabylonMesh;\r\n                                    }\r\n\r\n                                    this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });\r\n                                });\r\n                            })\r\n                        );\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                if ((babylonMesh as Mesh).geometry && (babylonMesh as Mesh).geometry!.useBoundingInfoFromGeometry) {\r\n                    // simply apply the world matrices to the bounding info - the extends are already ok\r\n                    babylonMesh._updateBoundingInfo();\r\n                } else {\r\n                    babylonMesh.refreshBoundingInfo(true);\r\n                }\r\n            });\r\n\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    private _loadMeshAsync(context: string, node: INode, mesh: IMesh, assign: (babylonTransformNode: TransformNode) => void): Promise<TransformNode> {\r\n        const primitives = mesh.primitives;\r\n        if (!primitives || !primitives.length) {\r\n            throw new Error(`${context}: Primitives are missing`);\r\n        }\r\n\r\n        if (primitives[0].index == undefined) {\r\n            ArrayItem.Assign(primitives);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\r\n\r\n        const name = node.name || `node${node.index}`;\r\n\r\n        if (primitives.length === 1) {\r\n            const primitive = mesh.primitives[0];\r\n            promises.push(\r\n                this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\r\n                    node._babylonTransformNode = babylonMesh;\r\n                    node._primitiveBabylonMeshes = [babylonMesh];\r\n                })\r\n            );\r\n        } else {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\r\n            node._babylonTransformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            node._primitiveBabylonMeshes = [];\r\n            for (const primitive of primitives) {\r\n                promises.push(\r\n                    this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\r\n                        babylonMesh.parent = node._babylonTransformNode!;\r\n                        node._primitiveBabylonMeshes!.push(babylonMesh);\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        assign(node._babylonTransformNode!);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal Define this method to modify the default behavior when loading data for mesh primitives.\r\n     * @param context The context when loading the asset\r\n     * @param name The mesh name when loading the asset\r\n     * @param node The glTF node when loading the asset\r\n     * @param mesh The glTF mesh when loading the asset\r\n     * @param primitive The glTF mesh primitive property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\r\n     */\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Promise<AbstractMesh> {\r\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\r\n\r\n        let babylonAbstractMesh: AbstractMesh;\r\n        let promise: Promise<any>;\r\n\r\n        if (shouldInstance && primitive._instanceData) {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name) as InstancedMesh;\r\n            babylonAbstractMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            promise = primitive._instanceData.promise;\r\n        } else {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonMesh = new Mesh(name, this._babylonScene);\r\n            babylonMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            babylonMesh.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n\r\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\r\n            promises.push(\r\n                this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {\r\n                    return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\r\n                        if (this._disposed) {\r\n                            return;\r\n                        }\r\n\r\n                        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n                        babylonGeometry.applyToMesh(babylonMesh);\r\n                        babylonGeometry._parentContainer = this._assetContainer;\r\n                        this._babylonScene._blockEntityCollection = false;\r\n                    });\r\n                })\r\n            );\r\n\r\n            const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n            if (primitive.material == undefined) {\r\n                let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\r\n                if (!babylonMaterial) {\r\n                    babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\r\n                    this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n                    this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\r\n                }\r\n                babylonMesh.material = babylonMaterial;\r\n            } else if (!this.parent.skipMaterials) {\r\n                const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\r\n                promises.push(\r\n                    this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        babylonMesh.material = babylonMaterial;\r\n                    })\r\n                );\r\n            }\r\n\r\n            promise = Promise.all(promises);\r\n\r\n            if (shouldInstance) {\r\n                primitive._instanceData = {\r\n                    babylonSourceMesh: babylonMesh,\r\n                    promise: promise,\r\n                };\r\n            }\r\n\r\n            babylonAbstractMesh = babylonMesh;\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\r\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\r\n        assign(babylonAbstractMesh);\r\n\r\n        this.logClose();\r\n\r\n        return promise.then(() => {\r\n            return babylonAbstractMesh;\r\n        });\r\n    }\r\n\r\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Promise<Geometry> {\r\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const attributes = primitive.attributes;\r\n        if (!attributes) {\r\n            throw new Error(`${context}: Attributes are missing`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\r\n\r\n        if (primitive.indices == undefined) {\r\n            babylonMesh.isUnIndexed = true;\r\n        } else {\r\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\r\n            promises.push(\r\n                this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    babylonGeometry.setIndices(data);\r\n                })\r\n            );\r\n        }\r\n\r\n        const loadAttribute = (attribute: string, kind: string, callback?: (accessor: IAccessor) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                babylonMesh._delayInfo.push(kind);\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\r\n                    if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\r\n                        const mmin = accessor.min as [number, number, number],\r\n                            mmax = accessor.max as [number, number, number];\r\n                        if (mmin !== undefined && mmax !== undefined) {\r\n                            if (accessor.normalized && accessor.componentType !== AccessorComponentType.FLOAT) {\r\n                                let divider = 1;\r\n                                switch (accessor.componentType) {\r\n                                    case AccessorComponentType.BYTE:\r\n                                        divider = 127.0;\r\n                                        break;\r\n                                    case AccessorComponentType.UNSIGNED_BYTE:\r\n                                        divider = 255.0;\r\n                                        break;\r\n                                    case AccessorComponentType.SHORT:\r\n                                        divider = 32767.0;\r\n                                        break;\r\n                                    case AccessorComponentType.UNSIGNED_SHORT:\r\n                                        divider = 65535.0;\r\n                                        break;\r\n                                }\r\n                                for (let i = 0; i < 3; ++i) {\r\n                                    mmin[i] = Math.max(mmin[i] / divider, -1.0);\r\n                                    mmax[i] = Math.max(mmax[i] / divider, -1.0);\r\n                                }\r\n                            }\r\n                            const min = TmpVectors.Vector3[0],\r\n                                max = TmpVectors.Vector3[1];\r\n                            min.copyFromFloats(...mmin);\r\n                            max.copyFromFloats(...mmax);\r\n                            babylonGeometry._boundingInfo = new BoundingInfo(min, max);\r\n                            babylonGeometry.useBoundingInfoFromGeometry = true;\r\n                        }\r\n                    }\r\n                    babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\r\n                })\r\n            );\r\n\r\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\r\n                babylonMesh.numBoneInfluencers = 8;\r\n            }\r\n\r\n            if (callback) {\r\n                callback(accessor);\r\n            }\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n        loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n        loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n        loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n        loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\r\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\r\n            if (accessor.type === AccessorType.VEC4) {\r\n                babylonMesh.hasVertexAlpha = true;\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonGeometry;\r\n        });\r\n    }\r\n\r\n    private _createMorphTargets(context: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, babylonMesh: Mesh): void {\r\n        if (!primitive.targets) {\r\n            return;\r\n        }\r\n\r\n        if (node._numMorphTargets == undefined) {\r\n            node._numMorphTargets = primitive.targets.length;\r\n        } else if (primitive.targets.length !== node._numMorphTargets) {\r\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\r\n        }\r\n\r\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\r\n\r\n        babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\r\n        babylonMesh.morphTargetManager.areUpdatesFrozen = true;\r\n\r\n        for (let index = 0; index < primitive.targets.length; index++) {\r\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\r\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\r\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\r\n            // TODO: tell the target whether it has positions, normals, tangents\r\n        }\r\n    }\r\n\r\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\r\n        if (!primitive.targets) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const morphTargetManager = babylonMesh.morphTargetManager!;\r\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\r\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\r\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            morphTargetManager.areUpdatesFrozen = false;\r\n        });\r\n    }\r\n\r\n    private _loadMorphTargetVertexDataAsync(context: string, babylonGeometry: Geometry, attributes: { [name: string]: number }, babylonMorphTarget: MorphTarget): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\r\n            if (!babylonVertexBuffer) {\r\n                return;\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    setData(babylonVertexBuffer, data);\r\n                })\r\n            );\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\r\n            const positions = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                positions[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setPositions(positions);\r\n        });\r\n\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\r\n            const normals = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\r\n                normals[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setNormals(normals);\r\n        });\r\n\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\r\n            const tangents = new Float32Array((data.length / 3) * 4);\r\n            let dataIndex = 0;\r\n            babylonVertexBuffer.forEach((data.length / 3) * 4, (value, index) => {\r\n                // Tangent data for morph targets is stored as xyz delta.\r\n                // The vertexData.tangent is stored as xyzw.\r\n                // So we need to skip every fourth vertexData.tangent.\r\n                if ((index + 1) % 4 !== 0) {\r\n                    tangents[dataIndex] = data[dataIndex] + value;\r\n                    dataIndex++;\r\n                }\r\n            });\r\n            babylonMorphTarget.setTangents(tangents);\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private static _LoadTransform(node: INode, babylonNode: TransformNode): void {\r\n        // Ignore the TRS of skinned nodes.\r\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n        if (node.skin != undefined) {\r\n            return;\r\n        }\r\n\r\n        let position = Vector3.Zero();\r\n        let rotation = Quaternion.Identity();\r\n        let scaling = Vector3.One();\r\n\r\n        if (node.matrix) {\r\n            const matrix = Matrix.FromArray(node.matrix);\r\n            matrix.decompose(scaling, rotation, position);\r\n        } else {\r\n            if (node.translation) {\r\n                position = Vector3.FromArray(node.translation);\r\n            }\r\n            if (node.rotation) {\r\n                rotation = Quaternion.FromArray(node.rotation);\r\n            }\r\n            if (node.scale) {\r\n                scaling = Vector3.FromArray(node.scale);\r\n            }\r\n        }\r\n\r\n        babylonNode.position = position;\r\n        babylonNode.rotationQuaternion = rotation;\r\n        babylonNode.scaling = scaling;\r\n    }\r\n\r\n    private _loadSkinAsync(context: string, node: INode, skin: ISkin, assign: (babylonSkeleton: Skeleton) => void): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (skin._data) {\r\n            assign(skin._data.babylonSkeleton);\r\n            return skin._data.promise;\r\n        }\r\n\r\n        const skeletonId = `skeleton${skin.index}`;\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\r\n        babylonSkeleton._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        this._loadBones(context, skin, babylonSkeleton);\r\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\r\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\r\n        });\r\n\r\n        skin._data = {\r\n            babylonSkeleton: babylonSkeleton,\r\n            promise: promise,\r\n        };\r\n\r\n        assign(babylonSkeleton);\r\n\r\n        return promise;\r\n    }\r\n\r\n    private _loadBones(context: string, skin: ISkin, babylonSkeleton: Skeleton): void {\r\n        if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\r\n            const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);\r\n            if (rootNode) {\r\n                if (skin.skeleton === undefined) {\r\n                    skin.skeleton = rootNode.index;\r\n                } else {\r\n                    const isParent = (a: INode, b: INode): boolean => {\r\n                        for (; b.parent; b = b.parent) {\r\n                            if (b.parent === a) {\r\n                                return true;\r\n                            }\r\n                        }\r\n\r\n                        return false;\r\n                    };\r\n\r\n                    const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);\r\n                    if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\r\n                        Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);\r\n                        skin.skeleton = rootNode.index;\r\n                    }\r\n                }\r\n            } else {\r\n                Logger.Warn(`${context}: Failed to find common root`);\r\n            }\r\n        }\r\n\r\n        const babylonBones: { [index: number]: Bone } = {};\r\n        for (const index of skin.joints) {\r\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\r\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\r\n        }\r\n    }\r\n\r\n    private _findSkeletonRootNode(context: string, joints: Array<number>): Nullable<INode> {\r\n        if (joints.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const paths: { [joint: number]: Array<INode> } = {};\r\n        for (const index of joints) {\r\n            const path = new Array<INode>();\r\n            let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);\r\n            while (node.index !== -1) {\r\n                path.unshift(node);\r\n                node = node.parent!;\r\n            }\r\n            paths[index] = path;\r\n        }\r\n\r\n        let rootNode: Nullable<INode> = null;\r\n        for (let i = 0; ; ++i) {\r\n            let path = paths[joints[0]];\r\n            if (i >= path.length) {\r\n                return rootNode;\r\n            }\r\n\r\n            const node = path[i];\r\n            for (let j = 1; j < joints.length; ++j) {\r\n                path = paths[joints[j]];\r\n                if (i >= path.length || node !== path[i]) {\r\n                    return rootNode;\r\n                }\r\n            }\r\n\r\n            rootNode = node;\r\n        }\r\n    }\r\n\r\n    private _loadBone(node: INode, skin: ISkin, babylonSkeleton: Skeleton, babylonBones: { [index: number]: Bone }): Bone {\r\n        let babylonBone = babylonBones[node.index];\r\n        if (babylonBone) {\r\n            return babylonBone;\r\n        }\r\n\r\n        let parentBabylonBone: Nullable<Bone> = null;\r\n        if (node.index !== skin.skeleton) {\r\n            if (node.parent && node.parent.index !== -1) {\r\n                parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\r\n            } else if (skin.skeleton !== undefined) {\r\n                Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);\r\n            }\r\n        }\r\n\r\n        const boneIndex = skin.joints.indexOf(node.index);\r\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\r\n        babylonBones[node.index] = babylonBone;\r\n\r\n        // Wait until the scene is loaded to ensure the transform nodes are loaded.\r\n        this._postSceneLoadActions.push(() => {\r\n            // Link the Babylon bone with the corresponding Babylon transform node.\r\n            // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\r\n            babylonBone.linkTransformNode(node._babylonTransformNode!);\r\n        });\r\n\r\n        return babylonBone;\r\n    }\r\n\r\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkin): Promise<Nullable<Float32Array>> {\r\n        if (skin.inverseBindMatrices == undefined) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\r\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\r\n    }\r\n\r\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\r\n        for (const babylonBone of babylonSkeleton.bones) {\r\n            const baseMatrix = Matrix.Identity();\r\n            const boneIndex = babylonBone._index!;\r\n            if (inverseBindMatricesData && boneIndex !== -1) {\r\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\r\n                baseMatrix.invertToRef(baseMatrix);\r\n            }\r\n\r\n            const babylonParentBone = babylonBone.getParent();\r\n            if (babylonParentBone) {\r\n                baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\r\n            }\r\n\r\n            babylonBone.updateMatrix(baseMatrix, false, false);\r\n            babylonBone._updateDifferenceMatrix(undefined, false);\r\n        }\r\n    }\r\n\r\n    private _getNodeMatrix(node: INode): Matrix {\r\n        return node.matrix\r\n            ? Matrix.FromArray(node.matrix)\r\n            : Matrix.Compose(\r\n                  node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\r\n                  node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\r\n                  node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero()\r\n              );\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF camera.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void = () => {}): Promise<Camera> {\r\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${camera.name || \"\"}`);\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\r\n        babylonCamera._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        babylonCamera.ignoreParentScaling = true;\r\n        camera._babylonCamera = babylonCamera;\r\n\r\n        babylonCamera.rotation = new Vector3(0, Math.PI, 0);\r\n\r\n        switch (camera.type) {\r\n            case CameraType.PERSPECTIVE: {\r\n                const perspective = camera.perspective;\r\n                if (!perspective) {\r\n                    throw new Error(`${context}: Camera perspective properties are missing`);\r\n                }\r\n\r\n                babylonCamera.fov = perspective.yfov;\r\n                babylonCamera.minZ = perspective.znear;\r\n                babylonCamera.maxZ = perspective.zfar || 0;\r\n                break;\r\n            }\r\n            case CameraType.ORTHOGRAPHIC: {\r\n                if (!camera.orthographic) {\r\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\r\n                }\r\n\r\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\r\n                babylonCamera.orthoRight = camera.orthographic.xmag;\r\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\r\n                babylonCamera.orthoTop = camera.orthographic.ymag;\r\n                babylonCamera.minZ = camera.orthographic.znear;\r\n                babylonCamera.maxZ = camera.orthographic.zfar;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\r\n            }\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\r\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\r\n        assign(babylonCamera);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonCamera;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationsAsync(): Promise<void> {\r\n        const animations = this._gltf.animations;\r\n        if (!animations) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<void>>();\r\n\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n            promises.push(\r\n                this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {\r\n                    // Delete the animation group if it ended up not having any animations in it.\r\n                    if (animationGroup.targetedAnimations.length === 0) {\r\n                        animationGroup.dispose();\r\n                    }\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Promise<AnimationGroup> {\r\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\r\n        babylonAnimationGroup._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        animation._babylonAnimationGroup = babylonAnimationGroup;\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        ArrayItem.Assign(animation.channels);\r\n        ArrayItem.Assign(animation.samplers);\r\n\r\n        for (const channel of animation.channels) {\r\n            promises.push(\r\n                this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {\r\n                    babylonTarget.animations = babylonTarget.animations || [];\r\n                    babylonTarget.animations.push(babylonAnimation);\r\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            babylonAnimationGroup.normalize(0);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        if (channel.target.node == undefined) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\r\n\r\n        // Ignore animations that have no animation targets.\r\n        if (\r\n            (channel.target.path === AnimationChannelTargetPath.WEIGHTS && !targetNode._numMorphTargets) ||\r\n            (channel.target.path !== AnimationChannelTargetPath.WEIGHTS && !targetNode._babylonTransformNode)\r\n        ) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        let properties: Array<AnimationPropertyInfo>;\r\n        switch (channel.target.path) {\r\n            case AnimationChannelTargetPath.TRANSLATION: {\r\n                properties = nodeAnimationData.translation;\r\n                break;\r\n            }\r\n            case AnimationChannelTargetPath.ROTATION: {\r\n                properties = nodeAnimationData.rotation;\r\n                break;\r\n            }\r\n            case AnimationChannelTargetPath.SCALE: {\r\n                properties = nodeAnimationData.scale;\r\n                break;\r\n            }\r\n            case AnimationChannelTargetPath.WEIGHTS: {\r\n                properties = nodeAnimationData.weights;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n            }\r\n        }\r\n\r\n        const targetInfo: IAnimationTargetInfo = {\r\n            target: targetNode,\r\n            properties: properties,\r\n        };\r\n\r\n        return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param targetInfo The glTF target and properties\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelFromTargetInfoAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        targetInfo: IAnimationTargetInfo,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const fps = this.parent.targetFps;\r\n        const invfps = 1 / fps;\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            let numAnimations = 0;\r\n\r\n            // Extract the corresponding values from the read value.\r\n            // GLTF values may be dispatched to several Babylon properties.\r\n            // For example, baseColorFactor [`r`, `g`, `b`, `a`] is dispatched to\r\n            // - albedoColor as Color3(`r`, `g`, `b`)\r\n            // - alpha as `a`\r\n            for (const property of targetInfo.properties) {\r\n                const stride = property.getStride(targetInfo.target);\r\n                const input = data.input;\r\n                const output = data.output;\r\n                const keys = new Array<IAnimationKey>(input.length);\r\n                let outputOffset = 0;\r\n\r\n                switch (data.interpolation) {\r\n                    case AnimationSamplerInterpolation.STEP: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                                interpolation: AnimationKeyInterpolation.STEP,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const inTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n                            const outTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                inTangent: inTangent,\r\n                                value: value,\r\n                                outTangent: outTangent,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.LINEAR: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (outputOffset > 0) {\r\n                    const name = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;\r\n                    property.buildAnimations(targetInfo.target, name, fps, keys, (babylonAnimatable, babylonAnimation) => {\r\n                        ++numAnimations;\r\n                        onLoad(babylonAnimatable, babylonAnimation);\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor),\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer.\r\n     * @param context The context when loading the asset\r\n     * @param buffer The glTF buffer property\r\n     * @param byteOffset The byte offset to use\r\n     * @param byteLength The byte length to use\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!buffer._data) {\r\n            if (buffer.uri) {\r\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\r\n            } else {\r\n                if (!this._bin) {\r\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n                }\r\n\r\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\r\n            }\r\n        }\r\n\r\n        return buffer._data.then((data) => {\r\n            try {\r\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\r\n            } catch (e) {\r\n                throw new Error(`${context}: ${e.message}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer view.\r\n     * @param context The context when loading the asset\r\n     * @param bufferView The glTF buffer view property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (bufferView._data) {\r\n            return bufferView._data;\r\n        }\r\n\r\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\r\n        bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\r\n\r\n        return bufferView._data;\r\n    }\r\n\r\n    private _loadAccessorAsync(context: string, accessor: IAccessor, constructor: TypedArrayConstructor): Promise<ArrayBufferView> {\r\n        if (accessor._data) {\r\n            return accessor._data;\r\n        }\r\n\r\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\r\n        const length = numComponents * accessor.count;\r\n\r\n        if (accessor.bufferView == undefined) {\r\n            accessor._data = Promise.resolve(new constructor(length));\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\r\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\r\n                } else {\r\n                    const typedArray = new constructor(length);\r\n                    VertexBuffer.ForEach(\r\n                        data,\r\n                        accessor.byteOffset || 0,\r\n                        bufferView.byteStride || byteStride,\r\n                        numComponents,\r\n                        accessor.componentType,\r\n                        typedArray.length,\r\n                        accessor.normalized || false,\r\n                        (value, index) => {\r\n                            typedArray[index] = value;\r\n                        }\r\n                    );\r\n                    return typedArray;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const sparse = accessor.sparse;\r\n            accessor._data = accessor._data.then((data) => {\r\n                const typedArray = data as TypedArrayLike;\r\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\r\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\r\n                return Promise.all([\r\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\r\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView),\r\n                ]).then(([indicesData, valuesData]) => {\r\n                    const indices = GLTFLoader._GetTypedArray(\r\n                        `${context}/sparse/indices`,\r\n                        sparse.indices.componentType,\r\n                        indicesData,\r\n                        sparse.indices.byteOffset,\r\n                        sparse.count\r\n                    ) as IndicesArray;\r\n\r\n                    const sparseLength = numComponents * sparse.count;\r\n                    let values: TypedArrayLike;\r\n\r\n                    if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\r\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                    } else {\r\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                        values = new constructor(sparseLength);\r\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\r\n                            values[index] = value;\r\n                        });\r\n                    }\r\n\r\n                    let valuesIndex = 0;\r\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\r\n                        let dataIndex = indices[indicesIndex] * numComponents;\r\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\r\n                            typedArray[dataIndex++] = values[valuesIndex++];\r\n                        }\r\n                    }\r\n\r\n                    return typedArray;\r\n                });\r\n            });\r\n        }\r\n\r\n        return accessor._data;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array> {\r\n        return this._loadAccessorAsync(context, accessor, Float32Array) as Promise<Float32Array>;\r\n    }\r\n\r\n    private _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<IndicesArray> {\r\n        if (accessor.type !== AccessorType.SCALAR) {\r\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\r\n        }\r\n\r\n        if (\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT\r\n        ) {\r\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<IndicesArray>;\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\r\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\r\n            });\r\n        }\r\n\r\n        return accessor._data as Promise<IndicesArray>;\r\n    }\r\n\r\n    private _loadVertexBufferViewAsync(bufferView: IBufferView): Promise<Buffer> {\r\n        if (bufferView._babylonBuffer) {\r\n            return bufferView._babylonBuffer;\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return new Buffer(engine, data, false);\r\n        });\r\n\r\n        return bufferView._babylonBuffer;\r\n    }\r\n\r\n    private _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<VertexBuffer> {\r\n        if (accessor._babylonVertexBuffer?.[kind]) {\r\n            return accessor._babylonVertexBuffer[kind];\r\n        }\r\n\r\n        if (!accessor._babylonVertexBuffer) {\r\n            accessor._babylonVertexBuffer = {};\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n\r\n        if (accessor.sparse) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(engine, data, kind, false);\r\n            });\r\n        }\r\n        // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\r\n        // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\r\n        else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(engine, data, kind, false);\r\n            });\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {\r\n                const size = GLTFLoader._GetNumComponents(context, accessor.type);\r\n                return new VertexBuffer(\r\n                    engine,\r\n                    babylonBuffer,\r\n                    kind,\r\n                    false,\r\n                    false,\r\n                    bufferView.byteStride,\r\n                    false,\r\n                    accessor.byteOffset,\r\n                    size,\r\n                    accessor.componentType,\r\n                    accessor.normalized,\r\n                    true,\r\n                    1,\r\n                    true\r\n                );\r\n            });\r\n        }\r\n\r\n        return accessor._babylonVertexBuffer[kind];\r\n    }\r\n\r\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughness, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            } else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\r\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        babylonMaterial.albedoTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (properties.metallicRoughnessTexture) {\r\n                properties.metallicRoughnessTexture.nonColorData = true;\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\r\n                        babylonMaterial.metallicTexture = texture;\r\n                    })\r\n                );\r\n\r\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void = () => {}\r\n    ): Promise<Material> {\r\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        material._data = material._data || {};\r\n        let babylonData = material._data[babylonDrawMode];\r\n        if (!babylonData) {\r\n            this.logOpen(`${context} ${material.name || \"\"}`);\r\n\r\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\r\n\r\n            babylonData = {\r\n                babylonMaterial: babylonMaterial,\r\n                babylonMeshes: [],\r\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial),\r\n            };\r\n\r\n            material._data[babylonDrawMode] = babylonData;\r\n\r\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\r\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        if (babylonMesh) {\r\n            babylonData.babylonMeshes.push(babylonMesh);\r\n\r\n            babylonMesh.onDisposeObservable.addOnce(() => {\r\n                const index = babylonData.babylonMeshes.indexOf(babylonMesh);\r\n                if (index !== -1) {\r\n                    babylonData.babylonMeshes.splice(index, 1);\r\n                }\r\n            });\r\n        }\r\n\r\n        assign(babylonData.babylonMaterial);\r\n\r\n        return babylonData.promise.then(() => {\r\n            return babylonData.babylonMaterial;\r\n        });\r\n    }\r\n\r\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonMaterial = new PBRMaterial(name, this._babylonScene);\r\n        babylonMaterial._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        babylonMaterial.fillMode = babylonDrawMode;\r\n        babylonMaterial.enableSpecularAntiAliasing = true;\r\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n        babylonMaterial.metallic = 1;\r\n        babylonMaterial.roughness = 1;\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a Babylon material from a glTF material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Material {\r\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const name = material.name || `material${material.index}`;\r\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Loads properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n\r\n        if (material.pbrMetallicRoughness) {\r\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\r\n        }\r\n\r\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        if (material.normalTexture) {\r\n            material.normalTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Normal)`;\r\n                    babylonMaterial.bumpTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\r\n            babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\r\n            if (material.normalTexture.scale != undefined && babylonMaterial.bumpTexture) {\r\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\r\n            }\r\n\r\n            babylonMaterial.forceIrradianceInFragment = true;\r\n        }\r\n\r\n        if (material.occlusionTexture) {\r\n            material.occlusionTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Occlusion)`;\r\n                    babylonMaterial.ambientTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.useAmbientInGrayScale = true;\r\n            if (material.occlusionTexture.strength != undefined) {\r\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\r\n            }\r\n        }\r\n\r\n        if (material.emissiveTexture) {\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Emissive)`;\r\n                    babylonMaterial.emissiveTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the alpha properties from a glTF material into a Babylon material.\r\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     */\r\n    public loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: Material): void {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\r\n        switch (alphaMode) {\r\n            case MaterialAlphaMode.OPAQUE: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.MASK: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\r\n                babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                }\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.BLEND: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF texture info.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        if (textureInfo.texCoord! >= 6) {\r\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\r\n        }\r\n\r\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\r\n        texture._textureInfo = textureInfo;\r\n\r\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\r\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\r\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\r\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\r\n            assign(babylonTexture);\r\n        });\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context} ${texture.name || \"\"}`);\r\n\r\n        const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);\r\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\r\n        const promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createTextureAsync(\r\n        context: string,\r\n        sampler: ISampler,\r\n        image: IImage,\r\n        assign: (babylonTexture: BaseTexture) => void = () => {},\r\n        textureLoaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ): Promise<BaseTexture> {\r\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const deferred = new Deferred<void>();\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const textureCreationOptions: ITextureCreationOptions = {\r\n            noMipmap: samplerData.noMipMaps,\r\n            invertY: false,\r\n            samplingMode: samplerData.samplingMode,\r\n            onLoad: () => {\r\n                if (!this._disposed) {\r\n                    deferred.resolve();\r\n                }\r\n            },\r\n            onError: (message?: string, exception?: any) => {\r\n                if (!this._disposed) {\r\n                    deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || \"Failed to load texture\"}`));\r\n                }\r\n            },\r\n            mimeType: image.mimeType,\r\n            loaderOptions: textureLoaderOptions,\r\n            useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers,\r\n        };\r\n        const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\r\n        babylonTexture._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        promises.push(deferred.promise);\r\n\r\n        promises.push(\r\n            this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\r\n                const name = image.uri || `${this._fileName}#image${image.index}`;\r\n                const dataUrl = `data:${this._uniqueRootUrl}${name}`;\r\n                babylonTexture.updateURL(dataUrl, data);\r\n            })\r\n        );\r\n\r\n        babylonTexture.wrapU = samplerData.wrapU;\r\n        babylonTexture.wrapV = samplerData.wrapV;\r\n        assign(babylonTexture);\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonTexture;\r\n        });\r\n    }\r\n\r\n    private _loadSampler(context: string, sampler: ISampler): _ISamplerData {\r\n        if (!sampler._data) {\r\n            sampler._data = {\r\n                noMipMaps: sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR,\r\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\r\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\r\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT),\r\n            };\r\n        }\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF image.\r\n     * @param context The context when loading the asset\r\n     * @param image The glTF image property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView> {\r\n        if (!image._data) {\r\n            this.logOpen(`${context} ${image.name || \"\"}`);\r\n\r\n            if (image.uri) {\r\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\r\n            } else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\r\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        return image._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF uri.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property associated with the uri\r\n     * @param uri The base64 or relative uri\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!GLTFLoader._ValidateUri(uri)) {\r\n            throw new Error(`${context}: '${uri}' is invalid`);\r\n        }\r\n\r\n        if (IsBase64DataUrl(uri)) {\r\n            const data = new Uint8Array(DecodeBase64UrlToBinary(uri));\r\n            this.log(`${context}: Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\r\n            return Promise.resolve(data);\r\n        }\r\n\r\n        this.log(`${context}: Loading ${uri}`);\r\n\r\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\r\n            return new Promise((resolve, reject) => {\r\n                this._parent._loadFile(\r\n                    this._babylonScene,\r\n                    url,\r\n                    (data) => {\r\n                        if (!this._disposed) {\r\n                            this.log(`${context}: Loaded ${uri} (${(data as ArrayBuffer).byteLength} bytes)`);\r\n                            resolve(new Uint8Array(data as ArrayBuffer));\r\n                        }\r\n                    },\r\n                    true,\r\n                    (request) => {\r\n                        reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\r\n                    }\r\n                );\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a JSON pointer to the metadata of the Babylon object at `<object>.metadata.gltf.pointers`.\r\n     * @param babylonObject the Babylon object with metadata\r\n     * @param pointer the JSON pointer\r\n     */\r\n    public static AddPointerMetadata(babylonObject: IWithMetadata, pointer: string): void {\r\n        const metadata = (babylonObject.metadata = babylonObject.metadata || {});\r\n        const gltf = (metadata.gltf = metadata.gltf || {});\r\n        const pointers = (gltf.pointers = gltf.pointers || []);\r\n        pointers.push(pointer);\r\n    }\r\n\r\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\r\n        // Set defaults if undefined\r\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\r\n\r\n        switch (mode) {\r\n            case TextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case TextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case TextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                Logger.Warn(`${context}: Invalid value (${mode})`);\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    private static _GetTextureSamplingMode(context: string, sampler: ISampler): number {\r\n        // Set defaults if undefined\r\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\r\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\r\n\r\n        if (magFilter === TextureMagFilter.LINEAR) {\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.LINEAR_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.LINEAR_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n            }\r\n        } else {\r\n            if (magFilter !== TextureMagFilter.NEAREST) {\r\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\r\n            }\r\n\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.NEAREST_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.NEAREST_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArrayConstructor(context: string, componentType: AccessorComponentType): TypedArrayConstructor {\r\n        switch (componentType) {\r\n            case AccessorComponentType.BYTE:\r\n                return Int8Array;\r\n            case AccessorComponentType.UNSIGNED_BYTE:\r\n                return Uint8Array;\r\n            case AccessorComponentType.SHORT:\r\n                return Int16Array;\r\n            case AccessorComponentType.UNSIGNED_SHORT:\r\n                return Uint16Array;\r\n            case AccessorComponentType.UNSIGNED_INT:\r\n                return Uint32Array;\r\n            case AccessorComponentType.FLOAT:\r\n                return Float32Array;\r\n            default:\r\n                throw new Error(`${context}: Invalid component type ${componentType}`);\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArray(\r\n        context: string,\r\n        componentType: AccessorComponentType,\r\n        bufferView: ArrayBufferView,\r\n        byteOffset: number | undefined,\r\n        length: number\r\n    ): TypedArrayLike {\r\n        const buffer = bufferView.buffer;\r\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\r\n\r\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\r\n\r\n        const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\r\n        if (byteOffset % componentTypeLength !== 0) {\r\n            // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\r\n            Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);\r\n            return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\r\n        }\r\n\r\n        return new constructor(buffer, byteOffset, length);\r\n    }\r\n\r\n    private static _GetNumComponents(context: string, type: string): number {\r\n        switch (type) {\r\n            case \"SCALAR\":\r\n                return 1;\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid type (${type})`);\r\n    }\r\n\r\n    private static _ValidateUri(uri: string): boolean {\r\n        return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetDrawMode(context: string, mode: number | undefined): number {\r\n        if (mode == undefined) {\r\n            mode = MeshPrimitiveMode.TRIANGLES;\r\n        }\r\n\r\n        switch (mode) {\r\n            case MeshPrimitiveMode.POINTS:\r\n                return Material.PointListDrawMode;\r\n            case MeshPrimitiveMode.LINES:\r\n                return Material.LineListDrawMode;\r\n            case MeshPrimitiveMode.LINE_LOOP:\r\n                return Material.LineLoopDrawMode;\r\n            case MeshPrimitiveMode.LINE_STRIP:\r\n                return Material.LineStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLES:\r\n                return Material.TriangleFillMode;\r\n            case MeshPrimitiveMode.TRIANGLE_STRIP:\r\n                return Material.TriangleStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLE_FAN:\r\n                return Material.TriangleFanDrawMode;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\r\n    }\r\n\r\n    private _compileMaterialsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile materials\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (this._gltf.materials) {\r\n            for (const material of this._gltf.materials) {\r\n                if (material._data) {\r\n                    for (const babylonDrawMode in material._data) {\r\n                        const babylonData = material._data[babylonDrawMode];\r\n                        for (const babylonMesh of babylonData.babylonMeshes) {\r\n                            // Ensure nonUniformScaling is set if necessary.\r\n                            babylonMesh.computeWorldMatrix(true);\r\n\r\n                            const babylonMaterial = babylonData.babylonMaterial;\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\r\n                            if (this._parent.useClipPlane) {\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile materials\");\r\n        });\r\n    }\r\n\r\n    private _compileShadowGeneratorsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const lights = this._babylonScene.lights;\r\n        for (const light of lights) {\r\n            const generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                promises.push(generator.forceCompilationAsync());\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\r\n        });\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtension) => void): void {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _applyExtensions<T>(property: IProperty, functionName: string, actionAsync: (extension: IGLTFLoaderExtension) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                const id = `${extension.name}.${functionName}`;\r\n                const loaderProperty = property as ILoaderProperty;\r\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\r\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\r\n                if (!activeLoaderExtensionFunctions[id]) {\r\n                    activeLoaderExtensionFunctions[id] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    } finally {\r\n                        delete activeLoaderExtensionFunctions[id];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _extensionsOnLoading(): void {\r\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\r\n    }\r\n\r\n    private _extensionsOnReady(): void {\r\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\r\n    }\r\n\r\n    private _extensionsLoadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\r\n    }\r\n\r\n    private _extensionsLoadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\r\n    }\r\n\r\n    private _extensionsLoadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\r\n    }\r\n\r\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\r\n    }\r\n\r\n    private _extensionsLoadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return this._applyExtensions(\r\n            primitive,\r\n            \"loadMeshPrimitive\",\r\n            (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsLoadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterial\",\r\n            (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsCreateMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\r\n    }\r\n\r\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterialProperties\",\r\n            (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial)\r\n        );\r\n    }\r\n\r\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\r\n    }\r\n\r\n    private _extensionsLoadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\r\n    }\r\n\r\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\r\n    }\r\n\r\n    private _extensionsLoadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            animation,\r\n            \"loadAnimationChannel\",\r\n            (extension) => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad)\r\n        );\r\n    }\r\n\r\n    private _extensionsLoadSkinAsync(context: string, node: INode, skin: ISkin): Nullable<Promise<void>> {\r\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\r\n    }\r\n\r\n    private _extensionsLoadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\r\n    }\r\n\r\n    private _extensionsLoadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\r\n    }\r\n\r\n    private _extensionsLoadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load an glTF extension.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extension from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extension does not exist\r\n     */\r\n    public static LoadExtensionAsync<TExtension = any, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extensions) {\r\n            return null;\r\n        }\r\n\r\n        const extensions = property.extensions;\r\n\r\n        const extension = extensions[extensionName] as TExtension;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load a glTF extra.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extra from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extra does not exist\r\n     */\r\n    public static LoadExtraAsync<TExtra = any, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extras) {\r\n            return null;\r\n        }\r\n\r\n        const extras = property.extras;\r\n\r\n        const extra = extras[extensionName] as TExtra;\r\n        if (!extra) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\r\n    }\r\n\r\n    /**\r\n     * Checks for presence of an extension.\r\n     * @param name The name of the extension to check\r\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\r\n     */\r\n    public isExtensionUsed(name: string): boolean {\r\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Increments the indentation level and logs a message.\r\n     * @param message The message to log\r\n     */\r\n    public logOpen(message: string): void {\r\n        this._parent._logOpen(message);\r\n    }\r\n\r\n    /**\r\n     * Decrements the indentation level.\r\n     */\r\n    public logClose(): void {\r\n        this._parent._logClose();\r\n    }\r\n\r\n    /**\r\n     * Logs a message\r\n     * @param message The message to log\r\n     */\r\n    public log(message: string): void {\r\n        this._parent._log(message);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public startPerformanceCounter(counterName: string): void {\r\n        this._parent._startPerformanceCounter(counterName);\r\n    }\r\n\r\n    /**\r\n     * Ends a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public endPerformanceCounter(counterName: string): void {\r\n        this._parent._endPerformanceCounter(counterName);\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\r\n","import type { Nullable } from \"core/types\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"core/Maths/sphericalPolynomial\";\r\nimport { Quaternion, Matrix } from \"core/Maths/math.vector\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { RawCubeTexture } from \"core/Materials/Textures/rawCubeTexture\";\r\n\r\nimport type { IEXTLightsImageBased_LightReferenceImageBased, IEXTLightsImageBased_LightImageBased, IEXTLightsImageBased } from \"babylonjs-gltf2interface\";\r\nimport type { IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"EXT_lights_image_based\";\r\n\r\ndeclare module \"babylonjs-gltf2interface\" {\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    interface IEXTLightsImageBased_LightImageBased {\r\n        _babylonTexture?: BaseTexture;\r\n        _loaded?: Promise<void>;\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_lights_image_based implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IEXTLightsImageBased_LightImageBased[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IEXTLightsImageBased;\r\n            this._lights = extension.lights;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTLightsImageBased_LightReferenceImageBased>(context, scene, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\r\n            promises.push(\r\n                this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\r\n                    this._loader.babylonScene.environmentTexture = texture;\r\n                })\r\n            );\r\n\r\n            this._loader.logClose();\r\n\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadLightAsync(context: string, light: IEXTLightsImageBased_LightImageBased): Promise<BaseTexture> {\r\n        if (!light._loaded) {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._loader.logOpen(`${context}`);\r\n\r\n            const imageData = new Array<Array<ArrayBufferView>>(light.specularImages.length);\r\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\r\n                const faces = light.specularImages[mipmap];\r\n                imageData[mipmap] = new Array<ArrayBufferView>(faces.length);\r\n                for (let face = 0; face < faces.length; face++) {\r\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\r\n                    this._loader.logOpen(`${specularImageContext}`);\r\n\r\n                    const index = faces[face];\r\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\r\n                    promises.push(\r\n                        this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {\r\n                            imageData[mipmap][face] = data;\r\n                        })\r\n                    );\r\n\r\n                    this._loader.logClose();\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n\r\n            light._loaded = Promise.all(promises).then(() => {\r\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\r\n                babylonTexture.name = light.name || \"environment\";\r\n                light._babylonTexture = babylonTexture;\r\n\r\n                if (light.intensity != undefined) {\r\n                    babylonTexture.level = light.intensity;\r\n                }\r\n\r\n                if (light.rotation) {\r\n                    let rotation = Quaternion.FromArray(light.rotation);\r\n\r\n                    // Invert the rotation so that positive rotation is counter-clockwise.\r\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\r\n                        rotation = Quaternion.Inverse(rotation);\r\n                    }\r\n\r\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\r\n                }\r\n\r\n                if (!light.irradianceCoefficients) {\r\n                    throw new Error(`${context}: Irradiance coefficients are missing`);\r\n                }\r\n\r\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\r\n                sphericalHarmonics.scaleInPlace(light.intensity);\r\n\r\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n\r\n                // Compute the lod generation scale to fit exactly to the number of levels available.\r\n                const lodGenerationScale = (imageData.length - 1) / Scalar.Log2(light.specularImageSize);\r\n                return babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\r\n            });\r\n        }\r\n\r\n        return light._loaded.then(() => {\r\n            return light._babylonTexture!;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_lights_image_based(loader));\r\n","import { Vector3, Quaternion, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { INode } from \"../glTFLoaderInterfaces\";\r\n\r\nimport type { IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\n\r\nimport \"core/Meshes/thinInstanceMesh\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMeshGpuInstancing, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            this._loader._disableInstancedMesh++;\r\n\r\n            const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);\r\n\r\n            this._loader._disableInstancedMesh--;\r\n\r\n            if (!node._primitiveBabylonMeshes) {\r\n                return promise;\r\n            }\r\n\r\n            const promises = new Array<Promise<Nullable<Float32Array>>>();\r\n            let instanceCount = 0;\r\n\r\n            const loadAttribute = (attribute: string) => {\r\n                if (extension.attributes[attribute] == undefined) {\r\n                    promises.push(Promise.resolve(null));\r\n                    return;\r\n                }\r\n\r\n                const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);\r\n                promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));\r\n\r\n                if (instanceCount === 0) {\r\n                    instanceCount = accessor.count;\r\n                } else if (instanceCount !== accessor.count) {\r\n                    throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"TRANSLATION\");\r\n            loadAttribute(\"ROTATION\");\r\n            loadAttribute(\"SCALE\");\r\n\r\n            return promise.then((babylonTransformNode) => {\r\n                return Promise.all(promises).then(([translationBuffer, rotationBuffer, scaleBuffer]) => {\r\n                    const matrices = new Float32Array(instanceCount * 16);\r\n\r\n                    TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\r\n                    TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\r\n                    TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\r\n\r\n                    for (let i = 0; i < instanceCount; ++i) {\r\n                        translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\r\n                        rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\r\n                        scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\r\n\r\n                        Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\r\n\r\n                        TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\r\n                    }\r\n\r\n                    for (const babylonMesh of node._primitiveBabylonMeshes!) {\r\n                        (babylonMesh as Mesh).thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\r\n                    }\r\n\r\n                    return babylonTransformNode;\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_mesh_gpu_instancing(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { ArrayItem, GLTFLoader } from \"../glTFLoader\";\r\nimport type { IBufferView } from \"../glTFLoaderInterfaces\";\r\nimport type { IEXTMeshoptCompression } from \"babylonjs-gltf2interface\";\r\nimport { MeshoptCompression } from \"core/Meshes/Compression/meshoptCompression\";\r\n\r\nconst NAME = \"EXT_meshopt_compression\";\r\n\r\ninterface IBufferViewMeshopt extends IBufferView {\r\n    _meshOptData?: Promise<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md)\r\n *\r\n * This extension uses a WebAssembly decoder module from https://github.com/zeux/meshoptimizer/tree/master/js\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_meshopt_compression implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMeshoptCompression, ArrayBufferView>(context, bufferView, this.name, (extensionContext, extension) => {\r\n            const bufferViewMeshopt = bufferView as IBufferViewMeshopt;\r\n            if (bufferViewMeshopt._meshOptData) {\r\n                return bufferViewMeshopt._meshOptData;\r\n            }\r\n\r\n            const buffer = ArrayItem.Get(`${context}/buffer`, this._loader.gltf.buffers, extension.buffer);\r\n            bufferViewMeshopt._meshOptData = this._loader.loadBufferAsync(`/buffers/${buffer.index}`, buffer, extension.byteOffset || 0, extension.byteLength).then((buffer) => {\r\n                return MeshoptCompression.Default.decodeGltfBufferAsync(buffer as Uint8Array, extension.count, extension.byteStride, extension.mode, extension.filter);\r\n            });\r\n\r\n            return bufferViewMeshopt._meshOptData;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_meshopt_compression(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IEXTTextureWebP } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"EXT_texture_webp\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_texture_webp implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTTextureWebP, BaseTexture>(context, texture, this.name, (extensionContext, extension) => {\r\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return this._loader._createTextureAsync(\r\n                context,\r\n                sampler,\r\n                image,\r\n                (babylonTexture) => {\r\n                    assign(babylonTexture);\r\n                },\r\n                undefined,\r\n                !texture._textureInfo.nonColorData\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_texture_webp(loader));\r\n","import { DracoCompression } from \"core/Meshes/Compression/dracoCompression\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport { MeshPrimitiveMode, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { IKHRDracoMeshCompression } from \"babylonjs-gltf2interface\";\r\nimport type { IMeshPrimitive, IBufferView } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_draco_mesh_compression\";\r\n\r\ninterface IBufferViewDraco extends IBufferView {\r\n    _dracoBabylonGeometry?: Promise<Geometry>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_draco_mesh_compression implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * The draco compression used to decode vertex data or DracoCompression.Default if not defined\r\n     */\r\n    public dracoCompression?: DracoCompression;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        delete this.dracoCompression;\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRDracoMeshCompression, Geometry>(context, primitive, this.name, (extensionContext, extension) => {\r\n            if (primitive.mode != undefined) {\r\n                if (primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP && primitive.mode !== MeshPrimitiveMode.TRIANGLES) {\r\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\r\n                }\r\n\r\n                // TODO: handle triangle strips\r\n                if (primitive.mode === MeshPrimitiveMode.TRIANGLE_STRIP) {\r\n                    throw new Error(`${context}: Mode ${primitive.mode} is not currently supported`);\r\n                }\r\n            }\r\n\r\n            const attributes: {\r\n                [kind: string]: number;\r\n            } = {};\r\n            const dividers: {\r\n                [kind: string]: number;\r\n            } = {};\r\n            const loadAttribute = (name: string, kind: string) => {\r\n                const uniqueId = extension.attributes[name];\r\n                if (uniqueId === undefined || primitive.attributes[name] === undefined) {\r\n                    return;\r\n                }\r\n\r\n                attributes[kind] = uniqueId;\r\n                const accessor = ArrayItem.Get(`${context}/attributes/${name}`, this._loader.gltf.accessors, primitive.attributes[name]);\r\n                if (accessor.normalized && accessor.componentType !== AccessorComponentType.FLOAT) {\r\n                    let divider = 1;\r\n                    switch (accessor.componentType) {\r\n                        case AccessorComponentType.BYTE:\r\n                            divider = 127.0;\r\n                            break;\r\n                        case AccessorComponentType.UNSIGNED_BYTE:\r\n                            divider = 255.0;\r\n                            break;\r\n                        case AccessorComponentType.SHORT:\r\n                            divider = 32767.0;\r\n                            break;\r\n                        case AccessorComponentType.UNSIGNED_SHORT:\r\n                            divider = 65535.0;\r\n                            break;\r\n                    }\r\n                    dividers[kind] = divider;\r\n                }\r\n\r\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                    babylonMesh._delayInfo.push(kind);\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n            loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n            loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n            loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n            loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\r\n\r\n            const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView) as IBufferViewDraco;\r\n            if (!bufferView._dracoBabylonGeometry) {\r\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                    const dracoCompression = this.dracoCompression || DracoCompression.Default;\r\n                    return dracoCompression\r\n                        .decodeMeshAsync(data, attributes, dividers)\r\n                        .then((babylonVertexData) => {\r\n                            const babylonGeometry = new Geometry(babylonMesh.name, this._loader.babylonScene);\r\n                            babylonVertexData.applyToGeometry(babylonGeometry);\r\n                            return babylonGeometry;\r\n                        })\r\n                        .catch((error) => {\r\n                            throw new Error(`${context}: ${error.message}`);\r\n                        });\r\n                });\r\n            }\r\n\r\n            return bufferView._dracoBabylonGeometry;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_draco_mesh_compression(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IKHRLightsPunctual_LightReference } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { INode, IKHRLightsPunctual_Light } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** hidden */\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IKHRLightsPunctual_Light[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as any;\r\n            this._lights = extension.lights;\r\n            ArrayItem.Assign(this._lights);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRLightsPunctual_LightReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                let babylonLight: Light;\r\n\r\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                switch (light.type) {\r\n                    case KHRLightsPunctual_LightType.DIRECTIONAL: {\r\n                        babylonLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.POINT: {\r\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.SPOT: {\r\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\r\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\r\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\r\n                        babylonLight = babylonSpotLight;\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        this._loader.babylonScene._blockEntityCollection = false;\r\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\r\n                    }\r\n                }\r\n\r\n                babylonLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                light._babylonLight = babylonLight;\r\n\r\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\r\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\r\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\r\n                babylonLight.parent = babylonMesh;\r\n\r\n                this._loader._babylonLights.push(babylonLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_lights(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsPbrSpecularGlossiness } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_pbrSpecularGlossiness\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_pbrSpecularGlossiness implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 200;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsPbrSpecularGlossiness>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, material, extension, babylonMaterial));\r\n            this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadSpecularGlossinessPropertiesAsync(context: string, material: IMaterial, properties: IKHRMaterialsPbrSpecularGlossiness, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.metallic = null;\r\n        babylonMaterial.roughness = null;\r\n\r\n        if (properties.diffuseFactor) {\r\n            babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);\r\n            babylonMaterial.alpha = properties.diffuseFactor[3];\r\n        } else {\r\n            babylonMaterial.albedoColor = Color3.White();\r\n        }\r\n\r\n        babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();\r\n        babylonMaterial.microSurface = properties.glossinessFactor == undefined ? 1 : properties.glossinessFactor;\r\n\r\n        if (properties.diffuseTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseTexture`, properties.diffuseTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse)`;\r\n                    babylonMaterial.albedoTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.specularGlossinessTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularGlossinessTexture`, properties.specularGlossinessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular Glossiness)`;\r\n                    babylonMaterial.reflectivityTexture = texture;\r\n                    babylonMaterial.reflectivityTexture.hasAlpha = true;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_pbrSpecularGlossiness(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_unlit implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 210;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, () => {\r\n            return this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\r\n        });\r\n    }\r\n\r\n    private _loadUnlitPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n        babylonMaterial.unlit = true;\r\n\r\n        const properties = material.pbrMetallicRoughness;\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            } else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        babylonMaterial.albedoTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_unlit(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsClearcoat } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)\r\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#7F7PN6#8)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsClearcoat>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadClearCoatPropertiesAsync(context: string, properties: IKHRMaterialsClearcoat, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.clearCoat.isEnabled = true;\r\n        babylonMaterial.clearCoat.useRoughnessFromMainTexture = false;\r\n        babylonMaterial.clearCoat.remapF0OnInterfaceChange = false;\r\n\r\n        if (properties.clearcoatFactor != undefined) {\r\n            babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;\r\n        } else {\r\n            babylonMaterial.clearCoat.intensity = 0;\r\n        }\r\n\r\n        if (properties.clearcoatTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatTexture`, properties.clearcoatTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Intensity)`;\r\n                    babylonMaterial.clearCoat.texture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.clearcoatRoughnessFactor != undefined) {\r\n            babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;\r\n        } else {\r\n            babylonMaterial.clearCoat.roughness = 0;\r\n        }\r\n\r\n        if (properties.clearcoatRoughnessTexture) {\r\n            (properties.clearcoatRoughnessTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatRoughnessTexture`, properties.clearcoatRoughnessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Roughness)`;\r\n                    babylonMaterial.clearCoat.textureRoughness = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.clearcoatNormalTexture) {\r\n            (properties.clearcoatNormalTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatNormalTexture`, properties.clearcoatNormalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Normal)`;\r\n                    babylonMaterial.clearCoat.bumpTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;\r\n            babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;\r\n            if (properties.clearcoatNormalTexture.scale != undefined) {\r\n                babylonMaterial.clearCoat.bumpTexture!.level = properties.clearcoatNormalTexture.scale;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_clearcoat(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsIridescence } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_iridescence\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_iridescence implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 195;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsIridescence>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadIridescencePropertiesAsync(context: string, properties: IKHRMaterialsIridescence, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.iridescence.isEnabled = true;\r\n\r\n        babylonMaterial.iridescence.intensity = properties.iridescenceFactor ?? 0;\r\n        babylonMaterial.iridescence.indexOfRefraction = properties.iridescenceIor ?? (properties as any).iridescenceIOR ?? 1.3;\r\n        babylonMaterial.iridescence.minimumThickness = properties.iridescenceThicknessMinimum ?? 100;\r\n        babylonMaterial.iridescence.maximumThickness = properties.iridescenceThicknessMaximum ?? 400;\r\n\r\n        if (properties.iridescenceTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/iridescenceTexture`, properties.iridescenceTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Iridescence Intensity)`;\r\n                    babylonMaterial.iridescence.texture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.iridescenceThicknessTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/iridescenceThicknessTexture`, properties.iridescenceThicknessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Iridescence Thickness)`;\r\n                    babylonMaterial.iridescence.thicknessTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_iridescence(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsEmissiveStrength } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_emissive_strength\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_emissive_strength implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 170;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsEmissiveStrength>(context, material, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial).then(() => {\r\n                this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadEmissiveProperties(context: string, properties: IKHRMaterialsEmissiveStrength, babylonMaterial: Material): void {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        if (properties.emissiveStrength !== undefined) {\r\n            babylonMaterial.emissiveColor.scaleToRef(properties.emissiveStrength, babylonMaterial.emissiveColor);\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_emissive_strength(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IKHRMaterialsSheen } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md)\r\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#BNIZX6#4)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_sheen implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsSheen>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadSheenPropertiesAsync(context: string, properties: IKHRMaterialsSheen, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.sheen.isEnabled = true;\r\n        babylonMaterial.sheen.intensity = 1;\r\n\r\n        if (properties.sheenColorFactor != undefined) {\r\n            babylonMaterial.sheen.color = Color3.FromArray(properties.sheenColorFactor);\r\n        } else {\r\n            babylonMaterial.sheen.color = Color3.Black();\r\n        }\r\n\r\n        if (properties.sheenColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/sheenColorTexture`, properties.sheenColorTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Sheen Color)`;\r\n                    babylonMaterial.sheen.texture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.sheenRoughnessFactor !== undefined) {\r\n            babylonMaterial.sheen.roughness = properties.sheenRoughnessFactor;\r\n        } else {\r\n            babylonMaterial.sheen.roughness = 0;\r\n        }\r\n\r\n        if (properties.sheenRoughnessTexture) {\r\n            (properties.sheenRoughnessTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/sheenRoughnessTexture`, properties.sheenRoughnessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Sheen Roughness)`;\r\n                    babylonMaterial.sheen.textureRoughness = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        babylonMaterial.sheen.albedoScaling = true;\r\n        babylonMaterial.sheen.useRoughnessFromMainTexture = false;\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_sheen(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IKHRMaterialsSpecular } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_specular\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_specular implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsSpecular>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadSpecularPropertiesAsync(context: string, properties: IKHRMaterialsSpecular, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (properties.specularFactor !== undefined) {\r\n            babylonMaterial.metallicF0Factor = properties.specularFactor;\r\n        }\r\n\r\n        if (properties.specularColorFactor !== undefined) {\r\n            babylonMaterial.metallicReflectanceColor = Color3.FromArray(properties.specularColorFactor);\r\n        }\r\n\r\n        if (properties.specularTexture) {\r\n            (properties.specularTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularTexture`, properties.specularTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular F0 Strength)`;\r\n                    babylonMaterial.metallicReflectanceTexture = texture;\r\n                    babylonMaterial.useOnlyMetallicFromMetallicReflectanceTexture = true;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.specularColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularColorTexture`, properties.specularColorTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular F0 Color)`;\r\n                    babylonMaterial.reflectanceTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_specular(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsIor } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_ior\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_ior implements IGLTFLoaderExtension {\r\n    /**\r\n     * Default ior Value from the spec.\r\n     */\r\n    private static readonly _DEFAULT_IOR = 1.5;\r\n\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 180;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsIor>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadIorPropertiesAsync(context: string, properties: IKHRMaterialsIor, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        if (properties.ior !== undefined) {\r\n            babylonMaterial.indexOfRefraction = properties.ior;\r\n        } else {\r\n            babylonMaterial.indexOfRefraction = KHR_materials_ior._DEFAULT_IOR;\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_ior(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Node } from \"core/node\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { INode, IMeshPrimitive, IMesh } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRMaterialVariants_Mapping, IKHRMaterialVariants_Variant, IKHRMaterialVariants_Variants } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_variants\";\r\n\r\ninterface IVariantsMap {\r\n    [key: string]: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n}\r\n\r\ninterface IExtensionMetadata {\r\n    lastSelected: Nullable<string | Array<string>>;\r\n    original: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n    variants: IVariantsMap;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_variants implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _variants?: Array<IKHRMaterialVariants_Variant>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public static GetAvailableVariants(rootMesh: Mesh): string[] {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            return [];\r\n        }\r\n\r\n        return Object.keys(extensionMetadata.variants);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public getAvailableVariants(rootMesh: Mesh): string[] {\r\n        return KHR_materials_variants.GetAvailableVariants(rootMesh);\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootMesh The glTF root mesh\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public static SelectVariant(rootMesh: Mesh, variantName: string | string[]): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        const select = (variantName: string): void => {\r\n            const entries = extensionMetadata.variants[variantName];\r\n            if (entries) {\r\n                for (const entry of entries) {\r\n                    entry.mesh.material = entry.material;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (variantName instanceof Array) {\r\n            for (const name of variantName) {\r\n                select(name);\r\n            }\r\n        } else {\r\n            select(variantName);\r\n        }\r\n\r\n        extensionMetadata.lastSelected = variantName;\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootMesh The glTF root mesh\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public selectVariant(rootMesh: Mesh, variantName: string | string[]): void {\r\n        return KHR_materials_variants.SelectVariant(rootMesh, variantName);\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootMesh The glTF root mesh\r\n     */\r\n    public static Reset(rootMesh: Mesh): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        for (const entry of extensionMetadata.original) {\r\n            entry.mesh.material = entry.material;\r\n        }\r\n\r\n        extensionMetadata.lastSelected = null;\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootMesh The glTF root mesh\r\n     */\r\n    public reset(rootMesh: Mesh): void {\r\n        return KHR_materials_variants.Reset(rootMesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public static GetLastSelectedVariant(rootMesh: Mesh): Nullable<string | string[]> {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        return extensionMetadata.lastSelected;\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public getLastSelectedVariant(rootMesh: Mesh): Nullable<string | string[]> {\r\n        return KHR_materials_variants.GetLastSelectedVariant(rootMesh);\r\n    }\r\n\r\n    private static _GetExtensionMetadata(rootMesh: Nullable<Mesh>): Nullable<IExtensionMetadata> {\r\n        return rootMesh?.metadata?.gltf?.[NAME] || null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IKHRMaterialVariants_Variants;\r\n            this._variants = extension.variants;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialVariants_Mapping, AbstractMesh>(context, primitive, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(\r\n                this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\r\n                    assign(babylonMesh);\r\n\r\n                    if (babylonMesh instanceof Mesh) {\r\n                        const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n\r\n                        const root = this._loader.rootBabylonMesh;\r\n                        const metadata = root ? (root.metadata = root.metadata || {}) : {};\r\n                        const gltf = (metadata.gltf = metadata.gltf || {});\r\n                        const extensionMetadata: IExtensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\r\n\r\n                        // Store the original material.\r\n                        extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\r\n\r\n                        // For each mapping, look at the variants and make a new entry for them.\r\n                        for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\r\n                            const mapping = extension.mappings[mappingIndex];\r\n                            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\r\n                            promises.push(\r\n                                this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                                    for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\r\n                                        const variantIndex = mapping.variants[mappingVariantIndex];\r\n                                        const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\r\n                                        extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\r\n                                        extensionMetadata.variants[variant.name].push({\r\n                                            mesh: babylonMesh,\r\n                                            material: babylonMaterial,\r\n                                        });\r\n\r\n                                        // Replace the target when original mesh is cloned\r\n                                        babylonMesh.onClonedObservable.add((newOne: Node) => {\r\n                                            const newMesh = newOne as Mesh;\r\n                                            let metadata: Nullable<IExtensionMetadata> = null;\r\n                                            let newRoot: Nullable<Node> = newMesh;\r\n\r\n                                            // Find root to get medata\r\n                                            do {\r\n                                                newRoot = newRoot!.parent;\r\n                                                if (!newRoot) {\r\n                                                    return;\r\n                                                }\r\n                                                metadata = KHR_materials_variants._GetExtensionMetadata(newRoot as Mesh);\r\n                                            } while (metadata === null);\r\n\r\n                                            // Need to clone the metadata on the root (first time only)\r\n                                            if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\r\n                                                // Copy main metadata\r\n                                                newRoot.metadata = {};\r\n                                                for (const key in root.metadata) {\r\n                                                    newRoot.metadata[key] = root.metadata[key];\r\n                                                }\r\n\r\n                                                // Copy the gltf metadata\r\n                                                newRoot.metadata.gltf = [];\r\n                                                for (const key in root.metadata.gltf) {\r\n                                                    newRoot.metadata.gltf[key] = root.metadata.gltf[key];\r\n                                                }\r\n\r\n                                                // Duplicate the extension specific metadata\r\n                                                newRoot.metadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\r\n                                                for (const original of metadata.original) {\r\n                                                    newRoot.metadata.gltf[NAME].original.push({\r\n                                                        mesh: original.mesh,\r\n                                                        material: original.material,\r\n                                                    });\r\n                                                }\r\n                                                for (const key in metadata.variants) {\r\n                                                    if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\r\n                                                        newRoot.metadata.gltf[NAME].variants[key] = [];\r\n                                                        for (const variantEntry of metadata.variants[key]) {\r\n                                                            newRoot.metadata.gltf[NAME].variants[key].push({\r\n                                                                mesh: variantEntry.mesh,\r\n                                                                material: variantEntry.material,\r\n                                                            });\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n\r\n                                                metadata = newRoot.metadata.gltf[NAME];\r\n                                            }\r\n\r\n                                            // Relocate\r\n                                            for (const target of metadata!.original) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                            for (const target of metadata!.variants[variant.name]) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                })\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n            );\r\n            return Promise.all(promises).then(([babylonMesh]) => {\r\n                return babylonMesh;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_variants(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\n\r\ninterface ITransmissionHelperHolder {\r\n    /**\r\n     * @internal\r\n     */\r\n    _transmissionHelper: TransmissionHelper | undefined;\r\n}\r\n\r\ninterface ITransmissionHelperOptions {\r\n    /**\r\n     * The size of the render buffers (default: 1024)\r\n     */\r\n    renderSize: number;\r\n\r\n    /**\r\n     * The number of samples to use when generating the render target texture for opaque meshes (default: 4)\r\n     */\r\n    samples: number;\r\n\r\n    /**\r\n     * Scale to apply when selecting the LOD level to sample the refraction texture (default: 1)\r\n     */\r\n    lodGenerationScale: number;\r\n\r\n    /**\r\n     * Offset to apply when selecting the LOD level to sample the refraction texture (default: -4)\r\n     */\r\n    lodGenerationOffset: number;\r\n\r\n    /**\r\n     * Type of the refraction render target texture (default: TEXTURETYPE_HALF_FLOAT)\r\n     */\r\n    renderTargetTextureType: number;\r\n\r\n    /**\r\n     * Defines if the mipmaps for the refraction render target texture must be generated (default: true)\r\n     */\r\n    generateMipmaps: boolean;\r\n\r\n    /**\r\n     * Clear color of the opaque texture. If not provided, use the scene clear color (which will be converted to linear space).\r\n     * If provided, should be in linear space\r\n     */\r\n    clearColor?: Color4;\r\n}\r\n\r\n/**\r\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\r\n */\r\nclass TransmissionHelper {\r\n    /**\r\n     * Creates the default options for the helper.\r\n     */\r\n    private static _GetDefaultOptions(): ITransmissionHelperOptions {\r\n        return {\r\n            renderSize: 1024,\r\n            samples: 4,\r\n            lodGenerationScale: 1,\r\n            lodGenerationOffset: -4,\r\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            generateMipmaps: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stores the creation options.\r\n     */\r\n    private readonly _scene: Scene & ITransmissionHelperHolder;\r\n\r\n    private _options: ITransmissionHelperOptions;\r\n\r\n    private _opaqueRenderTarget: Nullable<RenderTargetTexture> = null;\r\n    private _opaqueMeshesCache: AbstractMesh[] = [];\r\n    private _transparentMeshesCache: AbstractMesh[] = [];\r\n    private _materialObservers: { [id: string]: Nullable<Observer<AbstractMesh>> } = {};\r\n\r\n    /**\r\n     * This observable will be notified with any error during the creation of the environment,\r\n     * mainly texture creation errors.\r\n     */\r\n    public onErrorObservable: Observable<{ message?: string; exception?: any }>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param options Defines the options we want to customize the helper\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(options: Partial<ITransmissionHelperOptions>, scene: Scene) {\r\n        this._options = {\r\n            ...TransmissionHelper._GetDefaultOptions(),\r\n            ...options,\r\n        };\r\n        this._scene = scene as any;\r\n        this._scene._transmissionHelper = this;\r\n\r\n        this.onErrorObservable = new Observable();\r\n        this._scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._parseScene();\r\n        this._setupRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Updates the background according to the new options\r\n     * @param options\r\n     */\r\n    public updateOptions(options: Partial<ITransmissionHelperOptions>) {\r\n        // First check if any options are actually being changed. If not, exit.\r\n        const newValues = Object.keys(options).filter((key: string) => (this._options as any)[key] !== (options as any)[key]);\r\n        if (!newValues.length) {\r\n            return;\r\n        }\r\n\r\n        const newOptions = {\r\n            ...this._options,\r\n            ...options,\r\n        };\r\n\r\n        const oldOptions = this._options;\r\n        this._options = newOptions;\r\n\r\n        // If size changes, recreate everything\r\n        if (\r\n            newOptions.renderSize !== oldOptions.renderSize ||\r\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\r\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\r\n            !this._opaqueRenderTarget\r\n        ) {\r\n            this._setupRenderTargets();\r\n        } else {\r\n            this._opaqueRenderTarget.samples = newOptions.samples;\r\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\r\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the opaque render target texture or null if not available.\r\n     */\r\n    public getOpaqueTarget(): Nullable<Texture> {\r\n        return this._opaqueRenderTarget;\r\n    }\r\n\r\n    private _shouldRenderAsTransmission(material: Nullable<Material>): boolean {\r\n        if (!material) {\r\n            return false;\r\n        }\r\n        if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _addMesh(mesh: AbstractMesh): void {\r\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\r\n\r\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\r\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\r\n        Tools.SetImmediate(() => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _removeMesh(mesh: AbstractMesh): void {\r\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\r\n        delete this._materialObservers[mesh.uniqueId];\r\n        let idx = this._transparentMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._transparentMeshesCache.splice(idx, 1);\r\n        }\r\n        idx = this._opaqueMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._opaqueMeshesCache.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    private _parseScene(): void {\r\n        this._scene.meshes.forEach(this._addMesh.bind(this));\r\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\r\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\r\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\r\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\r\n    }\r\n\r\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\r\n    private _onMeshMaterialChanged(mesh: AbstractMesh) {\r\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\r\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\r\n\r\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\r\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\r\n        if (useTransmission) {\r\n            if (mesh.material instanceof PBRMaterial) {\r\n                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n            if (opaqueIdx !== -1) {\r\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else if (transparentIdx === -1) {\r\n                this._transparentMeshesCache.push(mesh);\r\n            }\r\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\r\n        } else {\r\n            if (transparentIdx !== -1) {\r\n                this._transparentMeshesCache.splice(transparentIdx, 1);\r\n                this._opaqueMeshesCache.push(mesh);\r\n            } else if (opaqueIdx === -1) {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup the render targets according to the specified options.\r\n     */\r\n    private _setupRenderTargets(): void {\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n        }\r\n        this._opaqueRenderTarget = new RenderTargetTexture(\r\n            \"opaqueSceneTexture\",\r\n            this._options.renderSize,\r\n            this._scene,\r\n            this._options.generateMipmaps,\r\n            undefined,\r\n            this._options.renderTargetTextureType\r\n        );\r\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\r\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\r\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\r\n        this._opaqueRenderTarget.gammaSpace = false;\r\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\r\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\r\n        this._opaqueRenderTarget.samples = this._options.samples;\r\n\r\n        let sceneImageProcessingapplyByPostProcess: boolean;\r\n\r\n        let saveSceneEnvIntensity: number;\r\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\r\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\r\n            this._scene.environmentIntensity = 1.0;\r\n            sceneImageProcessingapplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\r\n            if (!this._options.clearColor) {\r\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor);\r\n            } else {\r\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\r\n            }\r\n            // we do not use the applyByPostProcess setter to avoid flagging all the materials as \"image processing dirty\"!\r\n            this._scene.imageProcessingConfiguration._applyByPostProcess = true;\r\n        });\r\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\r\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\r\n            this._scene.imageProcessingConfiguration._applyByPostProcess = sceneImageProcessingapplyByPostProcess;\r\n        });\r\n\r\n        this._transparentMeshesCache.forEach((mesh: AbstractMesh) => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose all the elements created by the Helper.\r\n     */\r\n    public dispose(): void {\r\n        this._scene._transmissionHelper = undefined;\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n            this._opaqueRenderTarget = null;\r\n        }\r\n        this._transparentMeshesCache = [];\r\n        this._opaqueMeshesCache = [];\r\n    }\r\n}\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 175;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTransmission>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadTransparentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTransmission): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n        const pbrMaterial = babylonMaterial as PBRMaterial;\r\n\r\n        // Enables \"refraction\" texture which represents transmitted light.\r\n        pbrMaterial.subSurface.isRefractionEnabled = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\r\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\r\n\r\n        // Albedo colour will tint transmission.\r\n        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\r\n\r\n        if (extension.transmissionFactor !== undefined) {\r\n            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\r\n            const scene = pbrMaterial.getScene() as unknown as ITransmissionHelperHolder;\r\n            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\r\n                new TransmissionHelper({}, pbrMaterial.getScene());\r\n            }\r\n        } else {\r\n            pbrMaterial.subSurface.refractionIntensity = 0.0;\r\n            pbrMaterial.subSurface.isRefractionEnabled = false;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        pbrMaterial.subSurface.minimumThickness = 0.0;\r\n        pbrMaterial.subSurface.maximumThickness = 0.0;\r\n        if (extension.transmissionTexture) {\r\n            (extension.transmissionTexture as ITextureInfo).nonColorData = true;\r\n            return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined).then((texture: BaseTexture) => {\r\n                pbrMaterial.subSurface.refractionIntensityTexture = texture;\r\n                pbrMaterial.subSurface.useGltfStyleTextures = true;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_transmission(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTranslucency } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_translucency\";\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_translucency implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 174;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTranslucency>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadTranslucentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTranslucency): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n        const pbrMaterial = babylonMaterial as PBRMaterial;\r\n\r\n        // Enables \"translucency\" texture which represents diffusely-transmitted light.\r\n        pbrMaterial.subSurface.isTranslucencyEnabled = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make the\r\n        // internal IOR == 1.0 and set the thickness to 0.\r\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\r\n        pbrMaterial.subSurface.minimumThickness = 0.0;\r\n        pbrMaterial.subSurface.maximumThickness = 0.0;\r\n\r\n        // Albedo colour will tint transmission.\r\n        pbrMaterial.subSurface.useAlbedoToTintTranslucency = true;\r\n\r\n        if (extension.translucencyFactor !== undefined) {\r\n            pbrMaterial.subSurface.translucencyIntensity = extension.translucencyFactor;\r\n        } else {\r\n            pbrMaterial.subSurface.translucencyIntensity = 0.0;\r\n            pbrMaterial.subSurface.isTranslucencyEnabled = false;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (extension.translucencyTexture) {\r\n            (extension.translucencyTexture as ITextureInfo).nonColorData = true;\r\n            return this._loader.loadTextureInfoAsync(`${context}/translucencyTexture`, extension.translucencyTexture).then((texture: BaseTexture) => {\r\n                pbrMaterial.subSurface.translucencyIntensityTexture = texture;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_translucency(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsVolume } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_volume\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_volume implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 173;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            // We need to disable instance usage because the attenuation factor depends on the node scale of each individual mesh\r\n            this._loader._disableInstancedMesh++;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        if (this.enabled) {\r\n            this._loader._disableInstancedMesh--;\r\n        }\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsVolume>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadVolumePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsVolume): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        // If transparency isn't enabled already, this extension shouldn't do anything.\r\n        // i.e. it requires either the KHR_materials_transmission or KHR_materials_translucency extensions.\r\n        if ((!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled) || !extension.thicknessFactor) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // IOR in this extension only affects interior.\r\n        babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;\r\n        const attenuationDistance = extension.attenuationDistance !== undefined ? extension.attenuationDistance : Number.MAX_VALUE;\r\n        babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;\r\n        if (extension.attenuationColor !== undefined && extension.attenuationColor.length == 3) {\r\n            babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);\r\n        }\r\n\r\n        babylonMaterial.subSurface.minimumThickness = 0.0;\r\n        babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;\r\n        babylonMaterial.subSurface.useThicknessAsDepth = true;\r\n        if (extension.thicknessTexture) {\r\n            (extension.thicknessTexture as ITextureInfo).nonColorData = true;\r\n            return this._loader.loadTextureInfoAsync(`${context}/thicknessTexture`, extension.thicknessTexture).then((texture: BaseTexture) => {\r\n                babylonMaterial.subSurface.thicknessTexture = texture;\r\n                babylonMaterial.subSurface.useGltfStyleTextures = true;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_volume(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_mesh_quantization\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_mesh_quantization implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {}\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_mesh_quantization(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IKHRTextureBasisU } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_texture_basisu\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_basisu implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRTextureBasisU, BaseTexture>(context, texture, this.name, (extensionContext, extension) => {\r\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return this._loader._createTextureAsync(\r\n                context,\r\n                sampler,\r\n                image,\r\n                (babylonTexture) => {\r\n                    assign(babylonTexture);\r\n                },\r\n                texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : undefined,\r\n                !texture._textureInfo.nonColorData\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_texture_basisu(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\n\r\nimport type { ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRTextureTransform } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_transform implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRTextureTransform, BaseTexture>(context, textureInfo, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadTextureInfoAsync(context, textureInfo, (babylonTexture) => {\r\n                if (!(babylonTexture instanceof Texture)) {\r\n                    throw new Error(`${extensionContext}: Texture type not supported`);\r\n                }\r\n\r\n                if (extension.offset) {\r\n                    babylonTexture.uOffset = extension.offset[0];\r\n                    babylonTexture.vOffset = extension.offset[1];\r\n                }\r\n\r\n                // Always rotate around the origin.\r\n                babylonTexture.uRotationCenter = 0;\r\n                babylonTexture.vRotationCenter = 0;\r\n\r\n                if (extension.rotation) {\r\n                    babylonTexture.wAng = -extension.rotation;\r\n                }\r\n\r\n                if (extension.scale) {\r\n                    babylonTexture.uScale = extension.scale[0];\r\n                    babylonTexture.vScale = extension.scale[1];\r\n                }\r\n\r\n                if (extension.texCoord != undefined) {\r\n                    babylonTexture.coordinatesIndex = extension.texCoord;\r\n                }\r\n\r\n                assign(babylonTexture);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_texture_transform(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRXmpJsonLd_Gltf, IKHRXmpJsonLd_Node } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_xmp_json_ld\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/README.md)\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_xmp_json_ld implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Called after the loader state changes to LOADING.\r\n     */\r\n    public onLoading(): void {\r\n        if (this._loader.rootBabylonMesh === null) {\r\n            return;\r\n        }\r\n\r\n        const xmp_gltf = this._loader.gltf.extensions?.KHR_xmp_json_ld as IKHRXmpJsonLd_Gltf;\r\n        const xmp_node = this._loader.gltf.asset?.extensions?.KHR_xmp_json_ld as IKHRXmpJsonLd_Node;\r\n        if (xmp_gltf && xmp_node) {\r\n            const packet = +xmp_node.packet;\r\n            if (xmp_gltf.packets && packet < xmp_gltf.packets.length) {\r\n                this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};\r\n                this._loader.rootBabylonMesh.metadata.xmp = xmp_gltf.packets[packet];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_xmp_json_ld(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport type { ICamera, IKHRLightsPunctual_Light, IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { AnimationPropertyInfo, nodeAnimationData } from \"../glTFLoaderAnimation\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nfunction getColor3(_target: any, source: Float32Array, offset: number, scale: number): Color3 {\r\n    return Color3.FromArray(source, offset).scale(scale);\r\n}\r\n\r\nfunction getAlpha(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset + 3] * scale;\r\n}\r\n\r\nfunction getFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset] * scale;\r\n}\r\n\r\nfunction getMinusFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return -source[offset] * scale;\r\n}\r\n\r\nfunction getNextFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset + 1] * scale;\r\n}\r\n\r\nfunction getFloatBy2(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset] * scale * 2;\r\n}\r\n\r\nfunction getTextureTransformTree(textureName: string) {\r\n    return {\r\n        scale: [\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uScale`, getFloat, () => 2),\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vScale`, getNextFloat, () => 2),\r\n        ],\r\n        offset: [\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uOffset`, getFloat, () => 2),\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vOffset`, getNextFloat, () => 2),\r\n        ],\r\n        rotation: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.wAng`, getMinusFloat, () => 1)],\r\n    };\r\n}\r\n\r\nclass CameraAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: ICamera, name: string, fps: number, keys: any[], callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void): void {\r\n        callback(target._babylonCamera!, this._buildAnimation(name, fps, keys));\r\n    }\r\n}\r\n\r\nclass MaterialAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: IMaterial, name: string, fps: number, keys: any[], callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void): void {\r\n        for (const fillMode in target._data!) {\r\n            callback(target._data![fillMode].babylonMaterial, this._buildAnimation(name, fps, keys));\r\n        }\r\n    }\r\n}\r\n\r\nclass LightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(\r\n        target: IKHRLightsPunctual_Light,\r\n        name: string,\r\n        fps: number,\r\n        keys: any[],\r\n        callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): void {\r\n        callback(target._babylonLight!, this._buildAnimation(name, fps, keys));\r\n    }\r\n}\r\n\r\nconst nodesTree = {\r\n    __array__: {\r\n        __target__: true,\r\n        ...nodeAnimationData,\r\n    },\r\n};\r\n\r\nconst camerasTree = {\r\n    __array__: {\r\n        __target__: true,\r\n        orthographic: {\r\n            xmag: [\r\n                new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoLeft\", getMinusFloat, () => 1),\r\n                new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoRight\", getNextFloat, () => 1),\r\n            ],\r\n            ymag: [\r\n                new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoBottom\", getMinusFloat, () => 1),\r\n                new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoTop\", getNextFloat, () => 1),\r\n            ],\r\n            zfar: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"maxZ\", getFloat, () => 1)],\r\n            znear: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"minZ\", getFloat, () => 1)],\r\n        },\r\n        perspective: {\r\n            yfov: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"fov\", getFloat, () => 1)],\r\n            zfar: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"maxZ\", getFloat, () => 1)],\r\n            znear: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"minZ\", getFloat, () => 1)],\r\n        },\r\n    },\r\n};\r\n\r\nconst materialsTree = {\r\n    __array__: {\r\n        __target__: true,\r\n        pbrMetallicRoughness: {\r\n            baseColorFactor: [\r\n                new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"albedoColor\", getColor3, () => 4),\r\n                new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"alpha\", getAlpha, () => 4),\r\n            ],\r\n            metallicFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"metallic\", getFloat, () => 1)],\r\n            roughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"roughness\", getFloat, () => 1)],\r\n            baseColorTexture: {\r\n                extensions: {\r\n                    KHR_texture_transform: getTextureTransformTree(\"albedoTexture\"),\r\n                },\r\n            },\r\n        },\r\n        emissiveFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"emissiveColor\", getColor3, () => 3)],\r\n        normalTexture: {\r\n            scale: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"bumpTexture.level\", getFloat, () => 1)],\r\n        },\r\n        occlusionTexture: {\r\n            strength: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"ambientTextureStrength\", getFloat, () => 1)],\r\n            extensions: {\r\n                KHR_texture_transform: getTextureTransformTree(\"ambientTexture\"),\r\n            },\r\n        },\r\n        emissiveTexture: {\r\n            extensions: {\r\n                KHR_texture_transform: getTextureTransformTree(\"emissiveTexture\"),\r\n            },\r\n        },\r\n        extensions: {\r\n            KHR_materials_ior: {\r\n                ior: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"indexOfRefraction\", getFloat, () => 1)],\r\n            },\r\n            KHR_materials_clearcoat: {\r\n                clearcoatFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.intensity\", getFloat, () => 1)],\r\n                clearcoatRoughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.roughness\", getFloat, () => 1)],\r\n            },\r\n            KHR_materials_sheen: {\r\n                sheenColorFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"sheen.color\", getColor3, () => 3)],\r\n                sheenRoughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"sheen.roughness\", getFloat, () => 1)],\r\n            },\r\n            KHR_materials_specular: {\r\n                specularFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"metallicF0Factor\", getFloat, () => 1)],\r\n                specularColorFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"metallicReflectanceColor\", getColor3, () => 3)],\r\n            },\r\n            KHR_materials_emissive_strength: {\r\n                emissiveStrength: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"emissiveIntensity\", getFloat, () => 1)],\r\n            },\r\n            KHR_materials_transmission: {\r\n                transmissionFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.refractionIntensity\", getFloat, () => 1)],\r\n            },\r\n            KHR_materials_volume: {\r\n                attenuationColor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"subSurface.tintColor\", getColor3, () => 3)],\r\n                attenuationDistance: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.tintColorAtDistance\", getFloat, () => 1)],\r\n                thicknessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.maximumThickness\", getFloat, () => 1)],\r\n            },\r\n            KHR_materials_iridescence: {\r\n                iridescenceFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.intensity\", getFloat, () => 1)],\r\n                iridescenceIor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.indexOfRefraction\", getFloat, () => 1)],\r\n                iridescenceThicknessMinimum: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.minimumThickness\", getFloat, () => 1)],\r\n                iridescenceThicknessMaximum: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.maximumThickness\", getFloat, () => 1)],\r\n            },\r\n        },\r\n    },\r\n};\r\n\r\nconst extensionsTree = {\r\n    KHR_lights_punctual: {\r\n        lights: {\r\n            __array__: {\r\n                __target__: true,\r\n                color: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"diffuse\", getColor3, () => 3)],\r\n                intensity: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"intensity\", getFloat, () => 1)],\r\n                range: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"range\", getFloat, () => 1)],\r\n                spot: {\r\n                    innerConeAngle: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"innerAngle\", getFloatBy2, () => 1)],\r\n                    outerConeAngle: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"angle\", getFloatBy2, () => 1)],\r\n                },\r\n            },\r\n        },\r\n    },\r\n};\r\n\r\n/** @internal */\r\nexport const animationPointerTree = {\r\n    nodes: nodesTree,\r\n    materials: materialsTree,\r\n    cameras: camerasTree,\r\n    extensions: extensionsTree,\r\n};\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IAnimationTargetInfo } from \"../glTFLoader\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimation, IAnimationChannel } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRAnimationPointer } from \"babylonjs-gltf2interface\";\r\nimport { AnimationChannelTargetPath } from \"babylonjs-gltf2interface\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { animationPointerTree } from \"./KHR_animation_pointer.data\";\r\n\r\nconst NAME = \"KHR_animation_pointer\";\r\n\r\n/**\r\n * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_animation_pointer implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public get enabled(): boolean {\r\n        return this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete or null if not handled\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        const extension = channel.target.extensions?.KHR_animation_pointer as IKHRAnimationPointer;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        if (channel.target.path !== AnimationChannelTargetPath.POINTER) {\r\n            Logger.Warn(`${context}/target/path: Value (${channel.target.path}) must be (${AnimationChannelTargetPath.POINTER}) when using the ${this.name} extension`);\r\n        }\r\n\r\n        if (channel.target.node != undefined) {\r\n            Logger.Warn(`${context}/target/node: Value (${channel.target.node}) must not be present when using the ${this.name} extension`);\r\n        }\r\n\r\n        const extensionContext = `${context}/extensions/${this.name}`;\r\n\r\n        const pointer = extension.pointer;\r\n        if (!pointer) {\r\n            throw new Error(`${extensionContext}: Pointer is missing`);\r\n        }\r\n\r\n        const targetInfo = this._parseAnimationPointer(`${extensionContext}/pointer`, pointer);\r\n        if (!targetInfo) {\r\n            Logger.Warn(`${extensionContext}/pointer: Invalid pointer (${pointer}) skipped`);\r\n            return null;\r\n        }\r\n\r\n        return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\r\n    }\r\n\r\n    /**\r\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\r\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\r\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\r\n     * <assetIndex> := <digit> | <name>\r\n     * <propertyPath> := <extensionPath> | <standardPath>\r\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\r\n     * <standardPath> := <name> | <name>/<standardPath>\r\n     * <name> := W+\r\n     * <digit> := D+\r\n     *\r\n     * Examples:\r\n     *  - \"/nodes/0/rotation\"\r\n     *  - \"/materials/2/emissiveFactor\"\r\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\r\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\r\n     */\r\n    private _parseAnimationPointer(context: string, pointer: string): Nullable<IAnimationTargetInfo> {\r\n        if (!pointer.startsWith(\"/\")) {\r\n            Logger.Warn(`${context}: Value (${pointer}) must start with a slash`);\r\n            return null;\r\n        }\r\n\r\n        const parts = pointer.split(\"/\");\r\n\r\n        // Remove the first part since it will be empty string as pointers must start with a slash.\r\n        parts.shift();\r\n\r\n        let node: any = animationPointerTree;\r\n        let gltfCurrentNode: any = this._loader.gltf;\r\n        let gltfTargetNode: any = undefined;\r\n        for (const part of parts) {\r\n            if (node.__array__) {\r\n                node = node.__array__;\r\n            } else {\r\n                node = node[part];\r\n                if (!node) {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            gltfCurrentNode = gltfCurrentNode && gltfCurrentNode[part];\r\n\r\n            if (node.__target__) {\r\n                gltfTargetNode = gltfCurrentNode;\r\n            }\r\n        }\r\n\r\n        if (!gltfTargetNode || !Array.isArray(node)) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            target: gltfTargetNode,\r\n            properties: node,\r\n        };\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_animation_pointer(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Sound } from \"core/Audio/sound\";\r\nimport { WeightedSound } from \"core/Audio/weightedsound\";\r\n\r\nimport type { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IMSFTAudioEmitter_Clip, IMSFTAudioEmitter_Emitter, IMSFTAudioEmitter_EmittersReference, IMSFTAudioEmitter_AnimationEvent } from \"babylonjs-gltf2interface\";\r\nimport { IMSFTAudioEmitter_AnimationEventAction } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"MSFT_audio_emitter\";\r\n\r\ninterface ILoaderClip extends IMSFTAudioEmitter_Clip, IArrayItem {\r\n    _objectURL?: Promise<string>;\r\n}\r\n\r\ninterface ILoaderEmitter extends IMSFTAudioEmitter_Emitter, IArrayItem {\r\n    _babylonData?: {\r\n        sound?: WeightedSound;\r\n        loaded: Promise<void>;\r\n    };\r\n    _babylonSounds: Sound[];\r\n}\r\n\r\ninterface IMSFTAudioEmitter {\r\n    clips: ILoaderClip[];\r\n    emitters: ILoaderEmitter[];\r\n}\r\n\r\ninterface ILoaderAnimationEvent extends IMSFTAudioEmitter_AnimationEvent, IArrayItem {}\r\n\r\ninterface ILoaderAnimationEvents {\r\n    events: ILoaderAnimationEvent[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _clips: Array<ILoaderClip>;\r\n    private _emitters: Array<ILoaderEmitter>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        (this._clips as any) = null;\r\n        (this._emitters as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\r\n\r\n            this._clips = extension.clips;\r\n            this._emitters = extension.emitters;\r\n\r\n            ArrayItem.Assign(this._clips);\r\n            ArrayItem.Assign(this._emitters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference>(context, scene, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            for (const emitterIndex of extension.emitters) {\r\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                if (\r\n                    emitter.refDistance != undefined ||\r\n                    emitter.maxDistance != undefined ||\r\n                    emitter.rolloffFactor != undefined ||\r\n                    emitter.distanceModel != undefined ||\r\n                    emitter.innerAngle != undefined ||\r\n                    emitter.outerAngle != undefined\r\n                ) {\r\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\r\n                }\r\n\r\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            return this._loader\r\n                .loadNodeAsync(extensionContext, node, (babylonMesh) => {\r\n                    for (const emitterIndex of extension.emitters) {\r\n                        const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                        promises.push(\r\n                            this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\r\n                                for (const sound of emitter._babylonSounds) {\r\n                                    sound.attachToMesh(babylonMesh);\r\n                                    if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\r\n                                        sound.setLocalDirectionToMesh(Vector3.Forward());\r\n                                        sound.setDirectionalCone(\r\n                                            2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\r\n                                            2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\r\n                                            0\r\n                                        );\r\n                                    }\r\n                                }\r\n                            })\r\n                        );\r\n                    }\r\n\r\n                    assign(babylonMesh);\r\n                })\r\n                .then((babylonMesh) => {\r\n                    return Promise.all(promises).then(() => {\r\n                        return babylonMesh;\r\n                    });\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {\r\n                const promises = new Array<Promise<any>>();\r\n\r\n                ArrayItem.Assign(extension.events);\r\n                for (const event of extension.events) {\r\n                    promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\r\n                }\r\n\r\n                return Promise.all(promises).then(() => {\r\n                    return babylonAnimationGroup;\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\r\n        if (clip._objectURL) {\r\n            return clip._objectURL;\r\n        }\r\n\r\n        let promise: Promise<ArrayBufferView>;\r\n        if (clip.uri) {\r\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\r\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n        }\r\n\r\n        clip._objectURL = promise.then((data) => {\r\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\r\n        });\r\n\r\n        return clip._objectURL;\r\n    }\r\n\r\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\r\n        emitter._babylonSounds = emitter._babylonSounds || [];\r\n        if (!emitter._babylonData) {\r\n            const clipPromises = new Array<Promise<any>>();\r\n            const name = emitter.name || `emitter${emitter.index}`;\r\n            const options = {\r\n                loop: false,\r\n                autoplay: false,\r\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\r\n            };\r\n\r\n            for (let i = 0; i < emitter.clips.length; i++) {\r\n                const clipContext = `/extensions/${this.name}/clips`;\r\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\r\n                clipPromises.push(\r\n                    this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\r\n                        const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\r\n                        sound.refDistance = emitter.refDistance || 1;\r\n                        sound.maxDistance = emitter.maxDistance || 256;\r\n                        sound.rolloffFactor = emitter.rolloffFactor || 1;\r\n                        sound.distanceModel = emitter.distanceModel || \"exponential\";\r\n                    })\r\n                );\r\n            }\r\n\r\n            const promise = Promise.all(clipPromises).then(() => {\r\n                const weights = emitter.clips.map((clip) => {\r\n                    return clip.weight || 1;\r\n                });\r\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\r\n                if (emitter.innerAngle) {\r\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\r\n                }\r\n                if (emitter.outerAngle) {\r\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\r\n                }\r\n                if (emitter.volume) {\r\n                    weightedSound.volume = emitter.volume;\r\n                }\r\n                emitter._babylonData!.sound = weightedSound;\r\n            });\r\n\r\n            emitter._babylonData = {\r\n                loaded: promise,\r\n            };\r\n        }\r\n\r\n        return emitter._babylonData.loaded;\r\n    }\r\n\r\n    private _getEventAction(\r\n        context: string,\r\n        sound: WeightedSound,\r\n        action: IMSFTAudioEmitter_AnimationEventAction,\r\n        time: number,\r\n        startOffset?: number\r\n    ): (currentFrame: number) => void {\r\n        switch (action) {\r\n            case IMSFTAudioEmitter_AnimationEventAction.play: {\r\n                return (currentFrame: number) => {\r\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\r\n                    sound.play(frameOffset);\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.stop: {\r\n                return () => {\r\n                    sound.stop();\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.pause: {\r\n                return () => {\r\n                    sound.pause();\r\n                };\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Unsupported action ${action}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _loadAnimationEventAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        event: ILoaderAnimationEvent,\r\n        babylonAnimationGroup: AnimationGroup\r\n    ): Promise<void> {\r\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\r\n            return Promise.resolve();\r\n        }\r\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\r\n        const emitterIndex = event.emitter;\r\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\r\n        return this._loadEmitterAsync(context, emitter).then(() => {\r\n            const sound = emitter._babylonData!.sound;\r\n            if (sound) {\r\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\r\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\r\n                // Make sure all started audio stops when this animation is terminated.\r\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\r\n                    sound.stop();\r\n                });\r\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\r\n                    sound.pause();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_audio_emitter(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { INode, IMaterial, IBuffer, IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IProperty, IMSFTLOD } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"MSFT_lod\";\r\n\r\ninterface IBufferInfo {\r\n    start: number;\r\n    end: number;\r\n    loaded: Deferred<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_lod implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    /**\r\n     * Maximum number of LODs to load, starting from the lowest LOD.\r\n     */\r\n    public maxLODsToLoad = 10;\r\n\r\n    /**\r\n     * Observable raised when all node LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onNodeLODsLoadedObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Observable raised when all material LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onMaterialLODsLoadedObservable = new Observable<number>();\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _bufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _nodeIndexLOD: Nullable<number> = null;\r\n    private _nodeSignalLODs = new Array<Deferred<void>>();\r\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _nodeBufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _materialIndexLOD: Nullable<number> = null;\r\n    private _materialSignalLODs = new Array<Deferred<void>>();\r\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _materialBufferLODs = new Array<IBufferInfo>();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n\r\n        this._nodeIndexLOD = null;\r\n        this._nodeSignalLODs.length = 0;\r\n        this._nodePromiseLODs.length = 0;\r\n        this._nodeBufferLODs.length = 0;\r\n\r\n        this._materialIndexLOD = null;\r\n        this._materialSignalLODs.length = 0;\r\n        this._materialPromiseLODs.length = 0;\r\n        this._materialBufferLODs.length = 0;\r\n\r\n        this.onMaterialLODsLoadedObservable.clear();\r\n        this.onNodeLODsLoadedObservable.clear();\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\r\n                    if (this._nodeSignalLODs[indexLOD]) {\r\n                        this._nodeSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n\r\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\r\n                    if (this._materialSignalLODs[indexLOD]) {\r\n                        this._materialSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        const promise = this._loader.loadSceneAsync(context, scene);\r\n        this._loadBufferLOD(this._bufferLODs, 0);\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            let firstPromise: Promise<TransformNode>;\r\n\r\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\r\n                const nodeLOD = nodeLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._nodeIndexLOD = indexLOD;\r\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\r\n                }\r\n\r\n                const assignWrap = (babylonTransformNode: TransformNode) => {\r\n                    assign(babylonTransformNode);\r\n                    babylonTransformNode.setEnabled(false);\r\n                };\r\n\r\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\r\n                    if (indexLOD !== 0) {\r\n                        // TODO: should not rely on _babylonTransformNode\r\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\r\n                        if (previousNodeLOD._babylonTransformNode) {\r\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\r\n                            delete previousNodeLOD._babylonTransformNode;\r\n                        }\r\n                    }\r\n\r\n                    babylonMesh.setEnabled(true);\r\n                    return babylonMesh;\r\n                });\r\n\r\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._nodeIndexLOD = null;\r\n                    this._nodePromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        // Don't load material LODs if already loading a node LOD.\r\n        if (this._nodeIndexLOD) {\r\n            return null;\r\n        }\r\n\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, (extensionContext, extension) => {\r\n            let firstPromise: Promise<Material>;\r\n\r\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\r\n                const materialLOD = materialLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._materialIndexLOD = indexLOD;\r\n                }\r\n\r\n                const promise = this._loader\r\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        if (indexLOD === 0) {\r\n                            assign(babylonMaterial);\r\n                        }\r\n                    })\r\n                    .then((babylonMaterial) => {\r\n                        if (indexLOD !== 0) {\r\n                            assign(babylonMaterial);\r\n\r\n                            // TODO: should not rely on _data\r\n                            const previousDataLOD = materialLODs[indexLOD - 1]._data!;\r\n                            if (previousDataLOD[babylonDrawMode]) {\r\n                                this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\r\n                                delete previousDataLOD[babylonDrawMode];\r\n                            }\r\n                        }\r\n\r\n                        return babylonMaterial;\r\n                    });\r\n\r\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._materialIndexLOD = null;\r\n                    this._materialPromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        // Defer the loading of uris if loading a node or material LOD.\r\n        if (this._nodeIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._nodeIndexLOD - 1;\r\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {\r\n                return this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        } else if (this._materialIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._materialIndexLOD - 1;\r\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._materialSignalLODs[previousIndexLOD].promise.then(() => {\r\n                return this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\r\n            if (!this._loader.bin) {\r\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n            }\r\n\r\n            const loadAsync = (bufferLODs: Array<IBufferInfo>, indexLOD: number) => {\r\n                const start = byteOffset;\r\n                const end = start + byteLength - 1;\r\n                let bufferLOD = bufferLODs[indexLOD];\r\n                if (bufferLOD) {\r\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\r\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\r\n                } else {\r\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\r\n                    bufferLODs[indexLOD] = bufferLOD;\r\n                }\r\n\r\n                return bufferLOD.loaded.promise.then((data) => {\r\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\r\n                });\r\n            };\r\n\r\n            this._loader.log(`deferred`);\r\n\r\n            if (this._nodeIndexLOD !== null) {\r\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\r\n            } else if (this._materialIndexLOD !== null) {\r\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\r\n            } else {\r\n                return loadAsync(this._bufferLODs, 0);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _loadBufferLOD(bufferLODs: Array<IBufferInfo>, indexLOD: number): void {\r\n        const bufferLOD = bufferLODs[indexLOD];\r\n        if (bufferLOD) {\r\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\r\n            this._loader.bin!.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(\r\n                (data) => {\r\n                    bufferLOD.loaded.resolve(data);\r\n                },\r\n                (error) => {\r\n                    bufferLOD.loaded.reject(error);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an array of LOD properties from lowest to highest.\r\n     * @param context\r\n     * @param property\r\n     * @param array\r\n     * @param ids\r\n     */\r\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\r\n        if (this.maxLODsToLoad <= 0) {\r\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\r\n        }\r\n\r\n        const properties = new Array<T>();\r\n\r\n        for (let i = ids.length - 1; i >= 0; i--) {\r\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\r\n            if (properties.length === this.maxLODsToLoad) {\r\n                return properties;\r\n            }\r\n        }\r\n\r\n        properties.push(property);\r\n        return properties;\r\n    }\r\n\r\n    private _disposeTransformNode(babylonTransformNode: TransformNode): void {\r\n        const babylonMaterials = new Array<Material>();\r\n        const babylonMaterial = (babylonTransformNode as Mesh).material;\r\n        if (babylonMaterial) {\r\n            babylonMaterials.push(babylonMaterial);\r\n        }\r\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\r\n            if (babylonMesh.material) {\r\n                babylonMaterials.push(babylonMesh.material);\r\n            }\r\n        }\r\n\r\n        babylonTransformNode.dispose();\r\n\r\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\r\n        this._disposeMaterials(babylonMaterialsToDispose);\r\n    }\r\n\r\n    private _disposeMaterials(babylonMaterials: Material[]): void {\r\n        const babylonTextures: { [uniqueId: number]: BaseTexture } = {};\r\n\r\n        for (const babylonMaterial of babylonMaterials) {\r\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\r\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\r\n            }\r\n\r\n            babylonMaterial.dispose();\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\r\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\r\n                    delete babylonTextures[uniqueId];\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            babylonTextures[uniqueId].dispose();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_lod(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"MSFT_minecraftMesh\";\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_minecraftMesh implements IGLTFLoaderExtension {\r\n    /** @internal */\r\n    public readonly name = NAME;\r\n\r\n    /** @internal */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @internal */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtraAsync<boolean>(context, material, this.name, (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                if (babylonMaterial.needAlphaBlending()) {\r\n                    babylonMaterial.forceDepthWrite = true;\r\n                    babylonMaterial.separateCullingPass = true;\r\n                }\r\n\r\n                babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;\r\n                babylonMaterial.twoSidedLighting = true;\r\n\r\n                return promise;\r\n            }\r\n\r\n            return null;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_minecraftMesh(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"MSFT_sRGBFactors\";\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_sRGBFactors implements IGLTFLoaderExtension {\r\n    /** @internal */\r\n    public readonly name = NAME;\r\n\r\n    /** @internal */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @internal */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtraAsync<boolean>(context, material, this.name, (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                if (!babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor);\r\n                }\r\n\r\n                if (!babylonMaterial.reflectivityTexture) {\r\n                    babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor);\r\n                }\r\n\r\n                return promise;\r\n            }\r\n\r\n            return null;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_sRGBFactors(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\n\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport type { INode, ICamera, IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nconst NAME = \"ExtrasAsMetadata\";\r\n\r\ninterface ObjectWithMetadata {\r\n    metadata: any;\r\n}\r\n\r\n/**\r\n * Store glTF extras (if present) in BJS objects' metadata\r\n */\r\nexport class ExtrasAsMetadata implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _assignExtras(babylonObject: ObjectWithMetadata, gltfProp: IProperty): void {\r\n        if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {\r\n            const metadata = (babylonObject.metadata = babylonObject.metadata || {});\r\n            const gltf = (metadata.gltf = metadata.gltf || {});\r\n            gltf.extras = gltfProp.extras;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._loader.loadNodeAsync(context, node, (babylonTransformNode): void => {\r\n            this._assignExtras(babylonTransformNode, node);\r\n            assign(babylonTransformNode);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._loader.loadCameraAsync(context, camera, (babylonCamera): void => {\r\n            this._assignExtras(babylonCamera, camera);\r\n            assign(babylonCamera);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        const babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);\r\n        this._assignExtras(babylonMaterial, material);\r\n        return babylonMaterial;\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader): IGLTFLoaderExtension => new ExtrasAsMetadata(loader));\r\n"],"names":["validateAsync","data","rootUrl","fileName","getExternalResource","options","externalResourceFunction","uri","then","value","Uint8Array","ArrayBuffer","GLTFValidator","validateBytes","validateString","workerFunc","pendingExternalResources","onmessage","message","id","importScripts","url","Promise","resolve","reject","index","length","push","postMessage","reason","GLTFValidation","static","Worker","workerContent","workerBlobUrl","URL","createObjectURL","Blob","type","worker","onError","error","removeEventListener","onMessage","terminate","addEventListener","this","Configuration","_LoadScriptPromise","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","GLTFLoaderState","EComponentType","EShaderType","EParameterType","ETextureWrapMode","ETextureFilterType","ETextureFormat","ECullingType","EBlendingFunction","readAsync","arrayBuffer","byteOffset","byteLength","e","GLTFFileLoader","onParsedObservable","coordinateSystemMode","AUTO","animationStartMode","FIRST","compileMaterials","useClipPlane","compileShadowGenerators","transparencyAsCoverage","useRangeRequests","createInstances","alwaysComputeBoundingBox","loadAllMaterials","loadOnlyMaterials","skipMaterials","useSRGBBuffers","targetFps","alwaysComputeSkeletonRootNode","preprocessUrlAsync","onMeshLoadedObservable","onSkinLoadedObservable","onTextureLoadedObservable","onMaterialLoadedObservable","onCameraLoadedObservable","onCompleteObservable","onErrorObservable","onDisposeObservable","onExtensionLoadedObservable","validate","onValidatedObservable","_loader","_state","_requests","Array","name","extensions","isBinary","onLoaderStateChangedObservable","_logIndentLevel","_loggingEnabled","_log","_logDisabled","_capturePerformanceCounters","_startPerformanceCounter","_startPerformanceCounterDisabled","_endPerformanceCounter","_endPerformanceCounterDisabled","onParsed","callback","_onParsedObserver","remove","add","onMeshLoaded","_onMeshLoadedObserver","onTextureLoaded","_onTextureLoadedObserver","onMaterialLoaded","_onMaterialLoadedObserver","onCameraLoaded","_onCameraLoadedObserver","onComplete","_onCompleteObserver","_onErrorObserver","onDispose","_onDisposeObserver","onExtensionLoaded","_onExtensionLoadedObserver","loggingEnabled","_logEnabled","capturePerformanceCounters","_startPerformanceCounterEnabled","_endPerformanceCounterEnabled","onValidated","_onValidatedObserver","dispose","request","abort","_progressCallback","clear","notifyObservers","undefined","loadFile","scene","fileOrUrl","onSuccess","onProgress","useArrayBuffer","fileRequest","dataBuffer","_loadFile","webRequest","setRequestHeader","_unpackBinaryAsync","loaderData","_validate","json","_parseJson","importMeshAsync","meshesNames","_getLoader","loadAsync","loadAssetContainerAsync","container","materials","material","textures","texture","cameras","camera","result","prototype","apply","geometries","meshes","particleSystems","skeletons","animationGroups","lights","transformNodes","canDirectLoad","indexOf","startsWith","_MagicBase64Encoded","directLoad","createPlugin","loaderState","whenCompleteAsync","addOnce","_setState","state","onOpened","event","_onProgress","splice","_lengthComputable","lengthComputable","_loaded","loaded","_total","total","ValidateAsync","_loadFileAsync","asset","version","minVersion","generator","_parseVersion","Error","_compareVersion","major","minor","createLoader","_CreateGLTF1Loader","_CreateGLTF2Loader","parsed","JSON","parse","dataReader","magic","readUint32","unpacked","buffer","_unpackBinaryV1Async","_unpackBinaryV2Async","contentLength","contentFormat","bodyLength","readString","bin","startByteOffset","ChunkFormat","chunkLength","skipBytes","match","parseInt","a","b","_logOpen","_logClose","spaces","_logSpaces","substr","Log","counterName","IncrementalLoading","HomogeneousCoordinates","GLTFUtils","source","parameter","uniformName","shaderMaterial","mat","semantic","getWorldMatrix","getProjectionMatrix","getViewMatrix","multiply","invert","getTransformMatrix","FLOAT_MAT2","setMatrix2x2","FLOAT_MAT3","setMatrix3x3","FLOAT_MAT4","setMatrix","uniform","FLOAT","setFloat","FLOAT_VEC2","setVector2","FLOAT_VEC3","setVector3","FLOAT_VEC4","setVector4","mode","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","accessor","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","NEAREST","NEAREST_MIPMAP_NEAREST","gltfRuntime","bufferView","componentType","loadedBufferView","loadedBufferViews","BYTE","Int8Array","UNSIGNED_BYTE","SHORT","Int16Array","UNSIGNED_SHORT","Uint16Array","Float32Array","bufferViews","count","GetByteStrideFromType","GetBufferFromBufferView","view","i","String","fromCharCode","_DefaultMaterial","join","shaderPath","vertex","fragment","attributes","uniforms","samplers","needAlphaBlending","setColor4","ETokenType","Tokenizer","constructor","toParse","_pos","currentToken","UNKNOWN","currentIdentifier","currentString","isLetterOrDigitPattern","_toParse","_maxPos","getNextToken","isEnd","END_OF_INPUT","read","test","IDENTIFIER","peek","forward","glTFTransforms","babylonTransforms","glTFAnimationPaths","babylonAnimationPaths","parseObject","parsedObjects","runtimeProperty","object","parsedObject","normalizeUVs","getAttribute","attributeParameter","channel","Number","split","configureBoneTransformation","node","translation","rotation","scale","position","matrix","getParentBone","skins","jointName","newSkeleton","bones","nodes","nde","children","child","bone","getNodeToRoot","nodesToRoot","nodeToRoot","j","getJointNode","nodeIsInJoints","jointNames","importMesh","newMesh","_blockEntityCollection","assetContainer","_parentContainer","babylonNode","subMaterials","vertexData","verticesStarts","verticesCounts","indexStarts","indexCounts","meshIndex","meshId","mesh","primitives","tempVertexData","primitive","accessors","GetBufferFromAccessor","normals","set","positions","uvKind","uvs","matricesIndices","matricesWeights","colors","indices","Int32Array","merge","getMaterialById","GetDefaultMaterial","computeWorldMatrix","subMeshes","configureNode","newNode","scaling","rotationQuaternion","importNode","lastNode","importOnlyMeshes","skin","importMeshesNames","skeleton","getLastSkeletonById","babylonSkeleton","nodesToRootToAdd","k","_parent","getNodesToRoot","jointNode","existingBone","getBoneById","foundBone","parentBone","joint","prepare","importSkeleton","light","orthoCamera","attachControl","perspectiveCamera","persCamera","aspectRatio","getEngine","getRenderWidth","getRenderHeight","znear","zfar","maxZ","minZ","ambienLight","hemiLight","color","diffuse","directionalLight","dirLight","pointLight","ptLight","spotLight","spLight","fallOfAngle","angle","fallOffExponent","exponent","dummy","decompose","configureNodeFromMatrix","updateCache","traverseNodes","parent","meshIncluded","postLoad","currentScene","thing","scenes","anim","animations","animation","channels","lastAnimation","sampler","inputData","outputData","parameters","input","output","bufferInput","bufferOutput","targetId","target","targetNode","getNodeById","getNodeByName","isBone","targetPath","path","targetPathIndex","animationType","babylonAnimation","keys","arrayOffset","modifyKey","getKeys","getBaseMatrix","frame","setKeys","stopAnimation","beginAnimation","loadAnimations","MAX_VALUE","parseShaderUniforms","tokenizer","technique","unTreatedUniforms","unif","uniformParameter","transformIndex","importMaterials","GLTFLoaderExtension","LoadMaterialAsync","GLTFLoaderBase","parsedData","buffers","images","shaders","programs","techniques","extensionsUsed","buffersCount","shaderscount","loadedBufferCount","loadedShaderCount","dummyNodes","parsedBuffers","buf","parsedBuffer","parseBuffers","parsedShaders","sha","parsedShader","parseShaders","setTimeout","status","statusText","babylonTexture","createMipMaps","minFilter","NEAREST_MIPMAP_LINEAR","samplingMode","blob","blobURL","revokeBlobURL","revokeObjectURL","newTexture","wrapS","wrapU","GetWrapMode","wrapT","wrapV","shader","shaderString","atob","defaultMaterial","diffuseColor","sideOrientation","program","states","vertexShader","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","pixelTokenizer","SAMPLER_2D","attr","attribute","foundAttribute","enable","effect","onShaderCompileError","onCompiled","_","materialValues","values","techniqueUniforms","onLoadTexture","setTexture","LoadTextureAsync","SetUniform","prepareShaderMaterialUniforms","onBind","SetMatrix","getEffect","onBindShaderMaterial","onShaderCompileSuccess","functions","cullFace","BACK","backFaceCulling","blendFunc","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","alphaMode","ZERO","ONE_MINUS_SRC_COLOR","DST_COLOR","GLTFLoader","extension","Extensions","_importMeshAsync","useRightHandedSystem","LoadRuntimeAsync","_createNodes","skl","_loadBuffersAsync","_loadShadersAsync","_loadAsync","LoadRuntimeExtensionsAsync","onload","hasShaders","processShader","LoadShaderStringAsync","VERTEX","bind","onLoad","hasBuffers","processBuffer","LoadBufferAsync","_name","loadRuntimeAsync","loadRuntimeExtensionsAsync","loadBufferAsync","loadTextureBufferAsync","createTextureAsync","loadShaderStringAsync","loadMaterialAsync","_ApplyExtensions","loaderExtension","CreateRuntime","_LoadTextureBufferAsync","_CreateTextureAsync","LoadTextureBufferAsync","CreateTextureAsync","func","defaultFunc","extensionName","GLTFBinaryExtension","super","_bin","sourceExt","binaryExtensionShader","shaderBytes","DecodeBufferToText","RegisterExtension","GLTFMaterialsCommonExtension","ambientLight","ambient","point","directional","spot","fallOffAngle","Math","PI","standardMaterial","disableLighting","doubleSided","alpha","transparency","specularPower","shininess","_loadTexture","ambientColor","emission","emissiveColor","specular","specularColor","propertyPath","getVector3","_target","offset","scaleInPlace","AnimationPropertyInfo","getValue","getStride","_buildAnimation","fps","TransformNodeAnimationPropertyInfo","buildAnimations","_babylonTransformNode","nodeAnimationData","weights","_numMorphTargets","targetIndex","map","key","inTangent","outTangent","interpolation","_primitiveBabylonMeshes","babylonMesh","morphTargetManager","morphTarget","getTarget","babylonAnimationClone","clone","mergeDeep","objects","isObject","obj","reduce","prev","Object","forEach","pVal","oVal","isArray","concat","ArrayItem","context","array","_completePromises","_assetContainer","_babylonLights","_disableInstancedMesh","_extensions","_disposed","_rootUrl","_fileName","_uniqueRootUrl","_rootBabylonMesh","_defaultBabylonMaterialData","_postSceneLoadActions","factory","UnregisterExtension","_RegisteredExtensions","gltf","_gltf","babylonScene","_babylonScene","rootBabylonMesh","_loadData","nodeMap","_getMeshes","_getSkeletons","_getAnimationGroups","_getTransformNodes","_getGeometries","resultFunc","Date","now","_loadExtensions","_checkExtensions","loadingToReadyCounterName","LOADING","READY","loadingToCompleteCounterName","COMPLETE","_extensionsOnLoading","promises","oldBlockMaterialDirtyMechanism","blockMaterialDirtyMechanism","loadSceneAsync","Get","m","babylonDrawMode","_loadMaterialAsync","_compileMaterialsAsync","_compileShadowGeneratorsAsync","all","setEnabled","_extensionsOnReady","_startAnimations","catch","_setupData","binaryBuffer","Assign","nodeParents","rootNode","_createRootNode","parentIndex","sort","order","extensionsRequired","some","enabled","_LoadTransform","FORCE_RIGHT_HANDED","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","action","_loadAnimationsAsync","logClose","_forEachPrimitive","geometry","getClassName","_babylonTransformNodeForSkin","_data","_babylonAnimationGroup","NONE","babylonAnimationGroups","start","ALL","babylonAnimationGroup","assign","_extensionsLoadNodeAsync","loadNode","babylonTransformNode","AddPointerMetadata","loadCameraAsync","babylonCamera","childNode","childBabylonMesh","nodeName","transformNode","_loadMeshAsync","babylonTransformNodeForSkin","metadata","_loadSkinAsync","parentNode","skinnedNode","useBoundingInfoFromGeometry","_updateBoundingInfo","refreshBoundingInfo","_loadMeshPrimitiveAsync","_extensionsLoadMeshPrimitiveAsync","shouldInstance","targets","babylonAbstractMesh","promise","_instanceData","babylonSourceMesh","createInstance","overrideMaterialSideOrientation","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","applyToMesh","_GetDrawMode","babylonMaterial","_createDefaultMaterial","_extensionsLoadVertexDataAsync","isUnIndexed","_loadIndicesAccessorAsync","setIndices","loadAttribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","getKind","mmin","min","mmax","max","normalized","divider","copyFromFloats","_boundingInfo","setVerticesBuffer","numBoneInfluencers","hasVertexAlpha","targetNames","extras","getScene","areUpdatesFrozen","weight","addTarget","numTargets","babylonMorphTarget","_loadMorphTargetVertexDataAsync","setData","getVertexBuffer","_loadFloatAccessorAsync","setPositions","setNormals","tangents","dataIndex","setTangents","_extensionsLoadSkinAsync","skeletonId","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","_findSkeletonRootNode","joints","isParent","skeletonNode","babylonBones","_loadBone","paths","unshift","babylonBone","parentBabylonBone","boneIndex","_getNodeMatrix","linkTransformNode","inverseBindMatrices","baseMatrix","_index","invertToRef","babylonParentBone","getParent","multiplyToRef","getInvertedAbsoluteTransform","updateMatrix","_updateDifferenceMatrix","_extensionsLoadCameraAsync","ignoreParentScaling","_babylonCamera","perspective","fov","yfov","orthographic","orthoLeft","xmag","orthoRight","orthoBottom","ymag","orthoTop","loadAnimationAsync","animationGroup","targetedAnimations","_extensionsLoadAnimationAsync","_loadAnimationChannelAsync","babylonTarget","addTargetedAnimation","normalize","animationContext","_extensionsLoadAnimationChannelAsync","properties","targetInfo","_loadAnimationChannelFromTargetInfoAsync","invfps","_loadAnimationSamplerAsync","numAnimations","property","stride","outputOffset","babylonAnimatable","inputAccessor","outputAccessor","_extensionsLoadBufferAsync","loadUriAsync","loadBufferViewAsync","_extensionsLoadBufferViewAsync","_loadAccessorAsync","numComponents","_GetNumComponents","byteStride","typedArray","_GetTypedArray","sparse","indicesBufferView","valuesBufferView","indicesData","valuesData","sparseLength","sparseData","valuesIndex","indicesIndex","componentIndex","_GetTypedArrayConstructor","_loadVertexBufferViewAsync","_babylonBuffer","engine","_babylonVertexBuffer","babylonBuffer","size","_loadMaterialMetallicRoughnessPropertiesAsync","baseColorFactor","albedoColor","metallic","metallicFactor","roughness","roughnessFactor","baseColorTexture","loadTextureInfoAsync","albedoTexture","metallicRoughnessTexture","nonColorData","metallicTexture","useMetallnessFromMetallicTextureBlue","useRoughnessFromMetallicTextureGreen","useRoughnessFromMetallicTextureAlpha","_extensionsLoadMaterialAsync","babylonData","createMaterial","babylonMeshes","loadMaterialPropertiesAsync","fillMode","enableSpecularAntiAliasing","useRadianceOverAlpha","useSpecularOverAlpha","transparencyMode","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","pbrMetallicRoughness","loadMaterialAlphaProperties","emissiveFactor","twoSidedLighting","normalTexture","bumpTexture","invertNormalMapX","invertNormalMapY","level","forceIrradianceInFragment","occlusionTexture","ambientTexture","useAmbientInGrayScale","strength","ambientTextureStrength","emissiveTexture","alphaCutOff","alphaCutoff","hasAlpha","useAlphaFromAlbedoTexture","textureInfo","_extensionsLoadTextureInfoAsync","texCoord","_textureInfo","_loadTextureAsync","coordinatesIndex","_extensionsLoadTextureAsync","DefaultSampler","image","_createTextureAsync","textureLoaderOptions","useSRGBBuffer","samplerData","_loadSampler","deferred","textureCreationOptions","noMipmap","noMipMaps","invertY","exception","mimeType","loaderOptions","loadImageAsync","dataUrl","updateURL","_GetTextureSamplingMode","_GetTextureWrapMode","_extensionsLoadUriAsync","_ValidateUri","log","babylonObject","pointer","pointers","magFilter","Uint32Array","componentTypeLength","slice","forceCompilationAsync","useInstances","clipPlane","getShadowGenerator","_forEachExtensions","_applyExtensions","functionName","actionAsync","loaderProperty","_activeLoaderExtensionFunctions","activeLoaderExtensionFunctions","onLoading","onReady","_loadUriAsync","extra","isExtensionUsed","startPerformanceCounter","endPerformanceCounter","NAME","EXT_lights_image_based","loader","_lights","extensionContext","_loadLightAsync","environmentTexture","imageData","specularImages","mipmap","faces","face","specularImageContext","specularImageSize","_babylonTexture","intensity","getReflectionTextureMatrix","irradianceCoefficients","sphericalHarmonics","convertIrradianceToLambertianRadiance","sphericalPolynomial","lodGenerationScale","updateRGBDAsync","EXT_mesh_gpu_instancing","instanceCount","translationBuffer","rotationBuffer","scaleBuffer","matrices","thinInstanceSetBuffer","EXT_meshopt_compression","bufferViewMeshopt","_meshOptData","filter","EXT_texture_webp","KHR_draco_mesh_compression","dracoCompression","dividers","uniqueId","_dracoBabylonGeometry","decodeMeshAsync","babylonVertexData","applyToGeometry","KHR_lights","babylonLight","babylonSpotLight","outerConeAngle","innerAngle","innerConeAngle","_babylonLight","falloffType","range","KHR_materials_pbrSpecularGlossiness","_loadSpecularGlossinessPropertiesAsync","diffuseFactor","reflectivityColor","specularFactor","microSurface","glossinessFactor","diffuseTexture","specularGlossinessTexture","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","KHR_materials_unlit","_loadUnlitPropertiesAsync","unlit","KHR_materials_clearcoat","_loadClearCoatPropertiesAsync","clearCoat","isEnabled","useRoughnessFromMainTexture","remapF0OnInterfaceChange","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","textureRoughness","clearcoatNormalTexture","KHR_materials_iridescence","_loadIridescencePropertiesAsync","iridescence","iridescenceFactor","indexOfRefraction","iridescenceIor","iridescenceIOR","minimumThickness","iridescenceThicknessMinimum","maximumThickness","iridescenceThicknessMaximum","iridescenceTexture","iridescenceThicknessTexture","thicknessTexture","KHR_materials_emissive_strength","_loadEmissiveProperties","emissiveStrength","scaleToRef","KHR_materials_sheen","_loadSheenPropertiesAsync","sheen","sheenColorFactor","sheenColorTexture","sheenRoughnessFactor","sheenRoughnessTexture","albedoScaling","KHR_materials_specular","_loadSpecularPropertiesAsync","metallicF0Factor","specularColorFactor","metallicReflectanceColor","specularTexture","metallicReflectanceTexture","useOnlyMetallicFromMetallicReflectanceTexture","specularColorTexture","reflectanceTexture","KHR_materials_ior","_loadIorPropertiesAsync","ior","_DEFAULT_IOR","KHR_materials_variants","rootMesh","extensionMetadata","_GetExtensionMetadata","variants","getAvailableVariants","GetAvailableVariants","variantName","select","entries","entry","lastSelected","selectVariant","SelectVariant","original","reset","Reset","getLastSelectedVariant","GetLastSelectedVariant","_variants","root","mappingIndex","mappings","mapping","mappingVariantIndex","variantIndex","variant","onClonedObservable","newOne","newRoot","hasOwnProperty","call","variantEntry","TransmissionHelper","_opaqueRenderTarget","_opaqueMeshesCache","_transparentMeshesCache","_materialObservers","_options","_GetDefaultOptions","_scene","_transmissionHelper","_parseScene","_setupRenderTargets","renderSize","samples","lodGenerationOffset","renderTargetTextureType","generateMipmaps","updateOptions","newOptions","oldOptions","getOpaqueTarget","_shouldRenderAsTransmission","subSurface","isRefractionEnabled","_addMesh","onMaterialChangedObservable","_onMeshMaterialChanged","refractionTexture","_removeMesh","idx","onNewMeshAddedObservable","onMeshRemovedObservable","transparentIdx","opaqueIdx","sceneImageProcessingapplyByPostProcess","saveSceneEnvIntensity","ignoreCameraViewport","renderList","clearColor","gammaSpace","onBeforeBindObservable","opaqueRenderTarget","environmentIntensity","imageProcessingConfiguration","applyByPostProcess","copyFrom","toLinearSpaceToRef","_applyByPostProcess","onAfterUnbindObservable","KHR_materials_transmission","_loadTransparentPropertiesAsync","pbrMaterial","volumeIndexOfRefraction","useAlbedoToTintRefraction","transmissionFactor","refractionIntensity","transmissionTexture","refractionIntensityTexture","useGltfStyleTextures","KHR_materials_translucency","_loadTranslucentPropertiesAsync","isTranslucencyEnabled","useAlbedoToTintTranslucency","translucencyFactor","translucencyIntensity","translucencyTexture","translucencyIntensityTexture","KHR_materials_volume","_loadVolumePropertiesAsync","thicknessFactor","attenuationDistance","tintColorAtDistance","attenuationColor","tintColor","useThicknessAsDepth","KHR_mesh_quantization","KHR_texture_basisu","useRGBAIfASTCBC7NotAvailableWhenUASTC","KHR_texture_transform","uOffset","vOffset","uRotationCenter","vRotationCenter","wAng","uScale","vScale","KHR_xmp_json_ld","xmp_gltf","xmp_node","packet","packets","xmp","getColor3","getFloat","getMinusFloat","getNextFloat","getFloatBy2","getTextureTransformTree","textureName","MaterialAnimationPropertyInfo","CameraAnimationPropertyInfo","LightAnimationPropertyInfo","nodesTree","__array__","__target__","camerasTree","animationPointerTree","KHR_lights_punctual","KHR_animation_pointer","_parseAnimationPointer","parts","shift","gltfTargetNode","gltfCurrentNode","part","MSFT_audio_emitter","_clips","_emitters","clips","emitters","emitterIndex","emitter","refDistance","maxDistance","rolloffFactor","distanceModel","outerAngle","_loadEmitterAsync","sound","_babylonSounds","attachToMesh","setLocalDirectionToMesh","setDirectionalCone","events","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","_babylonData","clipPromises","loop","autoplay","volume","clipContext","objectURL","weightedSound","directionalConeInnerAngle","directionalConeOuterAngle","_getEventAction","time","startOffset","currentFrame","frameOffset","play","stop","pause","babylonAnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","MSFT_lod","maxLODsToLoad","onNodeLODsLoadedObservable","onMaterialLODsLoadedObservable","_bufferLODs","_nodeIndexLOD","_nodeSignalLODs","_nodePromiseLODs","_nodeBufferLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","_materialBufferLODs","indexLOD","_loadBufferLOD","firstPromise","nodeLODs","_getLODs","ids","nodeLOD","assignWrap","previousNodeLOD","_disposeTransformNode","materialLODs","materialLOD","previousDataLOD","_disposeMaterials","previousIndexLOD","bufferLODs","end","bufferLOD","babylonMaterials","getChildMeshes","babylonMaterialsToDispose","every","babylonTextures","getActiveTextures","hasTexture","MSFT_minecraftMesh","extraContext","forceDepthWrite","separateCullingPass","MSFT_sRGBFactors","ExtrasAsMetadata","_assignExtras","gltfProp"],"sourceRoot":""}