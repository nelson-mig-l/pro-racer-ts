{"version":3,"file":"js/530.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Animations/animation.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Animations/animationKey.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Animations/animationRange.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Animations/easing.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Behaviors/Cameras/autoRotationBehavior.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Behaviors/Cameras/bouncingBehavior.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Behaviors/Cameras/framingBehavior.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Cameras/Inputs/BaseCameraPointersInput.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Cameras/Inputs/arcRotateCameraPointersInput.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Cameras/arcRotateCamera.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Cameras/arcRotateCameraInputsManager.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Cameras/cameraInputsManager.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Cameras/targetCamera.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Lights/light.ts"],"sourcesContent":["import type { IEasingFunction, EasingFunction } from \"./easing\";\r\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { AnimationKeyInterpolation } from \"./animationKey\";\r\nimport { AnimationRange } from \"./animationRange\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport { Node } from \"../node\";\r\nimport type { IAnimatable } from \"./animatable.interface\";\r\nimport { Size } from \"../Maths/math.size\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\ndeclare type Animatable = import(\"./animatable\").Animatable;\r\ndeclare type RuntimeAnimation = import(\"./runtimeAnimation\").RuntimeAnimation;\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _IAnimationState {\r\n    key: number;\r\n    repeatCount: number;\r\n    workValue?: any;\r\n    loopMode?: number;\r\n    offsetValue?: any;\r\n    highLimitValue?: any;\r\n}\r\n\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nexport class Animation {\r\n    private static _UniqueIdGenerator = 0;\r\n\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    public static AllowMatricesInterpolation = false;\r\n\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    public static AllowMatrixDecomposeForInterpolation = true;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the animation (the uniqueness is solely among other animations)\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the animation was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Stores the key frames of the animation\r\n     */\r\n    private _keys: Array<IAnimationKey>;\r\n\r\n    /**\r\n     * Stores the easing function of the animation\r\n     */\r\n    private _easingFunction: Nullable<IEasingFunction> = null;\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n\r\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * Stores an array of target property paths\r\n     */\r\n    public targetPropertyPath: string[];\r\n\r\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\r\n    public blendingSpeed = 0.01;\r\n\r\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * @internal Internal use\r\n     */\r\n    public static _PrepareAnimation(\r\n        name: string,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction\r\n    ): Nullable<Animation> {\r\n        let dataType = undefined;\r\n\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        } else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        } else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n\r\n        const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n\r\n        const keys: Array<IAnimationKey> = [\r\n            { frame: 0, value: from },\r\n            { frame: totalFrame, value: to },\r\n        ];\r\n        animation.setKeys(keys);\r\n\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    public static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation {\r\n        const animation: Animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setEasingFunction(easingFunction);\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param target defines the target where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @param scene defines the hosting scene\r\n     * @returns the animatable created for this animation\r\n     */\r\n    public static CreateAndStartAnimation(\r\n        name: string,\r\n        target: any,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void,\r\n        scene?: Scene\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        if (target.getScene) {\r\n            scene = target.getScene();\r\n        }\r\n\r\n        if (!scene) {\r\n            return null;\r\n        }\r\n\r\n        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    public static CreateAndStartHierarchyAnimation(\r\n        name: string,\r\n        node: Node,\r\n        directDescendantsOnly: boolean,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable[]> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        const scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    public static CreateMergeAndStartAnimation(\r\n        name: string,\r\n        node: Node,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        node.animations.push(animation);\r\n\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame = 0, range?: string, cloneOriginal = false, clonedName?: string): Animation {\r\n        let animation = sourceAnimation;\r\n\r\n        if (cloneOriginal) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = clonedName || animation.name;\r\n        }\r\n\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n\r\n        referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\r\n        let startIndex = 0;\r\n        const firstKey = animation._keys[0];\r\n        let endIndex = animation._keys.length - 1;\r\n        const lastKey = animation._keys[endIndex];\r\n        const valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3],\r\n        };\r\n        let referenceFound = false;\r\n        let from = firstKey.frame;\r\n        let to = lastKey.frame;\r\n        if (range) {\r\n            const rangeValue = animation.getRange(range);\r\n\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        }\r\n        let fromKeyFound = firstKey.frame === from;\r\n        let toKeyFound = lastKey.frame === to;\r\n\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            const value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            const value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            const value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Find key bookends, create them if they don't exist\r\n        let index = 0;\r\n        while (!referenceFound || !fromKeyFound || (!toKeyFound && index < animation._keys.length - 1)) {\r\n            const currentKey = animation._keys[index];\r\n            const nextKey = animation._keys[index + 1];\r\n\r\n            // If reference frame wasn't found yet, check if we can interpolate to it\r\n            if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\r\n                let value;\r\n\r\n                if (referenceFrame === currentKey.frame) {\r\n                    value = animation._getKeyValue(currentKey.value);\r\n                } else if (referenceFrame === nextKey.frame) {\r\n                    value = animation._getKeyValue(nextKey.value);\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    value = animation._interpolate(referenceFrame, animationState);\r\n                }\r\n\r\n                valueStore.referenceValue = value.clone ? value.clone() : value;\r\n                referenceFound = true;\r\n            }\r\n\r\n            // If from key wasn't found yet, check if we can interpolate to it\r\n            if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\r\n                if (from === currentKey.frame) {\r\n                    startIndex = index;\r\n                } else if (from === nextKey.frame) {\r\n                    startIndex = index + 1;\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    const value = animation._interpolate(from, animationState);\r\n                    const key: IAnimationKey = {\r\n                        frame: from,\r\n                        value: value.clone ? value.clone() : value,\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    startIndex = index + 1;\r\n                }\r\n\r\n                fromKeyFound = true;\r\n            }\r\n\r\n            // If to key wasn't found yet, check if we can interpolate to it\r\n            if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\r\n                if (to === currentKey.frame) {\r\n                    endIndex = index;\r\n                } else if (to === nextKey.frame) {\r\n                    endIndex = index + 1;\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    const value = animation._interpolate(to, animationState);\r\n                    const key: IAnimationKey = {\r\n                        frame: to,\r\n                        value: value.clone ? value.clone() : value,\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    endIndex = index + 1;\r\n                }\r\n\r\n                toKeyFound = true;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Subtract the reference value from all of the key values\r\n        for (index = startIndex; index <= endIndex; index++) {\r\n            const key = animation._keys[index];\r\n\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    public static TransitionTo(\r\n        property: string,\r\n        targetValue: any,\r\n        host: any,\r\n        scene: Scene,\r\n        frameRate: number,\r\n        transition: Animation,\r\n        duration: number,\r\n        onAnimationEnd: Nullable<() => void> = null\r\n    ): Nullable<Animatable> {\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const endFrame: number = frameRate * (duration / 1000);\r\n\r\n        transition.setKeys([\r\n            {\r\n                frame: 0,\r\n                value: host[property].clone ? host[property].clone() : host[property],\r\n            },\r\n            {\r\n                frame: endFrame,\r\n                value: targetValue,\r\n            },\r\n        ]);\r\n\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n\r\n        host.animations.push(transition);\r\n\r\n        const animation: Animatable = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\r\n    public get runtimeAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\r\n    public get hasRunningRuntimeAnimations(): boolean {\r\n        for (const runtimeAnimation of this._runtimeAnimations) {\r\n            if (!runtimeAnimation.isStopped()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    constructor(\r\n        /**Name of the animation */\r\n        public name: string,\r\n        /**Property to animate */\r\n        public targetProperty: string,\r\n        /**The frames per second of the animation */\r\n        public framePerSecond: number,\r\n        /**The data type of the animation */\r\n        public dataType: number,\r\n        /**The loop mode of the animation */\r\n        public loopMode?: number,\r\n        /**Specifies if blending should be enabled */\r\n        public enableBlending?: boolean\r\n    ) {\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n        this.uniqueId = Animation._UniqueIdGenerator++;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    public addEvent(event: AnimationEvent): void {\r\n        this._events.push(event);\r\n        this._events.sort((a, b) => a.frame - b.frame);\r\n    }\r\n\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    public removeEvents(frame: number): void {\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    public getEvents(): AnimationEvent[] {\r\n        return this._events;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    public createRange(name: string, from: number, to: number): void {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    public deleteRange(name: string, deleteFrames = true): void {\r\n        const range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n        }\r\n        if (deleteFrames) {\r\n            const from = range.from;\r\n            const to = range.to;\r\n\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (let key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    public getRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name];\r\n    }\r\n\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    public getKeys(): Array<IAnimationKey> {\r\n        return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Gets the highest frame rate of the animation\r\n     * @returns Highest frame rate of the animation\r\n     */\r\n    public getHighestFrame(): number {\r\n        let ret = 0;\r\n\r\n        for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    public getEasingFunction(): Nullable<IEasingFunction> {\r\n        return this._easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    public setEasingFunction(easingFunction: Nullable<IEasingFunction>): void {\r\n        this._easingFunction = easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number {\r\n        return Scalar.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number {\r\n        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    public vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    public sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3 {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color3InterpolateFunctionWithTangents(startValue: Color3, outTangent: Color3, endValue: Color3, inTangent: Color3, gradient: number): Color3 {\r\n        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4 {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color4InterpolateFunctionWithTangents(startValue: Color4, outTangent: Color4, endValue: Color4, inTangent: Color4, gradient: number): Color4 {\r\n        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _getKeyValue(value: any): any {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Evaluate the animation value at a given frame\r\n     * @param currentFrame defines the frame where we want to evaluate the animation\r\n     * @returns the animation value\r\n     */\r\n    public evaluate(currentFrame: number) {\r\n        return this._interpolate(currentFrame, {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: Animation.ANIMATIONLOOPMODE_CONSTANT,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _interpolate(currentFrame: number, state: _IAnimationState): any {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n\r\n        const keys = this._keys;\r\n        const keysLength = keys.length;\r\n\r\n        let key = state.key;\r\n\r\n        while (key >= 0 && currentFrame < keys[key].frame) {\r\n            --key;\r\n        }\r\n\r\n        while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\r\n            ++key;\r\n        }\r\n\r\n        state.key = key;\r\n\r\n        if (key < 0) {\r\n            return this._getKeyValue(keys[0].value);\r\n        } else if (key + 1 > keysLength - 1) {\r\n            return this._getKeyValue(keys[keysLength - 1].value);\r\n        }\r\n\r\n        const startKey = keys[key];\r\n        const endKey = keys[key + 1];\r\n        const startValue = this._getKeyValue(startKey.value);\r\n        const endValue = this._getKeyValue(endKey.value);\r\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n            if (endKey.frame > currentFrame) {\r\n                return startValue;\r\n            } else {\r\n                return endValue;\r\n            }\r\n        }\r\n\r\n        const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n        const frameDelta = endKey.frame - startKey.frame;\r\n\r\n        // gradient : percent of currentFrame between the frame inf and the frame sup\r\n        let gradient = (currentFrame - startKey.frame) / frameDelta;\r\n\r\n        // check for easingFunction and correction of gradient\r\n        const easingFunction = this.getEasingFunction();\r\n        if (easingFunction !== null) {\r\n            gradient = easingFunction.ease(gradient);\r\n        }\r\n\r\n        switch (this.dataType) {\r\n            // Float\r\n            case Animation.ANIMATIONTYPE_FLOAT: {\r\n                const floatValue = useTangent\r\n                    ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient)\r\n                    : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return floatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return state.offsetValue * state.repeatCount + floatValue;\r\n                }\r\n                break;\r\n            }\r\n            // Quaternion\r\n            case Animation.ANIMATIONTYPE_QUATERNION: {\r\n                const quatValue = useTangent\r\n                    ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return quatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n\r\n                return quatValue;\r\n            }\r\n            // Vector3\r\n            case Animation.ANIMATIONTYPE_VECTOR3: {\r\n                const vec3Value = useTangent\r\n                    ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return vec3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return vec3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Vector2\r\n            case Animation.ANIMATIONTYPE_VECTOR2: {\r\n                const vec2Value = useTangent\r\n                    ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return vec2Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return vec2Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Size\r\n            case Animation.ANIMATIONTYPE_SIZE: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color3\r\n            case Animation.ANIMATIONTYPE_COLOR3: {\r\n                const color3Value = useTangent\r\n                    ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return color3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return color3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color4\r\n            case Animation.ANIMATIONTYPE_COLOR4: {\r\n                const color4Value = useTangent\r\n                    ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return color4Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return color4Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Matrix\r\n            case Animation.ANIMATIONTYPE_MATRIX: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT: {\r\n                        if (Animation.AllowMatricesInterpolation) {\r\n                            return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                        }\r\n                        return startValue;\r\n                    }\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE: {\r\n                        return startValue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    public matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    public clone(): Animation {\r\n        const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (const name in this._ranges) {\r\n                const range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     */\r\n    public setKeys(values: Array<IAnimationKey>): void {\r\n        this._keys = values.slice(0);\r\n    }\r\n\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        const dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        const keys = this.getKeys();\r\n        for (let index = 0; index < keys.length; index++) {\r\n            const animationKey = keys[index];\r\n\r\n            const key: any = {};\r\n            key.frame = animationKey.frame;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            serializationObject.keys.push(key);\r\n        }\r\n\r\n        serializationObject.ranges = [];\r\n        for (const name in this._ranges) {\r\n            const source = this._ranges[name];\r\n\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            const range: any = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CONSTANT = 2;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _UniversalLerp(left: any, right: any, amount: number): any {\r\n        const constructor = left.constructor;\r\n        if (constructor.Lerp) {\r\n            // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        } else if (constructor.Slerp) {\r\n            // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        } else if (left.toFixed) {\r\n            // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        } else {\r\n            // Blending not supported\r\n            return right;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    public static Parse(parsedAnimation: any): Animation {\r\n        const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n\r\n        const dataType = parsedAnimation.dataType;\r\n        const keys: Array<IAnimationKey> = [];\r\n        let data;\r\n        let index: number;\r\n\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            const key = parsedAnimation.keys[index];\r\n            let inTangent: any = undefined;\r\n            let outTangent: any = undefined;\r\n            let interpolation: any = undefined;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 2) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 3) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    if (key.values.length >= 4) {\r\n                        interpolation = key.values[3];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 13) {\r\n                        interpolation = key.values[12];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    if (key.values.length >= 17) {\r\n                        interpolation = key.values[16];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Color3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Color3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    if (key.values[4]) {\r\n                        inTangent = Color4.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        outTangent = Color4.FromArray(key.values[5]);\r\n                    }\r\n                    if (key.values[6]) {\r\n                        interpolation = Color4.FromArray(key.values[6]);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Vector3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Vector3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            const keyData: any = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            if (interpolation != undefined) {\r\n                keyData.interpolation = interpolation;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        if (serializationObject.animations) {\r\n                            serializationObject = serializationObject.animations;\r\n                        }\r\n\r\n                        if (serializationObject.length) {\r\n                            const output = new Array<Animation>();\r\n                            for (const serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n\r\n                        if (snippet.animations) {\r\n                            const serializationObject = JSON.parse(snippet.animations);\r\n                            const outputs = new Array<Animation>();\r\n                            for (const serializedAnimation of serializationObject.animations) {\r\n                                const output = this.Parse(serializedAnimation);\r\n                                output.snippetId = snippetId;\r\n                                outputs.push(output);\r\n                            }\r\n\r\n                            resolve(outputs);\r\n                        } else {\r\n                            const serializationObject = JSON.parse(snippet.animation);\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            output.snippetId = snippetId;\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.Animation\", Animation);\r\nNode._AnimationRangeFactory = (name: string, from: number, to: number) => new AnimationRange(name, from, to);\r\n","/**\r\n * Defines an interface which represents an animation key frame\r\n */\r\nexport interface IAnimationKey {\r\n    /**\r\n     * Frame of the key frame\r\n     */\r\n    frame: number;\r\n    /**\r\n     * Value at the specifies key frame\r\n     */\r\n    value: any;\r\n    /**\r\n     * The input tangent for the cubic hermite spline\r\n     */\r\n    inTangent?: any;\r\n    /**\r\n     * The output tangent for the cubic hermite spline\r\n     */\r\n    outTangent?: any;\r\n    /**\r\n     * The animation interpolation type\r\n     */\r\n    interpolation?: AnimationKeyInterpolation;\r\n    /**\r\n     * Property defined by UI tools to link (or not ) the tangents\r\n     */\r\n    lockedTangent?: boolean;\r\n}\r\n\r\n/**\r\n * Enum for the animation key frame interpolation type\r\n */\r\nexport enum AnimationKeyInterpolation {\r\n    /**\r\n     * Use tangents to interpolate between start and end values.\r\n     */\r\n    NONE = 0,\r\n    /**\r\n     * Do not interpolate between keys and use the start key value only. Tangents are ignored\r\n     */\r\n    STEP = 1,\r\n}\r\n","/**\r\n * Represents the range of an animation\r\n */\r\nexport class AnimationRange {\r\n    /**\r\n     * Initializes the range of an animation\r\n     * @param name The name of the animation range\r\n     * @param from The starting frame of the animation\r\n     * @param to The ending frame of the animation\r\n     */\r\n    constructor(\r\n        /**The name of the animation range**/\r\n        public name: string,\r\n        /**The starting frame of the animation */\r\n        public from: number,\r\n        /**The ending frame of the animation*/\r\n        public to: number\r\n    ) {}\r\n\r\n    /**\r\n     * Makes a copy of the animation range\r\n     * @returns A copy of the animation range\r\n     */\r\n    public clone(): AnimationRange {\r\n        return new AnimationRange(this.name, this.from, this.to);\r\n    }\r\n}\r\n","import { BezierCurve } from \"../Maths/math.path\";\r\n\r\n/**\r\n * This represents the main contract an easing function should follow.\r\n * Easing functions are used throughout the animation system.\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport interface IEasingFunction {\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * The link below provides some of the most common examples of easing functions.\r\n     * @see https://easings.net/\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    ease(gradient: number): number;\r\n}\r\n\r\n/**\r\n * Base class used for every default easing function.\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Interpolation follows the mathematical formula associated with the easing function.\r\n     */\r\n    public static readonly EASINGMODE_EASEIN = 0;\r\n\r\n    /**\r\n     * Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.\r\n     */\r\n    public static readonly EASINGMODE_EASEOUT = 1;\r\n\r\n    /**\r\n     * Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.\r\n     */\r\n    public static readonly EASINGMODE_EASEINOUT = 2;\r\n\r\n    private _easingMode = EasingFunction.EASINGMODE_EASEIN;\r\n\r\n    /**\r\n     * Sets the easing mode of the current function.\r\n     * @param easingMode Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)\r\n     */\r\n    public setEasingMode(easingMode: number) {\r\n        const n = Math.min(Math.max(easingMode, 0), 2);\r\n        this._easingMode = n;\r\n    }\r\n    /**\r\n     * Gets the current easing mode.\r\n     * @returns the easing mode\r\n     */\r\n    public getEasingMode(): number {\r\n        return this._easingMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public easeInCore(gradient: number): number {\r\n        throw new Error(\"You must implement this method\");\r\n    }\r\n\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    public ease(gradient: number): number {\r\n        switch (this._easingMode) {\r\n            case EasingFunction.EASINGMODE_EASEIN:\r\n                return this.easeInCore(gradient);\r\n            case EasingFunction.EASINGMODE_EASEOUT:\r\n                return 1 - this.easeInCore(1 - gradient);\r\n        }\r\n\r\n        if (gradient >= 0.5) {\r\n            return (1 - this.easeInCore((1 - gradient) * 2)) * 0.5 + 0.5;\r\n        }\r\n\r\n        return this.easeInCore(gradient * 2) * 0.5;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a circle shape (see link below).\r\n * @see https://easings.net/#easeInCirc\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class CircleEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        gradient = Math.max(0, Math.min(1, gradient));\r\n        return 1.0 - Math.sqrt(1.0 - gradient * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a ease back shape (see link below).\r\n * @see https://easings.net/#easeInBack\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class BackEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a back ease easing\r\n     * @see https://easings.net/#easeInBack\r\n     * @param amplitude Defines the amplitude of the function\r\n     */\r\n    constructor(\r\n        /** Defines the amplitude of the function */\r\n        public amplitude: number = 1\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const num = Math.max(0, this.amplitude);\r\n        return Math.pow(gradient, 3.0) - gradient * num * Math.sin(3.1415926535897931 * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a bouncing shape (see link below).\r\n * @see https://easings.net/#easeInBounce\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class BounceEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a bounce easing\r\n     * @see https://easings.net/#easeInBounce\r\n     * @param bounces Defines the number of bounces\r\n     * @param bounciness Defines the amplitude of the bounce\r\n     */\r\n    constructor(\r\n        /** Defines the number of bounces */\r\n        public bounces: number = 3,\r\n        /** Defines the amplitude of the bounce */\r\n        public bounciness: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const y = Math.max(0.0, this.bounces);\r\n        let bounciness = this.bounciness;\r\n        if (bounciness <= 1.0) {\r\n            bounciness = 1.001;\r\n        }\r\n        const num9 = Math.pow(bounciness, y);\r\n        const num5 = 1.0 - bounciness;\r\n        const num4 = (1.0 - num9) / num5 + num9 * 0.5;\r\n        const num15 = gradient * num4;\r\n        const num65 = Math.log(-num15 * (1.0 - bounciness) + 1.0) / Math.log(bounciness);\r\n        const num3 = Math.floor(num65);\r\n        const num13 = num3 + 1.0;\r\n        const num8 = (1.0 - Math.pow(bounciness, num3)) / (num5 * num4);\r\n        const num12 = (1.0 - Math.pow(bounciness, num13)) / (num5 * num4);\r\n        const num7 = (num8 + num12) * 0.5;\r\n        const num6 = gradient - num7;\r\n        const num2 = num7 - num8;\r\n        return (-Math.pow(1.0 / bounciness, y - num3) / (num2 * num2)) * (num6 - num2) * (num6 + num2);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 3 shape (see link below).\r\n * @see https://easings.net/#easeInCubic\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class CubicEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with an elastic shape (see link below).\r\n * @see https://easings.net/#easeInElastic\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class ElasticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an elastic easing function\r\n     * @see https://easings.net/#easeInElastic\r\n     * @param oscillations Defines the number of oscillations\r\n     * @param springiness Defines the amplitude of the oscillations\r\n     */\r\n    constructor(\r\n        /** Defines the number of oscillations*/\r\n        public oscillations: number = 3,\r\n        /** Defines the amplitude of the oscillations*/\r\n        public springiness: number = 3\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        let num2;\r\n        const num3 = Math.max(0.0, this.oscillations);\r\n        const num = Math.max(0.0, this.springiness);\r\n\r\n        if (num == 0) {\r\n            num2 = gradient;\r\n        } else {\r\n            num2 = (Math.exp(num * gradient) - 1.0) / (Math.exp(num) - 1.0);\r\n        }\r\n        return num2 * Math.sin((6.2831853071795862 * num3 + 1.5707963267948966) * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with an exponential shape (see link below).\r\n * @see https://easings.net/#easeInExpo\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class ExponentialEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an exponential easing function\r\n     * @see https://easings.net/#easeInExpo\r\n     * @param exponent Defines the exponent of the function\r\n     */\r\n    constructor(\r\n        /** Defines the exponent of the function */\r\n        public exponent: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        if (this.exponent <= 0) {\r\n            return gradient;\r\n        }\r\n\r\n        return (Math.exp(this.exponent * gradient) - 1.0) / (Math.exp(this.exponent) - 1.0);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class PowerEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an power base easing function\r\n     * @see https://easings.net/#easeInQuad\r\n     * @param power Defines the power of the function\r\n     */\r\n    constructor(\r\n        /** Defines the power of the function */\r\n        public power: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const y = Math.max(0.0, this.power);\r\n        return Math.pow(gradient, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 2 shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuadraticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 4 shape (see link below).\r\n * @see https://easings.net/#easeInQuart\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuarticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 5 shape (see link below).\r\n * @see https://easings.net/#easeInQuint\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuinticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a sin shape (see link below).\r\n * @see https://easings.net/#easeInSine\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class SineEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return 1.0 - Math.sin(1.5707963267948966 * (1.0 - gradient));\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a bezier shape (see link below).\r\n * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n * @see https://doc.babylonjs.com/divingDeeper/animation/advanced_animations#easing-functions\r\n */\r\nexport class BezierCurveEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a bezier function\r\n     * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n     * @param x1 Defines the x component of the start tangent in the bezier curve\r\n     * @param y1 Defines the y component of the start tangent in the bezier curve\r\n     * @param x2 Defines the x component of the end tangent in the bezier curve\r\n     * @param y2 Defines the y component of the end tangent in the bezier curve\r\n     */\r\n    constructor(\r\n        /** Defines the x component of the start tangent in the bezier curve */\r\n        public x1: number = 0,\r\n        /** Defines the y component of the start tangent in the bezier curve */\r\n        public y1: number = 0,\r\n        /** Defines the x component of the end tangent in the bezier curve */\r\n        public x2: number = 1,\r\n        /** Defines the y component of the end tangent in the bezier curve */\r\n        public y2: number = 1\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return BezierCurve.Interpolate(gradient, this.x1, this.y1, this.x2, this.y2);\r\n    }\r\n}\r\n","import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n */\r\nexport class AutoRotationBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"AutoRotation\";\r\n    }\r\n\r\n    private _zoomStopsAnimation = false;\r\n    private _idleRotationSpeed = 0.05;\r\n    private _idleRotationWaitTime = 2000;\r\n    private _idleRotationSpinupTime = 2000;\r\n\r\n    public targetAlpha: Nullable<number> = null;\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the default speed at which the camera rotates around the model.\r\n     */\r\n    public set idleRotationSpeed(speed: number) {\r\n        this._idleRotationSpeed = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the default speed at which the camera rotates around the model.\r\n     */\r\n    public get idleRotationSpeed() {\r\n        return this._idleRotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public set idleRotationWaitTime(time: number) {\r\n        this._idleRotationWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public get idleRotationWaitTime() {\r\n        return this._idleRotationWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public set idleRotationSpinupTime(time: number) {\r\n        this._idleRotationSpinupTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public get idleRotationSpinupTime() {\r\n        return this._idleRotationSpinupTime;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\r\n    public get rotationInProgress(): boolean {\r\n        return Math.abs(this._cameraRotationSpeed) > 0;\r\n    }\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastFrameTime: Nullable<number> = null;\r\n    private _lastInteractionTime = -Infinity;\r\n    private _cameraRotationSpeed: number = 0;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (this._reachTargetAlpha()) {\r\n                return;\r\n            }\r\n            const now = PrecisionDate.Now;\r\n            let dt = 0;\r\n            if (this._lastFrameTime != null) {\r\n                dt = now - this._lastFrameTime;\r\n            }\r\n            this._lastFrameTime = now;\r\n\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\r\n            const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\r\n            this._cameraRotationSpeed = this._idleRotationSpeed * scale;\r\n\r\n            // Step camera rotation by rotation speed\r\n            if (this._attachedCamera) {\r\n                this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    /**\r\n     * Force-reset the last interaction time\r\n     * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\r\n     */\r\n    public resetLastInteractionTime(customTime?: number): void {\r\n        this._lastInteractionTime = customTime ?? PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Returns true if camera alpha reaches the target alpha\r\n     * @returns true if camera alpha reaches the target alpha\r\n     */\r\n    private _reachTargetAlpha(): boolean {\r\n        if (this._attachedCamera && this.targetAlpha) {\r\n            return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @returns true if user is scrolling.\r\n     */\r\n    private _userIsZooming(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    }\r\n\r\n    private _lastFrameRadius = 0;\r\n    private _shouldAnimationStopForInteraction(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        let zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    }\r\n\r\n    // Tools\r\n    private _userIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n}\r\n","import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n */\r\nexport class BouncingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Bouncing\";\r\n    }\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new BackEase(0.3);\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n\r\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\r\n    public transitionDuration = 450;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\r\n    public lowerRadiusTransitionRange = 2;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\r\n    public upperRadiusTransitionRange = -2;\r\n\r\n    private _autoTransitionRange = false;\r\n\r\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\r\n    public get autoTransitionRange(): boolean {\r\n        return this._autoTransitionRange;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\r\n    public set autoTransitionRange(value: boolean) {\r\n        if (this._autoTransitionRange === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoTransitionRange = value;\r\n\r\n        const camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n                if (!mesh) {\r\n                    return;\r\n                }\r\n\r\n                mesh.computeWorldMatrix(true);\r\n                const diagonal = mesh.getBoundingInfo().diagonalLength;\r\n\r\n                this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                this.upperRadiusTransitionRange = diagonal * 0.05;\r\n            });\r\n        } else if (this._onMeshTargetChangedObserver) {\r\n            camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n    }\r\n\r\n    // Connection\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (!this._attachedCamera) {\r\n                return;\r\n            }\r\n\r\n            // Add the bounce animation to the lower radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\r\n            }\r\n\r\n            // Add the bounce animation to the upper radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Animations\r\n    private _radiusIsAnimating: boolean = false;\r\n    private _radiusBounceTransition: Nullable<Animation> = null;\r\n    private _animatables = new Array<Animatable>();\r\n    private _cachedWheelPrecision: number;\r\n\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @returns Bool to indicate if at limit.\r\n     */\r\n    private _isRadiusAtLimit(radiusLimit: Nullable<number>): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    private _applyBoundRadiusAnimation(radiusDelta: number): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        const animatable = Animation.TransitionTo(\r\n            \"radius\",\r\n            this._attachedCamera.radius + radiusDelta,\r\n            this._attachedCamera,\r\n            this._attachedCamera.getScene(),\r\n            60,\r\n            this._radiusBounceTransition,\r\n            this.transitionDuration,\r\n            () => this._clearAnimationLocks()\r\n        );\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    protected _clearAnimationLocks(): void {\r\n        this._radiusIsAnimating = false;\r\n\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n}\r\n","import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n */\r\nexport class FramingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Framing\";\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the animation to zoom on target mesh has ended\r\n     */\r\n    public onTargetFramingAnimationEndObservable = new Observable<void>();\r\n\r\n    private _mode = FramingBehavior.FitFrustumSidesMode;\r\n    private _radiusScale = 1.0;\r\n    private _positionScale = 0.5;\r\n    private _defaultElevation = 0.3;\r\n    private _elevationReturnTime = 1500;\r\n    private _elevationReturnWaitTime = 1000;\r\n    private _zoomStopsAnimation = false;\r\n    private _framingTime = 1500;\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new ExponentialEase();\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n\r\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\r\n    public set mode(mode: number) {\r\n        this._mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\r\n    public set radiusScale(radius: number) {\r\n        this._radiusScale = radius;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\r\n    public get radiusScale(): number {\r\n        return this._radiusScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public set positionScale(scale: number) {\r\n        this._positionScale = scale;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public get positionScale(): number {\r\n        return this._positionScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public set defaultElevation(elevation: number) {\r\n        this._defaultElevation = elevation;\r\n    }\r\n\r\n    /**\r\n     * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public get defaultElevation() {\r\n        return this._defaultElevation;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public set elevationReturnTime(speed: number) {\r\n        this._elevationReturnTime = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public get elevationReturnTime(): number {\r\n        return this._elevationReturnTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public set elevationReturnWaitTime(time: number) {\r\n        this._elevationReturnWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public get elevationReturnWaitTime(): number {\r\n        return this._elevationReturnWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public set framingTime(time: number) {\r\n        this._framingTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public get framingTime() {\r\n        return this._framingTime;\r\n    }\r\n\r\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\r\n    public autoCorrectCameraLimitsAndSensibility = true;\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastInteractionTime = -Infinity;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n            if (mesh) {\r\n                this.zoomOnMesh(mesh, undefined, () => {\r\n                    this.onTargetFramingAnimationEndObservable.notifyObservers();\r\n                });\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            this._maintainCameraAboveGround();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Framing control\r\n    private _animatables = new Array<Animatable>();\r\n    private _betaIsAnimating = false;\r\n    private _betaTransition: Animation;\r\n    private _radiusTransition: Animation;\r\n    private _vectorTransition: Animation;\r\n\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        let zoomTarget: Vector3;\r\n\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        const bottom = minimumWorld.y;\r\n        const top = maximumWorld.y;\r\n        const zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        } else {\r\n            const centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        this._betaIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        let radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            const extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\r\n            this.stopAllAnimations();\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n\r\n            if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\r\n                this._attachedCamera.storeState();\r\n            }\r\n        });\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param minimumWorld\r\n     * @param maximumWorld\r\n     * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number {\r\n        const size = maximumWorld.subtract(minimumWorld);\r\n        const boxVectorGlobalDiagonal = size.length();\r\n        const frustumSlope: Vector2 = this._getFrustumSlope();\r\n\r\n        // Formula for setting distance\r\n        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\r\n        const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\r\n\r\n        // Horizon distance\r\n        const radius = radiusWithoutFraming * this._radiusScale;\r\n        const distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\r\n        const distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\r\n        let distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    private _maintainCameraAboveGround(): void {\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n\r\n        const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        const limitBeta = Math.PI * 0.5;\r\n\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n\r\n            const animatabe = Animation.TransitionTo(\r\n                \"beta\",\r\n                defaultBeta,\r\n                this._attachedCamera,\r\n                this._attachedCamera.getScene(),\r\n                60,\r\n                this._betaTransition,\r\n                this._elevationReturnTime,\r\n                () => {\r\n                    this._clearAnimationLocks();\r\n                    this.stopAllAnimations();\r\n                }\r\n            );\r\n\r\n            if (animatabe) {\r\n                this._animatables.push(animatabe);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the frustum slope based on the canvas ratio and camera FOV\r\n     * @returns The frustum slope represented as a Vector2 with X and Y slopes\r\n     */\r\n    private _getFrustumSlope(): Vector2 {\r\n        // Calculate the viewport ratio\r\n        // Aspect Ratio is Height/Width.\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return Vector2.Zero();\r\n        }\r\n\r\n        const engine = camera.getScene().getEngine();\r\n        const aspectRatio = engine.getAspectRatio(camera);\r\n\r\n        // Camera FOV is the vertical field of view (top-bottom) in radians.\r\n        // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\r\n        const frustumSlopeY = Math.tan(camera.fov / 2);\r\n\r\n        // Slope of the frustum left/right planes in view space, relative to the forward vector.\r\n        // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\r\n        // along the forward vector.\r\n        const frustumSlopeX = frustumSlopeY * aspectRatio;\r\n\r\n        return new Vector2(frustumSlopeX, frustumSlopeY);\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    private _clearAnimationLocks(): void {\r\n        this._betaIsAnimating = false;\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\r\n    public get isUserIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    public static IgnoreBoundsSizeMode = 0;\r\n\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    public static FitFrustumSidesMode = 1;\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                }\r\n\r\n                if (this._currentActiveButton === -1 && !isTouch) {\r\n                    this._currentActiveButton = evt.button;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentActiveButton = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            .onPointerObservable.add(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = this.onContextMenu.bind(this);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA\r\n     * @param _pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onButtonDown(evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onButtonUp(evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase alpha)\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease alpha)\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase beta)\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease beta)\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the reset action.\r\n     * Those keys reset the camera to its last stored state (with the method camera.storeState())\r\n     */\r\n    @serialize()\r\n    public keysReset = [220];\r\n\r\n    /**\r\n     * Defines the panning sensibility of the inputs.\r\n     * (How fast is the camera panning)\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 50.0;\r\n\r\n    /**\r\n     * Defines the zooming sensibility of the inputs.\r\n     * (How fast is the camera zooming)\r\n     */\r\n    @serialize()\r\n    public zoomingSensibility: number = 25.0;\r\n\r\n    /**\r\n     * Defines whether maintaining the alt key down switch the movement mode from\r\n     * orientation to zoom.\r\n     */\r\n    @serialize()\r\n    public useAltToZoom: boolean = true;\r\n\r\n    /**\r\n     * Rotation speed of the camera\r\n     */\r\n    @serialize()\r\n    public angularSpeed = 0.01;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY += 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX += 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysReset.indexOf(keyCode) !== -1) {\r\n                    if (camera.useInputToRestoreState) {\r\n                        camera.restoreState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation && this._hitPlane) {\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA\r\n     * @param pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt\r\n     */\r\n    public onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     */\r\n    public onButtonUp(): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n","import { serialize, serializeAsVector3, serializeAsMeshReference, serializeAsVector2 } from \"../Misc/decorators\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AutoRotationBehavior } from \"../Behaviors/Cameras/autoRotationBehavior\";\r\nimport { BouncingBehavior } from \"../Behaviors/Cameras/bouncingBehavior\";\r\nimport { FramingBehavior } from \"../Behaviors/Cameras/framingBehavior\";\r\nimport { Camera } from \"./camera\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport type { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport type { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport type { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\nNode.AddNodeConstructor(\"ArcRotateCamera\", (name, scene) => {\r\n    return () => new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents an orbital type of camera.\r\n *\r\n * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\r\n * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.\r\n * @see https://doc.babylonjs.com/babylon101/cameras#arc-rotate-camera\r\n */\r\nexport class ArcRotateCamera extends TargetCamera {\r\n    /**\r\n     * Defines the rotation angle of the camera along the longitudinal axis.\r\n     */\r\n    @serialize()\r\n    public alpha: number;\r\n\r\n    /**\r\n     * Defines the rotation angle of the camera along the latitudinal axis.\r\n     */\r\n    @serialize()\r\n    public beta: number;\r\n\r\n    /**\r\n     * Defines the radius of the camera from it s target point.\r\n     */\r\n    @serialize()\r\n    public radius: number;\r\n\r\n    /**\r\n     * Defines an override value to use as the parameter to setTarget.\r\n     * This allows the parameter to be specified when animating the target (e.g. using FramingBehavior).\r\n     */\r\n    @serialize()\r\n    public overrideCloneAlphaBetaRadius: Nullable<boolean>;\r\n\r\n    @serializeAsVector3(\"target\")\r\n    protected _target: Vector3;\r\n    @serializeAsMeshReference(\"targetHost\")\r\n    protected _targetHost: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it from the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this._target;\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Defines the target mesh of the camera.\r\n     * The camera looks towards it from the radius distance.\r\n     * Please note that setting a target host will disable panning.\r\n     */\r\n    public get targetHost(): Nullable<AbstractMesh> {\r\n        return this._targetHost;\r\n    }\r\n    public set targetHost(value: Nullable<AbstractMesh>) {\r\n        if (value) {\r\n            this.setTarget(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this.target;\r\n    }\r\n\r\n    /**\r\n     * Define the current local position of the camera in the scene\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this.setPosition(newPosition);\r\n    }\r\n\r\n    protected _upToYMatrix: Matrix;\r\n    protected _yToUpMatrix: Matrix;\r\n\r\n    /**\r\n     * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.\r\n     * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.\r\n     */\r\n    set upVector(vec: Vector3) {\r\n        if (!this._upToYMatrix) {\r\n            this._yToUpMatrix = new Matrix();\r\n            this._upToYMatrix = new Matrix();\r\n\r\n            this._upVector = Vector3.Zero();\r\n        }\r\n\r\n        vec.normalize();\r\n        this._upVector.copyFrom(vec);\r\n        this.setMatUp();\r\n    }\r\n\r\n    get upVector() {\r\n        return this._upVector;\r\n    }\r\n\r\n    /**\r\n     * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.\r\n     */\r\n    public setMatUp() {\r\n        // from y-up to custom-up (used in _getViewMatrix)\r\n        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);\r\n\r\n        // from custom-up to y-up (used in rebuildAnglesAndRadius)\r\n        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);\r\n    }\r\n\r\n    /**\r\n     * Current inertia value on the longitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialAlphaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the latitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialBetaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the radius axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialRadiusOffset = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Minimum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerBetaLimit = 0.01;\r\n\r\n    /**\r\n     * Maximum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperBetaLimit = Math.PI - 0.01;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the target (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the target (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the X axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningX: number = 0;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the Y axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningY: number = 0;\r\n\r\n    /**\r\n     * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\r\n     * Basically if your fingers moves away from more than this distance you will be considered\r\n     * in pinch mode.\r\n     */\r\n    @serialize()\r\n    public pinchToPanMaxDistance: number = 20;\r\n\r\n    /**\r\n     * Defines the maximum distance the camera can pan.\r\n     * This could help keeping the camera always in your scene.\r\n     */\r\n    @serialize()\r\n    public panningDistanceLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Defines the target of the camera before panning.\r\n     */\r\n    @serializeAsVector3()\r\n    public panningOriginTarget: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Defines the value of the inertia used during panning.\r\n     * 0 would mean stop inertia and one would mean no deceleration at all.\r\n     */\r\n    @serialize()\r\n    public panningInertia = 0.9;\r\n\r\n    //-- begin properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityX(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityX;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityX(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityX = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityY(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityY;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityY(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityY = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    public get pinchPrecision(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchPrecision(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchDeltaPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\r\n    public get pinchDeltaPercentage(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchDeltaPercentage(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer use natural pinch zoom to override the pinch precision\r\n     * and pinch delta percentage.\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     */\r\n    public get useNaturalPinchZoom(): boolean {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.useNaturalPinchZoom;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set useNaturalPinchZoom(value: boolean) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.useNaturalPinchZoom = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    public get panningSensibility(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.panningSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set panningSensibility(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.panningSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    public get wheelPrecision(): number {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelPrecision(value: number) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public get zoomToMouseLocation(): boolean {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.zoomToMouseLocation;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set zoomToMouseLocation(value: boolean) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.zoomToMouseLocation = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchDeltaPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\r\n    public get wheelDeltaPercentage(): number {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelDeltaPercentage(value: number) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    //-- end properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Defines how much the radius should be scaled while zooming on a particular mesh (through the zoomOn function)\r\n     */\r\n    @serialize()\r\n    public zoomOnFactor = 1;\r\n\r\n    /**\r\n     * Defines a screen offset for the camera position.\r\n     */\r\n    @serializeAsVector2()\r\n    public targetScreenOffset = Vector2.Zero();\r\n\r\n    /**\r\n     * Allows the camera to be completely reversed.\r\n     * If false the camera can not arrive upside down.\r\n     */\r\n    @serialize()\r\n    public allowUpsideDown = true;\r\n\r\n    /**\r\n     * Define if double tap/click is used to restore the previously saved state of the camera.\r\n     */\r\n    @serialize()\r\n    public useInputToRestoreState = true;\r\n\r\n    /** @internal */\r\n    public _viewMatrix = new Matrix();\r\n    /** @internal */\r\n    public _useCtrlForPanning: boolean;\r\n    /** @internal */\r\n    public _panningMouseButton: number;\r\n\r\n    /**\r\n     * Defines the input associated to the camera.\r\n     */\r\n    public inputs: ArcRotateCameraInputsManager;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    /**\r\n     * Defines the allowed panning axis.\r\n     */\r\n    public panningAxis: Vector3 = new Vector3(1, 1, 0);\r\n    protected _transformedDirection: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * Defines if camera will eliminate transform on y axis.\r\n     */\r\n    public mapPanning: boolean = false;\r\n\r\n    // Behaviors\r\n    private _bouncingBehavior: Nullable<BouncingBehavior>;\r\n\r\n    /**\r\n     * Gets the bouncing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n     */\r\n    public get bouncingBehavior(): Nullable<BouncingBehavior> {\r\n        return this._bouncingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the bouncing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n     */\r\n    public get useBouncingBehavior(): boolean {\r\n        return this._bouncingBehavior != null;\r\n    }\r\n\r\n    public set useBouncingBehavior(value: boolean) {\r\n        if (value === this.useBouncingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._bouncingBehavior = new BouncingBehavior();\r\n            this.addBehavior(this._bouncingBehavior);\r\n        } else if (this._bouncingBehavior) {\r\n            this.removeBehavior(this._bouncingBehavior);\r\n            this._bouncingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _framingBehavior: Nullable<FramingBehavior>;\r\n\r\n    /**\r\n     * Gets the framing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n     */\r\n    public get framingBehavior(): Nullable<FramingBehavior> {\r\n        return this._framingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the framing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n     */\r\n    public get useFramingBehavior(): boolean {\r\n        return this._framingBehavior != null;\r\n    }\r\n\r\n    public set useFramingBehavior(value: boolean) {\r\n        if (value === this.useFramingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._framingBehavior = new FramingBehavior();\r\n            this.addBehavior(this._framingBehavior);\r\n        } else if (this._framingBehavior) {\r\n            this.removeBehavior(this._framingBehavior);\r\n            this._framingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _autoRotationBehavior: Nullable<AutoRotationBehavior>;\r\n\r\n    /**\r\n     * Gets the auto rotation behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n     */\r\n    public get autoRotationBehavior(): Nullable<AutoRotationBehavior> {\r\n        return this._autoRotationBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the auto rotation behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n     */\r\n    public get useAutoRotationBehavior(): boolean {\r\n        return this._autoRotationBehavior != null;\r\n    }\r\n\r\n    public set useAutoRotationBehavior(value: boolean) {\r\n        if (value === this.useAutoRotationBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._autoRotationBehavior = new AutoRotationBehavior();\r\n            this.addBehavior(this._autoRotationBehavior);\r\n        } else if (this._autoRotationBehavior) {\r\n            this.removeBehavior(this._autoRotationBehavior);\r\n            this._autoRotationBehavior = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable triggered when the mesh target has been changed on the camera.\r\n     */\r\n    public onMeshTargetChangedObservable = new Observable<Nullable<AbstractMesh>>();\r\n\r\n    /**\r\n     * Event raised when the camera is colliding with a mesh.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Defines whether the camera should check collision with the objects oh the scene.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#how-can-i-do-this\r\n     */\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Defines the collision radius of the camera.\r\n     * This simulates a sphere around the camera.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n     */\r\n    public collisionRadius = new Vector3(0.5, 0.5, 0.5);\r\n\r\n    protected _collider: Collider;\r\n    protected _previousPosition = Vector3.Zero();\r\n    protected _collisionVelocity = Vector3.Zero();\r\n    protected _newPosition = Vector3.Zero();\r\n    protected _previousAlpha: number;\r\n    protected _previousBeta: number;\r\n    protected _previousRadius: number;\r\n    //due to async collision inspection\r\n    protected _collisionTriggered: boolean;\r\n\r\n    protected _targetBoundingCenter: Nullable<Vector3>;\r\n\r\n    private _computationVector: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Instantiates a new ArcRotateCamera in a given scene\r\n     * @param name Defines the name of the camera\r\n     * @param alpha Defines the camera rotation along the longitudinal axis\r\n     * @param beta Defines the camera rotation along the latitudinal axis\r\n     * @param radius Defines the camera distance from its target\r\n     * @param target Defines the camera target\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);\r\n\r\n        this._target = Vector3.Zero();\r\n        if (target) {\r\n            this.setTarget(target);\r\n        }\r\n\r\n        this.alpha = alpha;\r\n        this.beta = beta;\r\n        this.radius = radius;\r\n\r\n        this.getViewMatrix();\r\n        this.inputs = new ArcRotateCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n    }\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _initCache(): void {\r\n        super._initCache();\r\n        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.alpha = undefined;\r\n        this._cache.beta = undefined;\r\n        this._cache.radius = undefined;\r\n        this._cache.targetScreenOffset = Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        this._cache._target.copyFrom(this._getTargetPosition());\r\n        this._cache.alpha = this.alpha;\r\n        this._cache.beta = this.beta;\r\n        this._cache.radius = this.radius;\r\n        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\r\n    }\r\n\r\n    protected _getTargetPosition(): Vector3 {\r\n        if (this._targetHost && this._targetHost.getAbsolutePosition) {\r\n            const pos: Vector3 = this._targetHost.getAbsolutePosition();\r\n            if (this._targetBoundingCenter) {\r\n                pos.addToRef(this._targetBoundingCenter, this._target);\r\n            } else {\r\n                this._target.copyFrom(pos);\r\n            }\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        if (lockedTargetPosition) {\r\n            return lockedTargetPosition;\r\n        }\r\n\r\n        return this._target;\r\n    }\r\n\r\n    private _storedAlpha: number;\r\n    private _storedBeta: number;\r\n    private _storedRadius: number;\r\n    private _storedTarget: Vector3;\r\n    private _storedTargetScreenOffset: Vector2;\r\n\r\n    /**\r\n     * Stores the current state of the camera (alpha, beta, radius and target)\r\n     * @returns the camera itself\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedAlpha = this.alpha;\r\n        this._storedBeta = this.beta;\r\n        this._storedRadius = this.radius;\r\n        this._storedTarget = this._getTargetPosition().clone();\r\n        this._storedTargetScreenOffset = this.targetScreenOffset.clone();\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Restored camera state. You must call storeState() first\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.setTarget(this._storedTarget.clone());\r\n        this.alpha = this._storedAlpha;\r\n        this.beta = this._storedBeta;\r\n        this.radius = this._storedRadius;\r\n        this.targetScreenOffset = this._storedTargetScreenOffset.clone();\r\n\r\n        this.inertialAlphaOffset = 0;\r\n        this.inertialBetaOffset = 0;\r\n        this.inertialRadiusOffset = 0;\r\n        this.inertialPanningX = 0;\r\n        this.inertialPanningY = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._cache._target.equals(this._getTargetPosition()) &&\r\n            this._cache.alpha === this.alpha &&\r\n            this._cache.beta === this.beta &&\r\n            this._cache.radius === this.radius &&\r\n            this._cache.targetScreenOffset.equals(this.targetScreenOffset)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     */\r\n    public attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean, panningMouseButton: number): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean, useCtrlForPanning: boolean | number = true, panningMouseButton: number = 2): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        const args = arguments;\r\n\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);\r\n        this._useCtrlForPanning = useCtrlForPanning as boolean;\r\n        this._panningMouseButton = panningMouseButton;\r\n        // backwards compatibility\r\n        if (typeof args[0] === \"boolean\") {\r\n            if (args.length > 1) {\r\n                this._useCtrlForPanning = args[1];\r\n            }\r\n            if (args.length > 2) {\r\n                this._panningMouseButton = args[2];\r\n            }\r\n        }\r\n\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {\r\n            this.inertialAlphaOffset = 0;\r\n            this.inertialBetaOffset = 0;\r\n            this.inertialRadiusOffset = 0;\r\n            this.inertialPanningX = 0;\r\n            this.inertialPanningY = 0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\r\n        if (this._collisionTriggered) {\r\n            return;\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n        // Inertia\r\n        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\r\n            const directionModifier = this.invertRotation ? -1 : 1;\r\n            let inertialAlphaOffset = this.inertialAlphaOffset;\r\n            if (this.beta <= 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            if (this.getScene().useRightHandedSystem) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            this.alpha += inertialAlphaOffset * directionModifier;\r\n\r\n            this.beta += this.inertialBetaOffset * directionModifier;\r\n\r\n            this.radius -= this.inertialRadiusOffset;\r\n            this.inertialAlphaOffset *= this.inertia;\r\n            this.inertialBetaOffset *= this.inertia;\r\n            this.inertialRadiusOffset *= this.inertia;\r\n            if (Math.abs(this.inertialAlphaOffset) < Epsilon) {\r\n                this.inertialAlphaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialBetaOffset) < Epsilon) {\r\n                this.inertialBetaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {\r\n                this.inertialRadiusOffset = 0;\r\n            }\r\n        }\r\n\r\n        // Panning inertia\r\n        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\r\n            const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\r\n\r\n            this._viewMatrix.invertToRef(this._cameraTransformMatrix);\r\n            localDirection.multiplyInPlace(this.panningAxis);\r\n            Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);\r\n            // Eliminate y if mapPanning is enabled\r\n            if (this.mapPanning || !this.panningAxis.y) {\r\n                this._transformedDirection.y = 0;\r\n            }\r\n\r\n            if (!this._targetHost) {\r\n                if (this.panningDistanceLimit) {\r\n                    this._transformedDirection.addInPlace(this._target);\r\n                    const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);\r\n                    if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {\r\n                        this._target.copyFrom(this._transformedDirection);\r\n                    }\r\n                } else {\r\n                    this._target.addInPlace(this._transformedDirection);\r\n                }\r\n            }\r\n\r\n            this.inertialPanningX *= this.panningInertia;\r\n            this.inertialPanningY *= this.panningInertia;\r\n\r\n            if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {\r\n                this.inertialPanningX = 0;\r\n            }\r\n            if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {\r\n                this.inertialPanningY = 0;\r\n            }\r\n        }\r\n\r\n        // Limits\r\n        this._checkLimits();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _checkLimits() {\r\n        if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta > Math.PI) {\r\n                this.beta = this.beta - 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta < this.lowerBetaLimit) {\r\n                this.beta = this.lowerBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta < -Math.PI) {\r\n                this.beta = this.beta + 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta > this.upperBetaLimit) {\r\n                this.beta = this.upperBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {\r\n            this.alpha = this.lowerAlphaLimit;\r\n        }\r\n        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {\r\n            this.alpha = this.upperAlphaLimit;\r\n        }\r\n\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds angles (alpha, beta) and radius from the give position and target\r\n     */\r\n    public rebuildAnglesAndRadius(): void {\r\n        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);\r\n\r\n        // need to rotate to Y up equivalent if up vector not Axis.Y\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);\r\n        }\r\n\r\n        this.radius = this._computationVector.length();\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        // Alpha\r\n        const previousAlpha = this.alpha;\r\n        if (this._computationVector.x === 0 && this._computationVector.z === 0) {\r\n            this.alpha = Math.PI / 2; // avoid division by zero when looking along up axis, and set to acos(0)\r\n        } else {\r\n            this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));\r\n        }\r\n\r\n        if (this._computationVector.z < 0) {\r\n            this.alpha = 2 * Math.PI - this.alpha;\r\n        }\r\n\r\n        // Calculate the number of revolutions between the new and old alpha values.\r\n        const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2.0 * Math.PI));\r\n        // Adjust alpha so that its numerical representation is the closest one to the old value.\r\n        this.alpha += alphaCorrectionTurns * 2.0 * Math.PI;\r\n\r\n        // Beta\r\n        this.beta = Math.acos(this._computationVector.y / this.radius);\r\n\r\n        this._checkLimits();\r\n    }\r\n\r\n    /**\r\n     * Use a position to define the current camera related information like alpha, beta and radius\r\n     * @param position Defines the position to set the camera at\r\n     */\r\n    public setPosition(position: Vector3): void {\r\n        if (this._position.equals(position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(position);\r\n\r\n        this.rebuildAnglesAndRadius();\r\n    }\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * This will automatically adapt alpha beta and radius to fit within the new target.\r\n     * Please note that setting a target as a mesh will disable panning.\r\n     * @param target Defines the new target as a Vector or a mesh\r\n     * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center\r\n     * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)\r\n     * @param cloneAlphaBetaRadius If true, replicate the current setup (alpha, beta, radius) on the new target\r\n     */\r\n    public setTarget(target: AbstractMesh | Vector3, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false): void {\r\n        cloneAlphaBetaRadius = this.overrideCloneAlphaBetaRadius ?? cloneAlphaBetaRadius;\r\n\r\n        if ((<any>target).getBoundingInfo) {\r\n            if (toBoundingCenter) {\r\n                this._targetBoundingCenter = (<any>target).getBoundingInfo().boundingBox.centerWorld.clone();\r\n            } else {\r\n                this._targetBoundingCenter = null;\r\n            }\r\n            (<AbstractMesh>target).computeWorldMatrix();\r\n            this._targetHost = <AbstractMesh>target;\r\n            this._target = this._getTargetPosition();\r\n\r\n            this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);\r\n        } else {\r\n            const newTarget = <Vector3>target;\r\n            const currentTarget = this._getTargetPosition();\r\n            if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\r\n                return;\r\n            }\r\n            this._targetHost = null;\r\n            this._target = newTarget;\r\n            this._targetBoundingCenter = null;\r\n            this.onMeshTargetChangedObservable.notifyObservers(null);\r\n        }\r\n\r\n        if (!cloneAlphaBetaRadius) {\r\n            this.rebuildAnglesAndRadius();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        // Compute\r\n        const cosa = Math.cos(this.alpha);\r\n        const sina = Math.sin(this.alpha);\r\n        const cosb = Math.cos(this.beta);\r\n        let sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        const target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n\r\n        // Rotate according to up vector\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);\r\n        }\r\n\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        if (this.getScene().collisionsEnabled && this.checkCollisions) {\r\n            const coordinator = this.getScene().collisionCoordinator;\r\n            if (!this._collider) {\r\n                this._collider = coordinator.createCollider();\r\n            }\r\n            this._collider._radius = this.collisionRadius;\r\n            this._newPosition.subtractToRef(this._position, this._collisionVelocity);\r\n            this._collisionTriggered = true;\r\n            coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n        } else {\r\n            this._position.copyFrom(this._newPosition);\r\n\r\n            let up = this.upVector;\r\n            if (this.allowUpsideDown && sinb < 0) {\r\n                up = up.negate();\r\n            }\r\n\r\n            this._computeViewMatrix(this._position, target, up);\r\n\r\n            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n        }\r\n        this._currentTarget = target;\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        if (!collidedMesh) {\r\n            this._previousPosition.copyFrom(this._position);\r\n        } else {\r\n            this.setPosition(newPosition);\r\n\r\n            if (this.onCollide) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n\r\n        // Recompute because of constraints\r\n        const cosa = Math.cos(this.alpha);\r\n        const sina = Math.sin(this.alpha);\r\n        const cosb = Math.cos(this.beta);\r\n        let sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        const target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        this._position.copyFrom(this._newPosition);\r\n\r\n        let up = this.upVector;\r\n        if (this.allowUpsideDown && this.beta < 0) {\r\n            up = up.clone();\r\n            up = up.negate();\r\n        }\r\n\r\n        this._computeViewMatrix(this._position, target, up);\r\n        this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n        this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n\r\n        this._collisionTriggered = false;\r\n    };\r\n\r\n    /**\r\n     * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.\r\n     * @param meshes Defines the mesh to zoom on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public zoomOn(meshes?: AbstractMesh[], doNotUpdateMaxZ = false): void {\r\n        meshes = meshes || this.getScene().meshes;\r\n\r\n        const minMaxVector = Mesh.MinMax(meshes);\r\n        const distance = Vector3.Distance(minMaxVector.min, minMaxVector.max);\r\n\r\n        this.radius = distance * this.zoomOnFactor;\r\n\r\n        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);\r\n    }\r\n\r\n    /**\r\n     * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.\r\n     * The target will be changed but the radius\r\n     * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public focusOn(meshesOrMinMaxVectorAndDistance: AbstractMesh[] | { min: Vector3; max: Vector3; distance: number }, doNotUpdateMaxZ = false): void {\r\n        let meshesOrMinMaxVector: { min: Vector3; max: Vector3 };\r\n        let distance: number;\r\n\r\n        if ((<any>meshesOrMinMaxVectorAndDistance).min === undefined) {\r\n            // meshes\r\n            const meshes = <AbstractMesh[]>meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\r\n            meshesOrMinMaxVector = Mesh.MinMax(meshes);\r\n            distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\r\n        } else {\r\n            //minMaxVector and distance\r\n            const minMaxVectorAndDistance = <any>meshesOrMinMaxVectorAndDistance;\r\n            meshesOrMinMaxVector = minMaxVectorAndDistance;\r\n            distance = minMaxVectorAndDistance.distance;\r\n        }\r\n\r\n        this._target = Mesh.Center(meshesOrMinMaxVector);\r\n\r\n        if (!doNotUpdateMaxZ) {\r\n            this.maxZ = distance * 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     * Override Camera.createRigCamera\r\n     */\r\n    public createRigCamera(name: string, cameraIndex: number): Camera {\r\n        let alphaShift: number = 0;\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\r\n                break;\r\n        }\r\n        const rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\r\n        rigCam._cameraRigParams = {};\r\n        rigCam.isRigCamera = true;\r\n        rigCam.rigParent = this;\r\n        rigCam.upVector = this.upVector;\r\n\r\n        rigCam.mode = this.mode;\r\n        rigCam.orthoLeft = this.orthoLeft;\r\n        rigCam.orthoRight = this.orthoRight;\r\n        rigCam.orthoBottom = this.orthoBottom;\r\n        rigCam.orthoTop = this.orthoTop;\r\n\r\n        return rigCam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @override\r\n     * Override Camera._updateRigCameras\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <ArcRotateCamera>this._rigCameras[0];\r\n        const camRight = <ArcRotateCamera>this._rigCameras[1];\r\n\r\n        camLeft.beta = camRight.beta = this.beta;\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCamera\";\r\n    }\r\n}\r\n","import type { ArcRotateCamera } from \"./arcRotateCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: ArcRotateCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n}\r\n","import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     * @param input camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        //for checkInputs, we are dynamically creating a function\r\n        //the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            this.lockedTarget.computeWorldMatrix();\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this.position.addInPlace(TmpVectors.Vector3[0]);\r\n            return;\r\n        }\r\n        this.position.addInPlace(this.cameraDirection);\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n            }\r\n\r\n            this.rotation.x += this.cameraRotation.x * directionMultiplier;\r\n            this.rotation.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this.rotation.x > limit) {\r\n                    this.rotation.x = limit;\r\n                }\r\n                if (this.rotation.x < -limit) {\r\n                    this.rotation.x = -limit;\r\n                }\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n","import { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\n\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Shadow generator associated to the light.\r\n     * @internal Internal use only.\r\n     */\r\n    public _shadowGenerator: Nullable<IShadowGenerator>;\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = new Array<AbstractMesh>();\r\n        this.excludedMeshes = new Array<AbstractMesh>();\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @returns the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return this._shadowGenerator;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @returns true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.dispose();\r\n            this._shadowGenerator = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        if (parsedLight.parentInstanceIndex !== undefined) {\r\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @internal Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @internal Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n}\r\n"],"names":["_IAnimationState","Animation","constructor","name","targetProperty","framePerSecond","dataType","loopMode","enableBlending","_easingFunction","_runtimeAnimations","Array","_events","blendingSpeed","_ranges","this","targetPropertyPath","split","undefined","ANIMATIONLOOPMODE_CYCLE","uniqueId","_UniqueIdGenerator","static","totalFrame","from","to","easingFunction","isNaN","parseFloat","isFinite","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_COLOR3","ANIMATIONTYPE_COLOR4","ANIMATIONTYPE_SIZE","animation","keys","frame","value","setKeys","setEasingFunction","property","animationType","ANIMATIONLOOPMODE_CONSTANT","target","onAnimationEnd","scene","_PrepareAnimation","getScene","beginDirectAnimation","node","directDescendantsOnly","beginDirectHierarchyAnimation","animations","push","beginAnimation","sourceAnimation","referenceFrame","range","cloneOriginal","clonedName","clone","_keys","length","startIndex","firstKey","endIndex","lastKey","valueStore","referenceValue","referencePosition","referenceQuaternion","referenceScaling","keyPosition","keyQuaternion","keyScaling","referenceFound","rangeValue","getRange","fromKeyFound","toKeyFound","_getKeyValue","index","currentKey","nextKey","animationState","key","repeatCount","_interpolate","splice","normalize","conjugateInPlace","ANIMATIONTYPE_MATRIX","decompose","subtractInPlace","divideInPlace","multiplyToRef","subtractToRef","width","height","targetValue","host","frameRate","transition","duration","endFrame","runtimeAnimations","hasRunningRuntimeAnimations","runtimeAnimation","isStopped","toString","fullDetails","ret","Object","first","addEvent","event","sort","a","b","removeEvents","getEvents","createRange","deleteRange","deleteFrames","getKeys","getHighestFrame","nKeys","getEasingFunction","floatInterpolateFunction","startValue","endValue","gradient","floatInterpolateFunctionWithTangents","outTangent","inTangent","quaternionInterpolateFunction","quaternionInterpolateFunctionWithTangents","vector3InterpolateFunction","vector3InterpolateFunctionWithTangents","vector2InterpolateFunction","vector2InterpolateFunctionWithTangents","sizeInterpolateFunction","color3InterpolateFunction","color3InterpolateFunctionWithTangents","color4InterpolateFunction","color4InterpolateFunctionWithTangents","evaluate","currentFrame","state","highLimitValue","keysLength","startKey","endKey","interpolation","useTangent","frameDelta","ease","floatValue","ANIMATIONLOOPMODE_RELATIVE","offsetValue","quatValue","scale","addInPlace","vec3Value","add","vec2Value","color3Value","color4Value","AllowMatricesInterpolation","matrixInterpolateFunction","workValue","result","AllowMatrixDecomposeForInterpolation","join","values","slice","serialize","serializationObject","loopBehavior","animationKey","asArray","ranges","source","left","right","amount","Lerp","Slerp","toFixed","parsedAnimation","data","_inTangent","equals","_outTangent","keyData","destination","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","parse","responseText","output","serializedAnimation","Parse","open","send","snippetId","snippet","jsonPayload","outputs","SnippetUrl","replace","CreateFromSnippetAsync","ParseFromSnippetAsync","N","AnimationKeyInterpolation","AnimationRange","EasingFunction","_easingMode","EASINGMODE_EASEIN","setEasingMode","easingMode","n","Math","min","max","getEasingMode","easeInCore","Error","EASINGMODE_EASEOUT","EASINGMODE_EASEINOUT","CircleEase","sqrt","BackEase","amplitude","super","num","pow","sin","BounceEase","bounces","bounciness","y","num9","num5","num4","num15","num65","log","num3","floor","num13","num8","num7","num6","num2","CubicEase","ElasticEase","oscillations","springiness","exp","ExponentialEase","exponent","PowerEase","power","QuadraticEase","QuarticEase","QuinticEase","SineEase","BezierCurveEase","x1","y1","x2","y2","AutoRotationBehavior","_zoomStopsAnimation","_idleRotationSpeed","_idleRotationWaitTime","_idleRotationSpinupTime","targetAlpha","_isPointerDown","_lastFrameTime","_lastInteractionTime","_cameraRotationSpeed","_lastFrameRadius","zoomStopsAnimation","flag","idleRotationSpeed","speed","idleRotationWaitTime","time","idleRotationSpinupTime","rotationInProgress","abs","init","attach","camera","_attachedCamera","_onPrePointerObservableObserver","onPrePointerObservable","pointerInfoPre","type","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_reachTargetAlpha","now","dt","_applyUserInteraction","timeToRotation","alpha","detach","remove","resetLastInteractionTime","customTime","_userIsZooming","inertialRadiusOffset","_shouldAnimationStopForInteraction","zoomHasHitLimit","radius","_userIsMoving","inertialAlphaOffset","inertialBetaOffset","inertialPanningX","inertialPanningY","BouncingBehavior","transitionDuration","lowerRadiusTransitionRange","upperRadiusTransitionRange","_autoTransitionRange","_radiusIsAnimating","_radiusBounceTransition","_animatables","autoTransitionRange","_onMeshTargetChangedObserver","onMeshTargetChangedObservable","mesh","computeWorldMatrix","diagonal","getBoundingInfo","diagonalLength","_isRadiusAtLimit","lowerRadiusLimit","_applyBoundRadiusAnimation","upperRadiusLimit","radiusLimit","radiusDelta","EasingMode","_cachedWheelPrecision","wheelPrecision","Infinity","stopAllAnimations","animatable","_clearAnimationLocks","stop","shift","FramingBehavior","onTargetFramingAnimationEndObservable","_mode","FitFrustumSidesMode","_radiusScale","_positionScale","_defaultElevation","_elevationReturnTime","_elevationReturnWaitTime","_framingTime","autoCorrectCameraLimitsAndSensibility","_betaIsAnimating","mode","radiusScale","positionScale","defaultElevation","elevation","elevationReturnTime","elevationReturnWaitTime","framingTime","zoomOnMesh","notifyObservers","_maintainCameraAboveGround","focusOnOriginXZ","boundingBox","zoomOnBoundingInfo","minimumWorld","maximumWorld","zoomOnMeshHierarchy","getHierarchyBoundingVectors","zoomOnMeshesHierarchy","meshes","Number","MAX_VALUE","i","boundingInfo","zoomTarget","bottom","zoomTargetY","radiusWorld","subtract","centerWorld","x","z","_vectorTransition","position","_calculateLowerRadiusFromModelBoundingSphere","minZ","IgnoreBoundsSizeMode","extend","panningSensibility","_radiusTransition","useInputToRestoreState","storeState","boxVectorGlobalDiagonal","frustumSlope","_getFrustumSlope","distanceForHorizontalFrustum","distanceForVerticalFrustum","distance","timeSinceInteraction","defaultBeta","PI","limitBeta","beta","_betaTransition","animatabe","aspectRatio","getEngine","getAspectRatio","frustumSlopeY","tan","fov","frustumSlopeX","isUserIsMoving","BaseCameraPointersInput","_currentActiveButton","buttons","attachControl","noPreventDefault","arguments","engine","element","getInputElement","previousPinchSquaredDistance","previousMultiTouchPanPosition","_pointA","_pointB","_altKey","_ctrlKey","_metaKey","_shiftKey","_buttonsPressed","_pointerInput","p","evt","isTouch","pointerType","isInVRExclusivePointerMode","indexOf","button","srcElement","altKey","ctrlKey","metaKey","shiftKey","isPointerLock","offsetX","movementX","offsetY","movementY","onTouch","onDoubleTap","preventDefault","clientX","clientY","ed","pointerId","distX","distY","pinchSquaredDistance","multiTouchPanPosition","onMultiTouch","releasePointerCapture","e","_badOS","onButtonUp","setPointerCapture","onButtonDown","focus","_observer","onPointerObservable","_onLostFocus","onLostFocus","_contextMenuBind","onContextMenu","bind","hostWindow","getHostWindow","handler","detachControl","inputElement","removeEventListener","getClassName","getSimpleName","point","ArcRotateCameraKeyboardMoveInput","keysUp","keysDown","keysLeft","keysRight","keysReset","zoomingSensibility","useAltToZoom","angularSpeed","_onCanvasBlurObserver","_scene","_engine","onCanvasBlurObservable","_onKeyboardObserver","onKeyboardObservable","info","_ctrlPressed","_altPressed","keyCode","checkInputs","_useCtrlForPanning","restoreState","ArcRotateCameraMouseWheelInput","zoomToMouseLocation","wheelDeltaPercentage","customComputeDeltaFromMouseWheel","_inertialPanning","_computeDeltaFromMouseWheelLegacyEvent","mouseWheelDelta","delta","wheelDelta","_wheel","platformScale","deltaMode","deltaY","estimatedTargetRadius","targetInertia","inertia","_hitPlane","_zoomToMouse","setAll","_updateHitPlane","scaleInPlace","_zeroIfClose","direction","_getPosition","ray","createPickingRay","pointerX","pointerY","intersectsPlane","origin","inertiaComp","lowerLimit","upperLimit","ratio","vec","directionToZoomLocation","ArcRotateCameraPointersInput","angularSensibilityX","angularSensibilityY","pinchPrecision","pinchDeltaPercentage","useNaturalPinchZoom","pinchZoom","multiTouchPanning","multiTouchPanAndZoom","pinchInwards","_isPanClick","_twoFingerActivityCount","_isPinching","_computeMultiTouchPanning","moveDeltaX","moveDeltaY","_computePinchZoom","MinimumRadiusForPinch","pointA","pointB","pinchToPanMaxDistance","_panningMouseButton","ArcRotateCamera","setActiveOnSceneIfNoneActive","lowerAlphaLimit","upperAlphaLimit","lowerBetaLimit","upperBetaLimit","panningDistanceLimit","panningOriginTarget","panningInertia","zoomOnFactor","targetScreenOffset","allowUpsideDown","_viewMatrix","panningAxis","_transformedDirection","mapPanning","checkCollisions","collisionRadius","_previousPosition","_collisionVelocity","_newPosition","_computationVector","_onCollisionPositionChange","collisionId","newPosition","collidedMesh","setPosition","onCollide","copyFrom","_position","cosa","cos","sina","cosb","sinb","_getTargetPosition","copyFromFloats","addToRef","up","upVector","negate","_computeViewMatrix","addAtIndex","_collisionTriggered","_target","setTarget","getViewMatrix","inputs","addKeyboard","addMouseWheel","addPointers","targetHost","_targetHost","getTarget","_upToYMatrix","_yToUpMatrix","_upVector","setMatUp","pointers","attached","keyboard","mousewheel","bouncingBehavior","_bouncingBehavior","useBouncingBehavior","addBehavior","removeBehavior","framingBehavior","_framingBehavior","useFramingBehavior","autoRotationBehavior","_autoRotationBehavior","useAutoRotationBehavior","_initCache","_cache","_updateCache","ignoreParentClass","getAbsolutePosition","pos","_targetBoundingCenter","_getLockedTargetPosition","_storedAlpha","_storedBeta","_storedRadius","_storedTarget","_storedTargetScreenOffset","_restoreStateValues","_isSynchronizedViewMatrix","ignored","useCtrlForPanning","panningMouseButton","args","attachElement","_reset","detachElement","_checkInputs","directionModifier","invertRotation","useRightHandedSystem","parent","_getWorldMatrixDeterminant","localDirection","invertToRef","_cameraTransformMatrix","multiplyInPlace","_checkLimits","rebuildAnglesAndRadius","previousAlpha","acos","alphaCorrectionTurns","round","toBoundingCenter","allowSamePosition","cloneAlphaBetaRadius","overrideCloneAlphaBetaRadius","newTarget","currentTarget","_getViewMatrix","collisionsEnabled","coordinator","collisionCoordinator","_collider","createCollider","_radius","getNewPosition","_currentTarget","zoomOn","doNotUpdateMaxZ","minMaxVector","focusOn","meshesOrMinMaxVectorAndDistance","meshesOrMinMaxVector","maxZ","createRigCamera","cameraIndex","alphaShift","cameraRigMode","_cameraRigParams","stereoHalfAngle","rigCam","isRigCamera","rigParent","orthoLeft","orthoRight","orthoBottom","orthoTop","_updateRigCameras","camLeft","_rigCameras","camRight","dispose","clear","ArcRotateCameraInputsManager","CameraInputTypes","CameraInputsManager","attachedToElement","input","_addCheckInputs","inputToRemove","cam","rebuildInputCheck","removeByType","inputType","fn","current","attachInput","disconnect","serializedCamera","res","inputsmgr","parsedCamera","parsedInputs","construct","parsedinput","TargetCamera","_tmpUpVector","_tmpTargetVector","cameraDirection","cameraRotation","ignoreParentScaling","updateUpVectorFromRotation","_tmpQuaternion","rotation","noRotationConstraint","inverseRotationSpeed","lockedTarget","_initialFocalDistance","_camMatrix","_cameraRotationMatrix","_referencePoint","_transformedReferencePoint","_defaultUp","_cachedRotationZ","_cachedQuaternionRotationZ","getFrontPosition","getWorldMatrix","globalPosition","absolutePosition","_storedPosition","_storedRotation","rotationQuaternion","_storedRotationQuaternion","lockedTargetPosition","_computeLocalCameraSpeed","getDeltaTime","getFps","invert","atan","m","vDir","_decideIfNeedsToMove","_updatePosition","directionMultiplier","needToMove","needToRotate","toEulerAnglesToRef","limit","lengthSquared","_updateCameraRotationMatrix","toRotationMatrix","_rotateUpVectorWithCameraRotationMatrix","parentWorldMatrix","_globalPosition","_markSyncedWithParent","getTranslationToRef","rigCamera","leftSign","rightSign","_getRigCamPositionAndTarget","halfSpace","_TargetFocalPoint","newFocalTarget","_TargetTransformMatrix","_RigCamTransformMatrix","Light","diffuse","specular","falloffType","FALLOFF_DEFAULT","intensity","_range","_inverseSquaredRange","_photometricScale","_intensityMode","INTENSITYMODE_AUTOMATIC","renderPriority","_shadowEnabled","_excludeWithLayerMask","_includeOnlyWithLayerMask","_lightmapMode","_excludedMeshesIds","_includedOnlyMeshesIds","_isLight","addLight","_uniformBuffer","_buildUniformLayout","includedOnlyMeshes","excludedMeshes","_resyncMeshes","intensityMode","_computePhotometricScale","shadowEnabled","_markMeshesAsLightDirty","_includedOnlyMeshes","_hookArrayForIncludedOnly","_excludedMeshes","_hookArrayForExcluded","excludeWithLayerMask","includeOnlyWithLayerMask","lightmapMode","transferTexturesToEffect","effect","lightIndex","_bindLight","useSpecular","receiveShadows","iAsString","needUpdate","bindToEffect","_renderId","getRenderId","_lastUseSpecular","useUbo","scaledIntensity","getScaledIntensity","transferToEffect","scaleToRef","updateColor4","shadowsEnabled","shadowGenerator","getShadowGenerator","bindShadowLight","update","bindUniformBuffer","getTypeID","_syncParentEnabledState","isDisposed","setEnabled","_shadowGenerator","canAffectMesh","layerMask","doNotRecurse","disposeMaterialAndTextures","stopAnimation","_parentContainer","lights","_removeLightSource","removeLight","newParent","GetConstructorFromName","clonedLight","isEnabled","onClonedObservable","_serializeAsParent","excludedMeshesIds","forEach","id","includedOnlyMeshesIds","serializeAnimationRanges","parsedLight","light","parentId","_waitingParentId","parentInstanceIndex","_waitingParentInstanceIndex","animationIndex","internalClass","autoAnimate","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","array","oldPush","items","apply","item","_resyncLightSource","oldSplice","deleteCount","deleted","lightSources","_markSubMeshesAsLightDirty","_getPhotometricScale","resetCachedMaterial","photometricScale","lightTypeID","photometricMode","LIGHTTYPEID_DIRECTIONALLIGHT","INTENSITYMODE_ILLUMINANCE","INTENSITYMODE_LUMINOUSINTENSITY","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_SPOTLIGHT","INTENSITYMODE_LUMINOUSPOWER","INTENSITYMODE_LUMINANCE","apexAngleRadians","LIGHTTYPEID_HEMISPHERICLIGHT","_reorderLightsInScene","_renderPriority","requireLightSorting","sortLightsByPriority","FALLOFF_PHYSICAL","FALLOFF_GLTF","FALLOFF_STANDARD","LIGHTMAP_DEFAULT","LIGHTMAP_SPECULAR","LIGHTMAP_SHADOWSONLY"],"sourceRoot":""}