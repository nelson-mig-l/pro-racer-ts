{"version":3,"file":"js/719.babylonBundle.js","mappings":"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","sources":["webpack://pro-racer/./src/externals/ammo.ts","webpack://pro-racer/./src/scenes/boxes.ts","webpack://pro-racer/./src/scenes/car.ts","webpack://pro-racer/./src/scenes/controls.ts","webpack://pro-racer/./src/scenes/proRacer.ts","webpack://pro-racer/../lts/materials/generated/grid/gridMaterial.ts","webpack://pro-racer/../lts/materials/generated/grid/grid.fragment.ts"],"sourcesContent":["import * as Ammo from \"ammo.js\";\n\nexport let ammoModule: any;\nexport const ammoReadyPromise = new Promise((resolve) => {\n    new Ammo().then((res: unknown) => {\n        ammoModule = res;\n        resolve(res);\n    });\n});\n","import { Material } from \"@babylonjs/core/Materials/material\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\nimport { Color3, Vector3 } from \"@babylonjs/core/Maths/math\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { MeshBuilder } from \"@babylonjs/core/Meshes/meshBuilder\";\nimport { PhysicsImpostor } from \"@babylonjs/core/Physics/physicsImpostor\";\nimport { Scene } from \"@babylonjs/core/scene\";\n\nexport class Boxes {\n    redMaterial: StandardMaterial;\n    blueMaterial: StandardMaterial;\n    scene: Scene;\n\n    constructor(scene: Scene) {\n        this.scene = scene;\n\n        this.redMaterial = new StandardMaterial(\"RedMaterial\", scene);\n        this.redMaterial.diffuseColor = new Color3(0.8,0.4,0.5);\n        this.redMaterial.emissiveColor = new Color3(0.8,0.4,0.5);\n\n        this.blueMaterial = new StandardMaterial(\"BlueMaterial\", scene);\n        this.blueMaterial.diffuseColor = new Color3(0.5,0.4,0.8);\n        this.blueMaterial.emissiveColor = new Color3(0.5,0.4,0.8);  \n    }\n\n    public baseBoxes() : void {\n        this.createBox(new Vector3(4,1,12),new Vector3(0,0,25),new Vector3(-Math.PI/8,0,0),0);\n        this.createBox(new Vector3(4,1,12),new Vector3(25,0,0),new Vector3(-Math.PI/8,Math.PI/2,0),0);\n        this.createBox(new Vector3(4,1,12),new Vector3(0,0,-25),new Vector3(Math.PI/8,0,0),0);\n        this.createBox(new Vector3(4,1,12),new Vector3(-25,0,0),new Vector3(Math.PI/8,Math.PI/2,0),0);\n    }\n\n    public randomBoxes() : void {\n        const s = new Vector3();\n        const p = new Vector3();\n        const r = new Vector3();\n        for(let i=0;i<20;i++){\n            const m = Math.random()*300-150+5;\n            const m3 = Math.random()*300-150+5;\n            const m2 = Math.random()*10;\n            s.set(m2,m2,m2);\n            p.set(m3,0,m);\n            r.set(m,m,m);\n            this.createBox(s,p,r,0);\n        }\n    \n        for(let i=0;i<30;i++){\n            const m = Math.random()*300-150+5;\n            const m3 = Math.random()*300-150+5;\n            const m2 = Math.random()*3;\n            s.set(m2,m2,m2);\n            p.set(m3,0,m);\n            r.set(m,m,m);\n            this.createBox(s,p,r,5);\n        }\n    }\n\n    private createBox(size: Vector3, position: Vector3, rotation: Vector3, mass: number) : Mesh {\n        const box = MeshBuilder.CreateBox(\"box\", { width: size.x, depth: size.z, height: size.y }, this.scene);\n        box.position.set(position.x,position.y,position.z);\n        box.rotation.set(rotation.x,rotation.y,rotation.z);\n        if(!mass){\n            mass = 0;\n            box.material = this.redMaterial;\n        } else {\n            box.position.y += 5;\n            box.material = this.blueMaterial;\n    \n        }\n        box.physicsImpostor = new PhysicsImpostor(box, PhysicsImpostor.BoxImpostor, { mass: mass, friction: 0.5, restitution: 0.7 }, this.scene);\n        return box;\n    }\n}\n\n","import { Mesh, StandardMaterial } from \"@babylonjs/core\";\nimport { FollowCamera } from \"@babylonjs/core/Cameras/followCamera\";\nimport { Color3, Quaternion, Vector3 } from \"@babylonjs/core/Maths/math\";\nimport { MeshBuilder } from \"@babylonjs/core/Meshes/meshBuilder\";\nimport { Scene } from \"@babylonjs/core/scene\";\n\nexport class Car {\n    ZERO_QUATERNION = new Quaternion(); \n\n    FRONT_LEFT = 0;\n    FRONT_RIGHT = 1;\n    BACK_LEFT = 2;\n    BACK_RIGHT = 3;\n\n    chassisWidth = 1.8;\n    chassisHeight = .6;\n    chassisLength = 4;\n    massVehicle = 200;\n\n\n    wheelAxisPositionBack = -1;\n    wheelRadiusBack = .4;\n    wheelWidthBack = .3;\n    wheelHalfTrackBack = 1;\n    wheelAxisHeightBack = 0.4;\n    \n    wheelAxisFrontPosition = 1.0;\n    wheelHalfTrackFront = 1;\n    wheelAxisHeightFront = 0.4;\n    wheelRadiusFront = .4;\n    wheelWidthFront = .3;\n\n    friction = 5;\n    suspensionStiffness = 10;\n    suspensionDamping = 0.3;\n    suspensionCompression = 4.4;\n    suspensionRestLength = 0.6;\n    rollInfluence = 0.0;\n\n    wheelDirectionCS0: number | undefined;\n    wheelAxleCS: number | undefined;\n\n    steeringIncrement = .01;\n    steeringClamp = 0.2;\n    maxEngineForce = 500;\n    maxBreakingForce = 10;\n    incEngine = 10.0;\n\n    vehicleSteering = 0;\n    engineForce = 0;  \n    breakingForce = 0;\n\n    private scene : Scene;\n\n    greenMaterial: StandardMaterial;\n    blackMaterial: StandardMaterial;\n\n    \n    tuning: any;\n    vehicle: any;\n    wheelMeshes: Mesh[] = [];\n    chassisMesh: Mesh;\n\n\n    vehicleReady = false;\n\n    constructor(pos: Vector3, scene: Scene, ammoModule: any) {\n        this.greenMaterial = new StandardMaterial(\"GreenMaterial\", scene);\n        this.greenMaterial.diffuseColor = new Color3(0.5,0.8,0.5);\n        this.greenMaterial.emissiveColor = new Color3(0.5,0.8,0.5);\n    \n        this.blackMaterial = new StandardMaterial(\"BlackMaterial\", scene);\n        this.blackMaterial.diffuseColor = new Color3(0.1,0.1,0.1);\n        this.blackMaterial.emissiveColor = new Color3(0.1,0.1,0.1);\n\n        this.scene = scene;\n        //Going Native\n        const physicsWorld = scene.getPhysicsEngine()?.getPhysicsPlugin().world;\n\n        this.wheelDirectionCS0 = new ammoModule.btVector3(0, -1, 0);\n        this.wheelAxleCS = new ammoModule.btVector3(-1, 0, 0);\n\n        const geometry = new ammoModule.btBoxShape(new ammoModule.btVector3(\n            this.chassisWidth * .5, \n            this.chassisHeight * .5, \n            this.chassisLength * .5));\n        const transform = new ammoModule.btTransform();\n        transform.setIdentity();\n        transform.setOrigin(new ammoModule.btVector3(0,5,0));\n        transform.setRotation(new ammoModule.btQuaternion(\n            this.ZERO_QUATERNION.x, \n            this.ZERO_QUATERNION.y, \n            this.ZERO_QUATERNION.z, \n            this.ZERO_QUATERNION.w));\n        const motionState = new ammoModule.btDefaultMotionState(transform);\n        const localInertia = new ammoModule.btVector3(0, 0, 0);\n        geometry.calculateLocalInertia(this.massVehicle, localInertia);\n\n\n        this.chassisMesh = this.createChassisMesh(this.chassisWidth, this.chassisHeight, this.chassisLength);\n\n\n        const massOffset = new ammoModule.btVector3( 0, 0.4, 0);\n        const transform2 = new ammoModule.btTransform();\n        transform2.setIdentity();\n        transform2.setOrigin(massOffset);\n        const compound = new ammoModule.btCompoundShape();\n        compound.addChildShape( transform2, geometry );\n\n        const body = new ammoModule.btRigidBody(new ammoModule.btRigidBodyConstructionInfo(this.massVehicle, motionState, compound, localInertia));\n        body.setActivationState(4);\n\t\t\n        physicsWorld.addRigidBody(body);\n\n\n        this.tuning = new ammoModule.btVehicleTuning();\n        const rayCaster = new ammoModule.btDefaultVehicleRaycaster(physicsWorld);\n        this.vehicle = new ammoModule.btRaycastVehicle(this.tuning, body, rayCaster);\n        this.vehicle.setCoordinateSystem(0, 1, 2);\n        physicsWorld.addAction(this.vehicle);\n\t\t\n        const trans = this.vehicle.getChassisWorldTransform();\n\n        this.addWheel(true, \n            new ammoModule.btVector3(this.wheelHalfTrackFront, this.wheelAxisHeightFront, this.wheelAxisFrontPosition), \n            this.wheelRadiusFront, this.wheelWidthFront, this.FRONT_LEFT);\n        this.addWheel(true, \n            new ammoModule.btVector3(-this.wheelHalfTrackFront, this.wheelAxisHeightFront, this.wheelAxisFrontPosition), \n            this.wheelRadiusFront, this.wheelWidthFront, this.FRONT_RIGHT);\n        this.addWheel(false, \n            new ammoModule.btVector3(-this.wheelHalfTrackBack, this.wheelAxisHeightBack, this.wheelAxisPositionBack), \n            this.wheelRadiusBack, this.wheelWidthBack, this.BACK_LEFT);\n        this.addWheel(false, \n            new ammoModule.btVector3(this.wheelHalfTrackBack, this.wheelAxisHeightBack, this.wheelAxisPositionBack), \n            this.wheelRadiusBack, this.wheelWidthBack, this.BACK_RIGHT);\n    \n        this.vehicleReady = true;\n    }\n\n    private createChassisMesh(w: number, l: number, h: number) : Mesh {\n        const mesh = MeshBuilder.CreateBox(\"box\", {width:w, depth:h, height:l}, this.scene);\n        mesh.rotationQuaternion = new Quaternion();\n        mesh.material = this.greenMaterial;\n    \n        const camera = new FollowCamera(\"FollowCam\", new Vector3(0, 10, -10), this.scene);\n        camera.radius = 10;\n        camera.heightOffset = 4;\n        camera.rotationOffset = 0;\n        camera.cameraAcceleration = 0.05;\n        camera.maxCameraSpeed = 400;\n        camera.attachControl(true);//camera.attachControl(canvas, true);\n        camera.lockedTarget = mesh; //version 2.5 onwards\n        this.scene.activeCamera = camera;\n    \n        return mesh;\n    }\n\n    private addWheel(isFront: boolean, pos: Vector3, radius: number, width: number, index: number) {\n\t\t\t\n        const wheelInfo = this.vehicle.addWheel(\n            pos,\n            this.wheelDirectionCS0,\n            this.wheelAxleCS,\n            this.suspensionRestLength,\n            radius,\n            this.tuning,\n            isFront);\n\n        wheelInfo.set_m_suspensionStiffness(this.suspensionStiffness);\n        wheelInfo.set_m_wheelsDampingRelaxation(this.suspensionDamping);\n        wheelInfo.set_m_wheelsDampingCompression(this.suspensionCompression);\n        wheelInfo.set_m_maxSuspensionForce(600000);\n        wheelInfo.set_m_frictionSlip(40);\n        wheelInfo.set_m_rollInfluence(this.rollInfluence);\n\n        this.wheelMeshes[index] = this.createWheelMesh(radius, width);\n    }\n\n    private createWheelMesh(radius: number, width: number) {\n        //var mesh = new BABYLON.MeshBuilder.CreateBox(\"wheel\", {width:.82, height:.82, depth:.82}, scene);\n        const mesh = MeshBuilder.CreateCylinder(\"Wheel\", {diameter:1, height:0.5, tessellation: 6}, this.scene);\n        mesh.rotationQuaternion = new Quaternion();\n        mesh.material = this.blackMaterial;\n        return mesh;\n    }\n}","import { Axis } from \"@babylonjs/core/Maths/math\";\nimport { Car } from \"./car\";\n\nconst actions = new Map<string, boolean>([\n    [\"acceleration\", false],\n    [\"braking\", false],\n    [\"right\", false],\n    [\"left\", false]\n]);\n\n// const keysActions = {\n//     \"KeyW\":'acceleration',\n//     \"KeyS\":'braking',\n//     \"KeyA\":'left',\n//     \"KeyD\":'right'\n// };\nconst keysActions = new Map<string, string>([\n    [\"KeyW\",'acceleration'],\n    [\"KeyS\",'braking'],\n    [\"KeyA\",'left'],\n    [\"KeyD\",'right']\n]);\n\nexport class Controls {\n\n    car: Car;\n\n    constructor(car: Car) {\n        this.car = car;\n        window.addEventListener( 'keydown', this.keydown);\n        window.addEventListener( 'keyup', this.keyup);\n    }\n\n    update() {\n        if(this.car.vehicleReady){\n                  \n            const speed = this.car.vehicle.getCurrentSpeedKmHour();\n            const maxSteerVal = 0.2;\n            this.car.breakingForce = 0;\n            this.car.engineForce = 0;\n\n            \n            if(actions.get(\"acceleration\")){\n                if (speed < -1){\n                    this.car.breakingForce = this.car.maxBreakingForce;\n                }else {\n                    this.car.engineForce = this.car.maxEngineForce;\n                }\n                    \n            } else if(actions.get(\"braking\")){\n                if (speed > 1){\n                    this.car.breakingForce = this.car.maxBreakingForce;\n                }else {\n                    this.car.engineForce = -this.car.maxEngineForce ;\n                }\n            } \n                    \n            if(actions.get(\"right\")){\n                if (this.car.vehicleSteering < this.car.steeringClamp){\n                    this.car.vehicleSteering += this.car.steeringIncrement;\n                }\n                    \n            } else if(actions.get(\"left\")){\n                if (this.car.vehicleSteering > -this.car.steeringClamp){\n                    this.car.vehicleSteering -= this.car.steeringIncrement;\n                }\n                    \n            } else {\n                this.car.vehicleSteering = 0;\n            }\n                    \n            this.car.vehicle.applyEngineForce(this.car.engineForce, this.car.FRONT_LEFT);\n            this.car.vehicle.applyEngineForce(this.car.engineForce, this.car.FRONT_RIGHT);\n                    \n            this.car.vehicle.setBrake(this.car.breakingForce / 2, this.car.FRONT_LEFT);\n            this.car.vehicle.setBrake(this.car.breakingForce / 2, this.car.FRONT_RIGHT);\n            this.car.vehicle.setBrake(this.car.breakingForce, this.car.BACK_LEFT);\n            this.car.vehicle.setBrake(this.car.breakingForce, this.car.BACK_RIGHT);\n                    \n            this.car.vehicle.setSteeringValue(this.car.vehicleSteering, this.car.FRONT_LEFT);\n            this.car.vehicle.setSteeringValue(this.car.vehicleSteering, this.car.FRONT_RIGHT);\n                    \n                    \n            let tm, p, q, i;\n            const n = this.car.vehicle.getNumWheels();\n            for (i = 0; i < n; i++) {\n                this.car.vehicle.updateWheelTransform(i, true);\n                tm = this.car.vehicle.getWheelTransformWS(i);\n                p = tm.getOrigin();\n                q = tm.getRotation();\n                this.car.wheelMeshes[i].position.set(p.x(), p.y(), p.z());\n                this.car.wheelMeshes[i].rotationQuaternion?.set(q.x(), q.y(), q.z(), q.w());\n                this.car.wheelMeshes[i].rotate(Axis.Z, Math.PI/2);\n            }\n\n            tm = this.car.vehicle.getChassisWorldTransform();\n            p = tm.getOrigin();\n            q = tm.getRotation();\n            this.car.chassisMesh.position.set(p.x(), p.y(), p.z());\n            this.car.chassisMesh.rotationQuaternion?.set(q.x(), q.y(), q.z(), q.w());\n            this.car.chassisMesh.rotate(Axis.X, Math.PI);\n                 \n        }\n    }\n\n    private keyup(e: KeyboardEvent) {\n        if(keysActions.get(e.code)) {\n            actions.set(keysActions.get(e.code)??\"\", false);\n            //e.preventDefault();\n            //e.stopPropagation();\n\n            //return false;\n        }\n    }\n\n    private keydown(e: KeyboardEvent) {\n        if(keysActions.get(e.code)) {\n            actions.set(keysActions.get(e.code)??\"\", true);\n            //e.preventDefault();\n            //e.stopPropagation();\n\n            //return false;\n        }\n    }\n\n\n}\n","import { Engine } from \"@babylonjs/core/Engines/engine\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\nimport { SphereBuilder } from \"@babylonjs/core/Meshes/Builders/sphereBuilder\";\nimport { AmmoJSPlugin } from \"@babylonjs/core/Physics/Plugins/ammoJSPlugin\";\nimport \"@babylonjs/core/Physics/physicsEngineComponent\";\n\n// If you don't need the standard material you will still need to import it since the scene requires it.\nimport \"@babylonjs/core/Materials/standardMaterial\";\nimport { PhysicsImpostor } from \"@babylonjs/core/Physics/physicsImpostor\";\nimport { ammoModule, ammoReadyPromise } from \"../externals/ammo\";\nimport { CreateSceneClass } from \"../createScene\";\nimport { MeshBuilder } from \"@babylonjs/core/Meshes/meshBuilder\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\nimport { Axis, Color3 } from \"@babylonjs/core/Maths/math\";\nimport * as GRID from \"@babylonjs/materials/grid\";\n\nimport {Boxes} from \"./boxes\"\nimport {Car} from \"./car\";\nimport { Controls } from \"./controls\";\n\nclass ProRacerScene implements CreateSceneClass {\n    preTasks = [ammoReadyPromise];\n\n    createScene = async (engine: Engine, canvas: HTMLCanvasElement): Promise<Scene> => {\n        // This creates a basic Babylon Scene object (non-mesh)\n        const scene = new Scene(engine);\n        const camera = new FreeCamera(\"camera1\", new Vector3(0, 5, -10), scene);\n        // This targets the camera to scene origin\n        camera.setTarget(Vector3.Zero());\n        // This attaches the camera to the canvas\n        camera.attachControl(canvas, true);\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n        const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\n        // Default intensity is 1. Let's dim the light a small amount\n        light.intensity = 0.7;\n\n        // Materials\n        const redMaterial = new StandardMaterial(\"RedMaterial\", scene);\n        redMaterial.diffuseColor = new Color3(0.8,0.4,0.5);\n        redMaterial.emissiveColor = new Color3(0.8,0.4,0.5);\n\n        scene.enablePhysics(new Vector3(0,-10,0), new AmmoJSPlugin(true, ammoModule));\n\n        /* Testing physics\n        const zero = new ammoModule.btVector3(0, 0, 0);\n        console.log(zero);\n        const tm = new ammoModule.btTriangleMesh();\n        console.log(\"TriangleMesh\");\n        console.log(tm);\n        console.log(\"----\");\n        //const meshShape = ammoModule.btBvhTriangleMeshShape(tm, true, true);\n        console.log(\"====\");\n        //console.log(meshShape.name);\n        */\n\n        // Our built-in 'ground' shape.\n        \n        const ground = MeshBuilder.CreateGround(\"ground\", { \n            width: 460, \n            height: 460, \n            subdivisions: 2 \n        }, scene);\n        ground.physicsImpostor = new PhysicsImpostor(ground, PhysicsImpostor.BoxImpostor, { \n            mass: 0, \n            friction: 0.5, \n            restitution: 0.7\n        }, scene);\n\n        ground.material = new GRID.GridMaterial(\"groundMaterial\", scene);\n        \n        const boxes = new Boxes(scene)\n        boxes.baseBoxes();\n        boxes.randomBoxes();\n\n        ////const actions = {acceleration:false,braking:false,right:false,left:false};\n        // const actions = new Map<string, boolean>([\n        //     [\"acceleration\", false],\n        //     [\"braking\", false],\n        //     [\"right\", false],\n        //     [\"left\", false]\n        // ]);\n        \n        // // const keysActions = {\n        // //     \"KeyW\":'acceleration',\n        // //     \"KeyS\":'braking',\n        // //     \"KeyA\":'left',\n        // //     \"KeyD\":'right'\n        // // };\n        // const keysActions = new Map<string, string>([\n        //     [\"KeyW\",'acceleration'],\n        //     [\"KeyS\",'braking'],\n        //     [\"KeyA\",'left'],\n        //     [\"KeyD\",'right']\n        // ]);\n\n        // function keyup(e: KeyboardEvent) {\n        //     if(keysActions.get(e.code)) {\n        //         actions.set(keysActions.get(e.code)??\"\", false);\n        //         //e.preventDefault();\n        //         //e.stopPropagation();\n        \n        //         //return false;\n        //     }\n        // }\n        \n        // function keydown(e: KeyboardEvent) {\n        //     if(keysActions.get(e.code)) {\n        //         actions.set(keysActions.get(e.code)??\"\", true);\n        //         //e.preventDefault();\n        //         //e.stopPropagation();\n        \n        //         //return false;\n        //     }\n        // }\n\n        const car = new Car(new Vector3(0, 4, -20), scene, ammoModule);\n        const controls = new Controls(car);\n\n        scene.registerBeforeRender(function() {\n            const dt = engine.getDeltaTime()/*.toFixed()*//1000;\n            controls.update();\n            // if(car.vehicleReady){                  \n            //     const speed = car.vehicle.getCurrentSpeedKmHour();\n            //     const maxSteerVal = 0.2;\n            //     car.breakingForce = 0;\n            //     car.engineForce = 0;\n    \n                \n            //     if(actions.get(\"acceleration\")){\n            //         if (speed < -1){\n            //             car.breakingForce = car.maxBreakingForce;\n            //         }else {\n            //             car.engineForce = car.maxEngineForce;\n            //         }\n                        \n            //     } else if(actions.get(\"braking\")){\n            //         if (speed > 1){\n            //             car.breakingForce = car.maxBreakingForce;\n            //         }else {\n            //             car.engineForce = -car.maxEngineForce ;\n            //         }\n            //     } \n                        \n            //     if(actions.get(\"right\")){\n            //         if (car.vehicleSteering < car.steeringClamp){\n            //             car.vehicleSteering += car.steeringIncrement;\n            //         }\n                        \n            //     } else if(actions.get(\"left\")){\n            //         if (car.vehicleSteering > -car.steeringClamp){\n            //             car.vehicleSteering -= car.steeringIncrement;\n            //         }\n                        \n            //     } else {\n            //         car.vehicleSteering = 0;\n            //     }\n                        \n            //     car.vehicle.applyEngineForce(car.engineForce, car.FRONT_LEFT);\n            //     car.vehicle.applyEngineForce(car.engineForce, car.FRONT_RIGHT);\n                        \n            //     car.vehicle.setBrake(car.breakingForce / 2, car.FRONT_LEFT);\n            //     car.vehicle.setBrake(car.breakingForce / 2, car.FRONT_RIGHT);\n            //     car.vehicle.setBrake(car.breakingForce, car.BACK_LEFT);\n            //     car.vehicle.setBrake(car.breakingForce, car.BACK_RIGHT);\n                        \n            //     car.vehicle.setSteeringValue(car.vehicleSteering, car.FRONT_LEFT);\n            //     car.vehicle.setSteeringValue(car.vehicleSteering, car.FRONT_RIGHT);\n                        \n                        \n            //     let tm, p, q, i;\n            //     const n = car.vehicle.getNumWheels();\n            //     for (i = 0; i < n; i++) {\n            //         car.vehicle.updateWheelTransform(i, true);\n            //         tm = car.vehicle.getWheelTransformWS(i);\n            //         p = tm.getOrigin();\n            //         q = tm.getRotation();\n            //         car.wheelMeshes[i].position.set(p.x(), p.y(), p.z());\n            //         car.wheelMeshes[i].rotationQuaternion?.set(q.x(), q.y(), q.z(), q.w());\n            //         car.wheelMeshes[i].rotate(Axis.Z, Math.PI/2);\n            //     }\n    \n            //     tm = car.vehicle.getChassisWorldTransform();\n            //     p = tm.getOrigin();\n            //     q = tm.getRotation();\n            //     car.chassisMesh.position.set(p.x(), p.y(), p.z());\n            //     car.chassisMesh.rotationQuaternion?.set(q.x(), q.y(), q.z(), q.w());\n            //     car.chassisMesh.rotate(Axis.X, Math.PI);\n                     \n            // }\n        });\n    \n        return scene;\n    };\n\n}\n\nexport default new ProRacerScene();\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper, serializeAsVector3 } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector4, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./grid.fragment\";\r\nimport \"./grid.vertex\";\r\n\r\nclass GridMaterialDefines extends MaterialDefines {\r\n    public OPACITY = false;\r\n    public TRANSPARENT = false;\r\n    public FOG = false;\r\n    public PREMULTIPLYALPHA = false;\r\n    public MAX_LINE = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * The grid materials allows you to wrap any shape with a grid.\r\n * Colors are customizable.\r\n */\r\nexport class GridMaterial extends PushMaterial {\r\n    /**\r\n     * Main color of the grid (e.g. between lines)\r\n     */\r\n    @serializeAsColor3()\r\n    public mainColor = Color3.Black();\r\n\r\n    /**\r\n     * Color of the grid lines.\r\n     */\r\n    @serializeAsColor3()\r\n    public lineColor = Color3.Teal();\r\n\r\n    /**\r\n     * The scale of the grid compared to unit.\r\n     */\r\n    @serialize()\r\n    public gridRatio = 1.0;\r\n\r\n    /**\r\n     * Allows setting an offset for the grid lines.\r\n     */\r\n    @serializeAsVector3()\r\n    public gridOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * The frequency of thicker lines.\r\n     */\r\n    @serialize()\r\n    public majorUnitFrequency = 10;\r\n\r\n    /**\r\n     * The visibility of minor units in the grid.\r\n     */\r\n    @serialize()\r\n    public minorUnitVisibility = 0.33;\r\n\r\n    /**\r\n     * The grid opacity outside of the lines.\r\n     */\r\n    @serialize()\r\n    public opacity = 1.0;\r\n\r\n    /**\r\n     * Determine RBG output is premultiplied by alpha value.\r\n     */\r\n    @serialize()\r\n    public preMultiplyAlpha = false;\r\n\r\n    /**\r\n     * Determines if the max line value will be used instead of the sum wherever grid lines intersect.\r\n     */\r\n    @serialize()\r\n    public useMaxLine = false;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: BaseTexture;\r\n\r\n    private _gridControl: Vector4 = new Vector4(this.gridRatio, this.majorUnitFrequency, this.minorUnitVisibility, this.opacity);\r\n\r\n    /**\r\n     * constructor\r\n     * @param name The name given to the material in order to identify it afterwards.\r\n     * @param scene The scene the material is used in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the grid requires alpha blending.\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.opacity < 1.0 || (this._opacityTexture && this._opacityTexture.isReady());\r\n    }\r\n\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return mesh.visibility < 1.0 || this.needAlphaBlending();\r\n    }\r\n\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GridMaterialDefines();\r\n        }\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        if (defines.TRANSPARENT !== this.opacity < 1.0) {\r\n            defines.TRANSPARENT = !defines.TRANSPARENT;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {\r\n            defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.MAX_LINE !== this.useMaxLine) {\r\n            defines.MAX_LINE = !defines.MAX_LINE;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.OPACITY = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, false, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), defines, !!useInstances);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Attributes\r\n            MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, false);\r\n            const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Defines\r\n            const join = defines.toString();\r\n            subMesh.setEffect(\r\n                scene\r\n                    .getEngine()\r\n                    .createEffect(\r\n                        \"grid\",\r\n                        attribs,\r\n                        [\r\n                            \"projection\",\r\n                            \"mainColor\",\r\n                            \"lineColor\",\r\n                            \"gridControl\",\r\n                            \"gridOffset\",\r\n                            \"vFogInfos\",\r\n                            \"vFogColor\",\r\n                            \"world\",\r\n                            \"view\",\r\n                            \"opacityMatrix\",\r\n                            \"vOpacityInfos\",\r\n                            \"visibility\",\r\n                        ],\r\n                        [\"opacitySampler\"],\r\n                        join,\r\n                        undefined,\r\n                        this.onCompiled,\r\n                        this.onError\r\n                    ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        this._activeEffect.setFloat(\"visibility\", mesh.visibility);\r\n\r\n        // Matrices\r\n        if (!defines.INSTANCES || defines.THIN_INSTANCE) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n        this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        this._activeEffect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n\r\n        // Uniforms\r\n        if (this._mustRebind(scene, effect)) {\r\n            this._activeEffect.setColor3(\"mainColor\", this.mainColor);\r\n            this._activeEffect.setColor3(\"lineColor\", this.lineColor);\r\n\r\n            this._activeEffect.setVector3(\"gridOffset\", this.gridOffset);\r\n\r\n            this._gridControl.x = this.gridRatio;\r\n            this._gridControl.y = Math.round(this.majorUnitFrequency);\r\n            this._gridControl.z = this.minorUnitVisibility;\r\n            this._gridControl.w = this.opacity;\r\n            this._activeEffect.setVector4(\"gridControl\", this._gridControl);\r\n\r\n            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                this._activeEffect.setFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                this._activeEffect.setMatrix(\"opacityMatrix\", this._opacityTexture.getTextureMatrix());\r\n            }\r\n        }\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and its associated resources.\r\n     * @param forceDisposeEffect will also dispose the used effect when true\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): GridMaterial {\r\n        return SerializationHelper.Clone(() => new GridMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GridMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"GridMaterial\";\r\n    }\r\n\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GridMaterial {\r\n        return SerializationHelper.Parse(() => new GridMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GridMaterial\", GridMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"gridPixelShader\";\nconst shader = `#extension GL_OES_standard_derivatives : enable\n#define SQRT2 1.41421356\n#define PI 3.14159\nprecision highp float;\runiform float visibility;\runiform vec3 mainColor;\runiform vec3 lineColor;\runiform vec4 gridControl;\runiform vec3 gridOffset;\rvarying vec3 vPosition;\rvarying vec3 vNormal;\r#include<fogFragmentDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\runiform sampler2D opacitySampler;\runiform vec2 vOpacityInfos;\r#endif\nfloat getDynamicVisibility(float position) {\rfloat majorGridFrequency=gridControl.y;\rif (floor(position+0.5)==floor(position/majorGridFrequency+0.5)*majorGridFrequency)\r{\rreturn 1.0;\r} \rreturn gridControl.z;\r}\rfloat getAnisotropicAttenuation(float differentialLength) {\rconst float maxNumberOfLines=10.0;\rreturn clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);\r}\rfloat isPointOnLine(float position,float differentialLength) {\rfloat fractionPartOfPosition=position-floor(position+0.5); \rfractionPartOfPosition/=differentialLength; \rfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);\rfloat result=0.5+0.5*cos(fractionPartOfPosition*PI); \rreturn result; \r}\rfloat contributionOnAxis(float position) {\rfloat differentialLength=length(vec2(dFdx(position),dFdy(position)));\rdifferentialLength*=SQRT2; \rfloat result=isPointOnLine(position,differentialLength);\rfloat dynamicVisibility=getDynamicVisibility(position);\rresult*=dynamicVisibility;\rfloat anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);\rresult*=anisotropicAttenuation;\rreturn result;\r}\rfloat normalImpactOnAxis(float x) {\rfloat normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);\rreturn normalImpact;\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfloat gridRatio=gridControl.x;\rvec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;\rfloat x=contributionOnAxis(gridPos.x);\rfloat y=contributionOnAxis(gridPos.y);\rfloat z=contributionOnAxis(gridPos.z);\rvec3 normal=normalize(vNormal);\rx*=normalImpactOnAxis(normal.x);\ry*=normalImpactOnAxis(normal.y);\rz*=normalImpactOnAxis(normal.z);\r#ifdef MAX_LINE \nfloat grid=clamp(max(max(x,y),z),0.,1.);\r#else\nfloat grid=clamp(x+y+z,0.,1.);\r#endif\nvec3 color=mix(mainColor,lineColor,grid);\r#ifdef FOG\n#include<fogFragment>\n#endif\nfloat opacity=1.0;\r#ifdef TRANSPARENT\nopacity=clamp(grid,0.08,gridControl.w*grid);\r#endif \n#ifdef OPACITY\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\r#endif \ngl_FragColor=vec4(color.rgb,opacity*visibility);\r#ifdef TRANSPARENT\n#ifdef PREMULTIPLYALPHA\ngl_FragColor.rgb*=opacity;\r#endif\n#else \n#endif\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gridPixelShader = { name, shader };\n"],"names":["ammoModule","ammoReadyPromise","Promise","resolve","then","res","Boxes","constructor","scene","this","redMaterial","diffuseColor","emissiveColor","blueMaterial","baseBoxes","createBox","Math","PI","randomBoxes","s","p","r","i","m","random","m3","m2","set","size","position","rotation","mass","box","width","x","depth","z","height","y","material","physicsImpostor","friction","restitution","Car","pos","ZERO_QUATERNION","FRONT_LEFT","FRONT_RIGHT","BACK_LEFT","BACK_RIGHT","chassisWidth","chassisHeight","chassisLength","massVehicle","wheelAxisPositionBack","wheelRadiusBack","wheelWidthBack","wheelHalfTrackBack","wheelAxisHeightBack","wheelAxisFrontPosition","wheelHalfTrackFront","wheelAxisHeightFront","wheelRadiusFront","wheelWidthFront","suspensionStiffness","suspensionDamping","suspensionCompression","suspensionRestLength","rollInfluence","steeringIncrement","steeringClamp","maxEngineForce","maxBreakingForce","incEngine","vehicleSteering","engineForce","breakingForce","wheelMeshes","vehicleReady","greenMaterial","StandardMaterial","blackMaterial","physicsWorld","getPhysicsEngine","getPhysicsPlugin","world","wheelDirectionCS0","btVector3","wheelAxleCS","geometry","btBoxShape","transform","btTransform","setIdentity","setOrigin","setRotation","btQuaternion","w","motionState","btDefaultMotionState","localInertia","calculateLocalInertia","chassisMesh","createChassisMesh","massOffset","transform2","compound","btCompoundShape","addChildShape","body","btRigidBody","btRigidBodyConstructionInfo","setActivationState","addRigidBody","tuning","btVehicleTuning","rayCaster","btDefaultVehicleRaycaster","vehicle","btRaycastVehicle","setCoordinateSystem","addAction","getChassisWorldTransform","addWheel","l","h","mesh","rotationQuaternion","camera","radius","heightOffset","rotationOffset","cameraAcceleration","maxCameraSpeed","attachControl","lockedTarget","activeCamera","isFront","index","wheelInfo","set_m_suspensionStiffness","set_m_wheelsDampingRelaxation","set_m_wheelsDampingCompression","set_m_maxSuspensionForce","set_m_frictionSlip","set_m_rollInfluence","createWheelMesh","diameter","tessellation","actions","Map","keysActions","Controls","car","window","addEventListener","keydown","keyup","update","speed","getCurrentSpeedKmHour","tm","q","get","applyEngineForce","setBrake","setSteeringValue","n","getNumWheels","updateWheelTransform","getWheelTransformWS","getOrigin","getRotation","rotate","e","code","preTasks","createScene","async","engine","canvas","setTarget","intensity","enablePhysics","ground","subdivisions","boxes","controls","registerBeforeRender","getDeltaTime"],"sourceRoot":""}