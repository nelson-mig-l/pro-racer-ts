{"version":3,"file":"js/345.babylonBundle.js","mappings":"2IAEO,IAAIA,EACJ,MAAMC,EAAmB,IAAIC,SAASC,KACzC,IAAI,GAAOC,MAAMC,IACbL,EAAaK,EACbF,EAAQE,EAAI,GACd,G,yKCoEN,YA3DA,oBACI,KAAAC,SAAW,CAAC,KAEZ,KAAAC,YAAcC,MAAOC,EAAgBC,KAEjC,MAAMC,EAAQ,IAAI,IAAMF,GAExBE,EAAMC,cAAc,KAAM,IAAI,KAAa,EAAM,MACjD,MAAMC,EAAO,IAAI,cAAqB,EAAG,EAAG,GAE5CC,QAAQC,IAAIF,GACZ,MAAMG,EAAK,IAAI,mBACfF,QAAQC,IAAI,gBACZD,QAAQC,IAAIC,GACZF,QAAQC,IAAI,QAEZD,QAAQC,IAAI,QAIZ,MAAME,EAAS,IAAI,IAAgB,kBAAmB,EAAGC,KAAKC,GAAK,EAAG,GAAI,IAAI,IAAQ,EAAG,EAAG,GAAIR,GAGhGM,EAAOG,UAAU,YAGjBH,EAAOI,cAAcX,GAAQ,GAGf,IAAI,IAAiB,QAAS,IAAI,IAAQ,EAAG,EAAG,GAAIC,GAG5DW,UAAY,GAGlB,MAAMC,EAAS,kBACX,SACA,CAAEC,SAAU,EAAGC,SAAU,IACzBd,GAGJY,EAAOG,gBAAkB,IAAI,IAAgBH,EAAQ,mBAAgC,CAAEI,KAAM,EAAGC,YAAa,IAAMjB,GAGnHY,EAAOM,SAASC,EAAI,EAGpB,MAAMC,EAAS,kBACX,SACA,CAAEC,MAAO,EAAGC,OAAQ,GACpBtB,GAKJ,OAFAoB,EAAOL,gBAAkB,IAAI,IAAgBK,EAAQ,gBAA6B,CAAEJ,KAAM,EAAGC,YAAa,KAEnGjB,CAAK,CAEpB,E,qIC/DA,EAAAuB,EAAA,mBAAwB,gBAAgB,CAACC,EAAMxB,IACpC,IAAM,IAAIyB,EAAiBD,EAAM,WAAgBxB,KAOrD,MAAMyB,UAAyB,IAuBlCC,YAAYF,EAAcG,EAAoB3B,GAC1C4B,MAAMJ,EAAMxB,GAlBT,KAAA6B,YAAc,IAAI,KAAO,EAAK,EAAK,GAmBtCC,KAAKH,UAAYA,GAAa,QAClC,CAEUI,sBACND,KAAKE,eAAeC,WAAW,aAAc,GAC7CH,KAAKE,eAAeC,WAAW,gBAAiB,GAChDH,KAAKE,eAAeC,WAAW,iBAAkB,GACjDH,KAAKE,eAAeC,WAAW,eAAgB,GAC/CH,KAAKE,eAAeC,WAAW,cAAe,GAC9CH,KAAKE,eAAeC,WAAW,cAAe,GAC9CH,KAAKE,eAAeE,QACxB,CAMOC,eACH,MAAO,kBACX,CAQOC,qBAAqBC,GAExB,OADAP,KAAKH,UAAY,cAAkBU,EAAOC,SAAS,aAC5CR,KAAKH,SAChB,CAMOY,qBACH,OAAO,IACX,CAQOC,iBAAiBC,EAAiBC,GACrC,MAAMC,EAAqB,cAAkBb,KAAKH,WAGlD,OAFAG,KAAKE,eAAeY,aAAa,aAAcD,EAAmBE,EAAGF,EAAmBxB,EAAGwB,EAAmBG,EAAG,EAAKJ,GACtHZ,KAAKE,eAAee,aAAa,eAAgBjB,KAAKD,YAAYmB,MAAMlB,KAAKnB,WAAY+B,GAClFZ,IACX,CAEOmB,6BAA6BC,EAAgBC,GAChD,MAAMR,EAAqB,cAAkBb,KAAKH,WAElD,OADAuB,EAAOE,UAAUD,EAAsBR,EAAmBE,EAAGF,EAAmBxB,EAAGwB,EAAmBG,GAC/FhB,IACX,CAMOuB,qBAIH,OAHKvB,KAAKwB,eACNxB,KAAKwB,aAAe,iBAEjBxB,KAAKwB,YAChB,CAMOC,YACH,OAAO,gCACX,CAOOC,4BAA4BC,EAAcf,GAC7Ce,EAAQ,YAAcf,IAAc,CACxC,GAxGA,UADC,W,mCAOD,UADC,W","sources":["webpack://pro-racer/./src/externals/ammo.ts","webpack://pro-racer/./src/scenes/physicsWithAmmo.ts","webpack://pro-racer/../lts/core/generated/Lights/hemisphericLight.ts"],"sourcesContent":["import * as Ammo from \"ammo.js\";\n\nexport let ammoModule: any;\nexport const ammoReadyPromise = new Promise((resolve) => {\n    new Ammo().then((res: unknown) => {\n        ammoModule = res;\n        resolve(res);\n    });\n});\n","import { Engine } from \"@babylonjs/core/Engines/engine\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\nimport { SphereBuilder } from \"@babylonjs/core/Meshes/Builders/sphereBuilder\";\nimport { GroundBuilder } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\nimport { AmmoJSPlugin } from \"@babylonjs/core/Physics/Plugins/ammoJSPlugin\";\nimport \"@babylonjs/core/Physics/physicsEngineComponent\";\n\n// If you don't need the standard material you will still need to import it since the scene requires it.\nimport \"@babylonjs/core/Materials/standardMaterial\";\nimport { PhysicsImpostor } from \"@babylonjs/core/Physics/physicsImpostor\";\nimport { ammoModule, ammoReadyPromise } from \"../externals/ammo\";\nimport { CreateSceneClass } from \"../createScene\";\n\nclass PhysicsSceneWithAmmo implements CreateSceneClass {\n    preTasks = [ammoReadyPromise];\n\n    createScene = async (engine: Engine, canvas: HTMLCanvasElement): Promise<Scene> => {\n        // This creates a basic Babylon Scene object (non-mesh)\n        const scene = new Scene(engine);\n        \n        scene.enablePhysics(null, new AmmoJSPlugin(true, ammoModule));\n        const zero = new ammoModule.btVector3(0, 0, 0);\n        \n        console.log(zero);\n        const tm = new ammoModule.btTriangleMesh();\n        console.log(\"TriangleMesh\");\n        console.log(tm);\n        console.log(\"----\");\n        //const meshShape = ammoModule.btBvhTriangleMeshShape(tm, true, true);\n        console.log(\"====\");\n        //console.log(meshShape.name);\n    \n        // This creates and positions a free camera (non-mesh)\n        const camera = new ArcRotateCamera(\"my first camera\", 0, Math.PI / 3, 10, new Vector3(0, 0, 0), scene);\n    \n        // This targets the camera to scene origin\n        camera.setTarget(Vector3.Zero());\n    \n        // This attaches the camera to the canvas\n        camera.attachControl(canvas, true);\n    \n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n        const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\n    \n        // Default intensity is 1. Let's dim the light a small amount\n        light.intensity = 0.7;\n    \n        // Our built-in 'sphere' shape.\n        const sphere = SphereBuilder.CreateSphere(\n            \"sphere\",\n            { diameter: 2, segments: 32 },\n            scene\n        );\n    \n        sphere.physicsImpostor = new PhysicsImpostor(sphere, PhysicsImpostor.SphereImpostor, { mass: 2, restitution: 0.8}, scene);\n    \n        // Move the sphere upward 1/2 its height\n        sphere.position.y = 5;\n    \n        // Our built-in 'ground' shape.\n        const ground = GroundBuilder.CreateGround(\n            \"ground\",\n            { width: 6, height: 6 },\n            scene\n        );\n        \n        ground.physicsImpostor = new PhysicsImpostor(ground, PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.6});\n    \n        return scene;\n    };\n}\n\nexport default new PhysicsSceneWithAmmo();\n","import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @returns The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param _effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(_effect: Effect, lightIndex: string): HemisphericLight {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"],"names":["ammoModule","ammoReadyPromise","Promise","resolve","then","res","preTasks","createScene","async","engine","canvas","scene","enablePhysics","zero","console","log","tm","camera","Math","PI","setTarget","attachControl","intensity","sphere","diameter","segments","physicsImpostor","mass","restitution","position","y","ground","width","height","N","name","HemisphericLight","constructor","direction","super","groundColor","this","_buildUniformLayout","_uniformBuffer","addUniform","create","getClassName","setDirectionToTarget","target","subtract","getShadowGenerator","transferToEffect","_effect","lightIndex","normalizeDirection","updateFloat4","x","z","updateColor3","scale","transferToNodeMaterialEffect","effect","lightDataUniformName","setFloat3","computeWorldMatrix","_worldMatrix","getTypeID","prepareLightSpecificDefines","defines"],"sourceRoot":""}