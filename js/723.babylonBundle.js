"use strict";(self.webpackChunkpro_racer=self.webpackChunkpro_racer||[]).push([[723],{6089:(e,t,s)=>{s.d(t,{R:()=>S});var i=s(972),n=s(3073),r=(s(1358),s(7827),s(2106),s(9938)),a=s(6070),o=s(9251),h=s(889),d=s(9288),l=s(78);const c=i.P.Up(),u=i.P.Zero(),_=new i.P,p=new i.P,f=new i.y3;class S extends a.u{constructor(e,t,s){S.IsSupported?(super(e,t,s),this.usePercentageCloserFiltering=!0):d.Y.Error("CascadedShadowMap is not supported by the current engine.")}_validateFilter(e){return e===a.u.FILTER_NONE||e===a.u.FILTER_PCF||e===a.u.FILTER_PCSS?e:(console.error('Unsupported filter "'+e+'"!'),a.u.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(e){(e=Math.min(Math.max(e,S.MIN_CASCADES_COUNT),S.MAX_CASCADES_COUNT))!==this._numCascades&&(this._numCascades=e,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(e){this._freezeShadowCastersBoundingInfoObservable&&e&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._freezeShadowCastersBoundingInfoObservable||e||(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this))),this._freezeShadowCastersBoundingInfo=e,e&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE),this._shadowMap&&this._shadowMap.renderList){const e=this._shadowMap.renderList;for(let t=0;t<e.length;t++){const s=e[t];if(!s)continue;const i=s.getBoundingInfo().boundingBox;this._scbiMin.minimizeInPlace(i.minimumWorld),this._scbiMax.maximizeInPlace(i.maximumWorld)}const t=this._scene.meshes;for(let e=0;e<t.length;e++){const s=t[e];if(!(s&&s.isVisible&&s.isEnabled&&s.receiveShadows))continue;const i=s.getBoundingInfo().boundingBox;this._scbiMin.minimizeInPlace(i.minimumWorld),this._scbiMax.maximizeInPlace(i.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(e){this._shadowCastersBoundingInfo=e}setMinMaxDistance(e,t){this._minDistance===e&&this._maxDistance===t||(e>t&&(e=0,t=1),e<0&&(e=0),t>1&&(t=1),this._minDistance=e,this._maxDistance=t,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return S.CLASSNAME}getCascadeMinExtents(e){return e>=0&&e<this._numCascades?this._cascadeMinExtents[e]:null}getCascadeMaxExtents(e){return e>=0&&e<this._numCascades?this._cascadeMaxExtents[e]:null}get shadowMaxZ(){return this._scene&&this._scene.activeCamera?this._shadowMaxZ:0}set shadowMaxZ(e){this._scene&&this._scene.activeCamera?this._shadowMaxZ===e||e<this._scene.activeCamera.minZ||e>this._scene.activeCamera.maxZ||(this._shadowMaxZ=e,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0):this._shadowMaxZ=e}get debug(){return this._debug}set debug(e){this._debug=e,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(e){this._depthClamp=e}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){this._cascadeBlendPercentage=e,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(e){const t=Math.min(Math.max(e,0),1);this._lambda!=t&&(this._lambda=t,this._breaksAreDirty=!0)}getCascadeViewMatrix(e){return e>=0&&e<this._numCascades?this._viewMatrices[e]:null}getCascadeProjectionMatrix(e){return e>=0&&e<this._numCascades?this._projectionMatrices[e]:null}getCascadeTransformMatrix(e){return e>=0&&e<this._numCascades?this._transformMatrices[e]:null}setDepthRenderer(e){this._depthRenderer=e,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){const t=this._scene.activeCamera;if(t){if(this._autoCalcDepthBounds=e,!e)return this._depthReducer&&this._depthReducer.deactivate(),void this.setMinMaxDistance(0,1);this._depthReducer||(this._depthReducer=new h.j(t),this._depthReducer.onAfterReductionPerformed.add((e=>{let t=e.min,s=e.max;t>=s&&(t=0,s=1),t==this._minDistance&&s==this._maxDistance||this.setMinMaxDistance(t,s)})),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){var e,t,s;return null!==(s=null===(t=null===(e=this._depthReducer)||void 0===e?void 0:e.depthRenderer)||void 0===t?void 0:t.getDepthMap().refreshRate)&&void 0!==s?s:-1}set autoCalcDepthBoundsRefreshRate(e){var t;(null===(t=this._depthReducer)||void 0===t?void 0:t.depthRenderer)&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=e)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const e=this._scene.activeCamera;if(!e)return;const t=e.minZ,s=e.maxZ,i=s-t,n=this._minDistance,r=t+n*i,a=t+(this._shadowMaxZ<s&&this._shadowMaxZ>=t?Math.min((this._shadowMaxZ-t)/(s-t),this._maxDistance):this._maxDistance)*i,o=a-r,h=a/r;for(let e=0;e<this._cascades.length;++e){const s=(e+1)/this._numCascades,a=r*h**s,d=r+o*s,l=this._lambda*(a-d)+d;this._cascades[e].prevBreakDistance=0===e?n:this._cascades[e-1].breakDistance,this._cascades[e].breakDistance=(l-t)/i,this._viewSpaceFrustumsZ[e]=l,this._frustumLengths[e]=(this._cascades[e].breakDistance-this._cascades[e].prevBreakDistance)*i}this._breaksAreDirty=!1}_computeMatrices(){const e=this._scene;if(!e.activeCamera)return;i.P.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),1===Math.abs(i.P.Dot(this._lightDirection,i.P.Up()))&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const t=e.getEngine().useReverseDepthBuffer;for(let s=0;s<this._numCascades;++s){this._computeFrustumInWorldSpace(s),this._computeCascadeFrustum(s),this._cascadeMaxExtents[s].subtractToRef(this._cascadeMinExtents[s],_),this._frustumCenter[s].addToRef(this._lightDirection.scale(this._cascadeMinExtents[s].z),this._shadowCameraPos[s]),i.y3.LookAtLHToRef(this._shadowCameraPos[s],this._frustumCenter[s],c,this._viewMatrices[s]);let n=0,r=_.z;const o=this._shadowCastersBoundingInfo;o.update(this._viewMatrices[s]),r=Math.min(r,o.boundingBox.maximumWorld.z),n=this._depthClamp&&this.filter!==a.u.FILTER_PCSS?Math.max(n,o.boundingBox.minimumWorld.z):Math.min(n,o.boundingBox.minimumWorld.z),i.y3.OrthoOffCenterLHToRef(this._cascadeMinExtents[s].x,this._cascadeMaxExtents[s].x,this._cascadeMinExtents[s].y,this._cascadeMaxExtents[s].y,t?r:n,t?n:r,this._projectionMatrices[s],e.getEngine().isNDCHalfZRange),this._cascadeMinExtents[s].z=n,this._cascadeMaxExtents[s].z=r,this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s],this._transformMatrices[s]),i.P.TransformCoordinatesToRef(u,this._transformMatrices[s],_),_.scaleInPlace(this._mapSize/2),p.copyFromFloats(Math.round(_.x),Math.round(_.y),Math.round(_.z)),p.subtractInPlace(_).scaleInPlace(2/this._mapSize),i.y3.TranslationToRef(p.x,p.y,0,f),this._projectionMatrices[s].multiplyToRef(f,this._projectionMatrices[s]),this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s],this._transformMatrices[s]),this._transformMatrices[s].copyToArray(this._transformMatricesAsArray,16*s)}}_computeFrustumInWorldSpace(e){if(!this._scene.activeCamera)return;const t=this._cascades[e].prevBreakDistance,s=this._cascades[e].breakDistance,n=this._scene.getEngine().isNDCHalfZRange;this._scene.activeCamera.getViewMatrix();const r=i.y3.Invert(this._scene.activeCamera.getTransformationMatrix()),a=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let t=0;t<S._FrustumCornersNDCSpace.length;++t)_.copyFrom(S._FrustumCornersNDCSpace[(t+a)%S._FrustumCornersNDCSpace.length]),n&&-1===_.z&&(_.z=0),i.P.TransformCoordinatesToRef(_,r,this._frustumCornersWorldSpace[e][t]);for(let i=0;i<S._FrustumCornersNDCSpace.length/2;++i)_.copyFrom(this._frustumCornersWorldSpace[e][i+4]).subtractInPlace(this._frustumCornersWorldSpace[e][i]),p.copyFrom(_).scaleInPlace(t),_.scaleInPlace(s),_.addInPlace(this._frustumCornersWorldSpace[e][i]),this._frustumCornersWorldSpace[e][i+4].copyFrom(_),this._frustumCornersWorldSpace[e][i].addInPlace(p)}_computeCascadeFrustum(e){if(this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[e].copyFromFloats(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE),this._frustumCenter[e].copyFromFloats(0,0,0),this._scene.activeCamera){for(let t=0;t<this._frustumCornersWorldSpace[e].length;++t)this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][t]);if(this._frustumCenter[e].scaleInPlace(1/this._frustumCornersWorldSpace[e].length),this.stabilizeCascades){let t=0;for(let s=0;s<this._frustumCornersWorldSpace[e].length;++s){const i=this._frustumCornersWorldSpace[e][s].subtractToRef(this._frustumCenter[e],_).length();t=Math.max(t,i)}t=Math.ceil(16*t)/16,this._cascadeMaxExtents[e].copyFromFloats(t,t,t),this._cascadeMinExtents[e].copyFromFloats(-t,-t,-t)}else{const t=this._frustumCenter[e];this._frustumCenter[e].addToRef(this._lightDirection,_),i.y3.LookAtLHToRef(t,_,c,f);for(let t=0;t<this._frustumCornersWorldSpace[e].length;++t)i.P.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][t],f,_),this._cascadeMinExtents[e].minimizeInPlace(_),this._cascadeMaxExtents[e].maximizeInPlace(_)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let e=0;e<this._numCascades;++e)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`))}static get IsSupported(){const e=l.l.LastCreatedEngine;return!!e&&e._features.supportCSM}_initializeGenerator(){var e,t,s,n,r,a,h,d,l,c,u,_,p,f,M,g,m,x,E,v;this.penumbraDarkness=null!==(e=this.penumbraDarkness)&&void 0!==e?e:1,this._numCascades=null!==(t=this._numCascades)&&void 0!==t?t:S.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=null!==(s=this.stabilizeCascades)&&void 0!==s&&s,this._freezeShadowCastersBoundingInfoObservable=null!==(n=this._freezeShadowCastersBoundingInfoObservable)&&void 0!==n?n:null,this.freezeShadowCastersBoundingInfo=null!==(r=this.freezeShadowCastersBoundingInfo)&&void 0!==r&&r,this._scbiMin=null!==(a=this._scbiMin)&&void 0!==a?a:new i.P(0,0,0),this._scbiMax=null!==(h=this._scbiMax)&&void 0!==h?h:new i.P(0,0,0),this._shadowCastersBoundingInfo=null!==(d=this._shadowCastersBoundingInfo)&&void 0!==d?d:new o.j(new i.P(0,0,0),new i.P(0,0,0)),this._breaksAreDirty=null===(l=this._breaksAreDirty)||void 0===l||l,this._minDistance=null!==(c=this._minDistance)&&void 0!==c?c:0,this._maxDistance=null!==(u=this._maxDistance)&&void 0!==u?u:1,this._currentLayer=null!==(_=this._currentLayer)&&void 0!==_?_:0,this._shadowMaxZ=null!==(M=null!==(p=this._shadowMaxZ)&&void 0!==p?p:null===(f=this._scene.activeCamera)||void 0===f?void 0:f.maxZ)&&void 0!==M?M:1e4,this._debug=null!==(g=this._debug)&&void 0!==g&&g,this._depthClamp=null===(m=this._depthClamp)||void 0===m||m,this._cascadeBlendPercentage=null!==(x=this._cascadeBlendPercentage)&&void 0!==x?x:.1,this._lambda=null!==(E=this._lambda)&&void 0!==E?E:.5,this._autoCalcDepthBounds=null!==(v=this._autoCalcDepthBounds)&&void 0!==v&&v,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const e=this._scene.getEngine(),t={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new n._(this._light.name+"_CSMShadowMap",t,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0)}_initializeShadowMap(){if(super._initializeShadowMap(),null===this._shadowMap)return;this._transformMatricesAsArray=new Float32Array(16*this._numCascades),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(2*this._numCascades),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let e=0;e<this._numCascades;++e){this._cascades[e]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[e]=i.y3.Zero(),this._projectionMatrices[e]=i.y3.Zero(),this._transformMatrices[e]=i.y3.Zero(),this._cascadeMinExtents[e]=new i.P,this._cascadeMaxExtents[e]=new i.P,this._frustumCenter[e]=new i.P,this._shadowCameraPos[e]=new i.P,this._frustumCornersWorldSpace[e]=new Array(S._FrustumCornersNDCSpace.length);for(let t=0;t<S._FrustumCornersNDCSpace.length;++t)this._frustumCornersWorldSpace[e][t]=new i.P}const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add((t=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[t]),this._currentLayer=t,this._filter===a.u.FILTER_PCF&&e.setColorWrite(!1),this._scene.setTransformMatrix(this.getCascadeViewMatrix(t),this.getCascadeProjectionMatrix(t)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())})),this._shadowMap.onBeforeBindObservable.add((()=>{var t;this._currentSceneUBO=this._scene.getSceneUniformBuffer(),null===(t=e._debugPushGroup)||void 0===t||t.call(e,`cascaded shadow map generation for pass id ${e.currentRenderPassId}`,1),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()})),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(e,t){t.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(e){e.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==a.u.FILTER_PCSS?"1":"0"))}prepareDefines(e,t){super.prepareDefines(e,t);const s=this._scene,i=this._light;if(!s.shadowsEnabled||!i.shadowEnabled)return;e["SHADOWCSM"+t]=!0,e["SHADOWCSMDEBUG"+t]=this.debug,e["SHADOWCSMNUM_CASCADES"+t]=this.numCascades,e["SHADOWCSM_RIGHTHANDED"+t]=s.useRightHandedSystem;const n=s.activeCamera;n&&this._shadowMaxZ<n.maxZ&&(e["SHADOWCSMUSESHADOWMAXZ"+t]=!0),0===this.cascadeBlendPercentage&&(e["SHADOWCSMNOBLEND"+t]=!0)}bindShadowLight(e,t){const s=this._light,i=this._scene;if(!i.shadowsEnabled||!s.shadowEnabled)return;const n=i.activeCamera;if(!n)return;const r=this.getShadowMap();if(!r)return;const o=r.getSize().width;if(t.setMatrices("lightMatrix"+e,this._transformMatricesAsArray),t.setArray("viewFrustumZ"+e,this._viewSpaceFrustumsZ),t.setFloat("cascadeBlendFactor"+e,0===this.cascadeBlendPercentage?1e4:1/this.cascadeBlendPercentage),t.setArray("frustumLengths"+e,this._frustumLengths),this._filter===a.u.FILTER_PCF)t.setDepthStencilTexture("shadowSampler"+e,r),s._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),o,1/o,this.frustumEdgeFalloff,e);else if(this._filter===a.u.FILTER_PCSS){for(let e=0;e<this._numCascades;++e)this._lightSizeUVCorrection[2*e+0]=0===e?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[e].x-this._cascadeMinExtents[e].x),this._lightSizeUVCorrection[2*e+1]=0===e?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[e].y-this._cascadeMinExtents[e].y),this._depthCorrection[e]=0===e?1:(this._cascadeMaxExtents[e].z-this._cascadeMinExtents[e].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);t.setDepthStencilTexture("shadowSampler"+e,r),t.setTexture("depthSampler"+e,r),t.setArray2("lightSizeUVCorrection"+e,this._lightSizeUVCorrection),t.setArray("depthCorrection"+e,this._depthCorrection),t.setFloat("penumbraDarkness"+e,this.penumbraDarkness),s._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/o,this._contactHardeningLightSizeUVRatio*o,this.frustumEdgeFalloff,e)}else t.setTexture("shadowSampler"+e,r),s._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),o,1/o,this.frustumEdgeFalloff,e);s._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(n),this.getLight().getDepthMinZ(n)+this.getLight().getDepthMaxZ(n),e)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const e=super.serialize(),t=this.getShadowMap();if(!t)return e;if(e.numCascades=this._numCascades,e.debug=this._debug,e.stabilizeCascades=this.stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this.cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.autoCalcDepthBounds=this.autoCalcDepthBounds,e.shadowMaxZ=this._shadowMaxZ,e.penumbraDarkness=this.penumbraDarkness,e.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,e.minDistance=this.minDistance,e.maxDistance=this.maxDistance,e.renderList=[],t.renderList)for(let s=0;s<t.renderList.length;s++){const i=t.renderList[s];e.renderList.push(i.id)}return e}static Parse(e,t){const s=a.u.Parse(e,t,((e,t)=>new S(e,t)));return void 0!==e.numCascades&&(s.numCascades=e.numCascades),void 0!==e.debug&&(s.debug=e.debug),void 0!==e.stabilizeCascades&&(s.stabilizeCascades=e.stabilizeCascades),void 0!==e.lambda&&(s.lambda=e.lambda),void 0!==e.cascadeBlendPercentage&&(s.cascadeBlendPercentage=e.cascadeBlendPercentage),void 0!==e.depthClamp&&(s.depthClamp=e.depthClamp),void 0!==e.autoCalcDepthBounds&&(s.autoCalcDepthBounds=e.autoCalcDepthBounds),void 0!==e.shadowMaxZ&&(s.shadowMaxZ=e.shadowMaxZ),void 0!==e.penumbraDarkness&&(s.penumbraDarkness=e.penumbraDarkness),void 0!==e.freezeShadowCastersBoundingInfo&&(s.freezeShadowCastersBoundingInfo=e.freezeShadowCastersBoundingInfo),void 0!==e.minDistance&&void 0!==e.maxDistance&&s.setMinMaxDistance(e.minDistance,e.maxDistance),s}}S._FrustumCornersNDCSpace=[new i.P(-1,1,-1),new i.P(1,1,-1),new i.P(1,-1,-1),new i.P(-1,-1,-1),new i.P(-1,1,1),new i.P(1,1,1),new i.P(1,-1,1),new i.P(-1,-1,1)],S.CLASSNAME="CascadedShadowGenerator",S.DEFAULT_CASCADES_COUNT=4,S.MIN_CASCADES_COUNT=2,S.MAX_CASCADES_COUNT=4,S._SceneComponentInitialization=e=>{throw(0,r.S)("ShadowGeneratorSceneComponent")}},6070:(e,t,s)=>{s.d(t,{u:()=>M});var i=s(972),n=s(9859),r=s(7959),a=s(5046),o=s(6721),h=s(4684),d=s(3073),l=s(1932),c=s(4774),u=s(4673),_=s(9938),p=s(3092),f=s(7800),S=s(2813);s(1358),s(7827),s(2106);s(3127).v.IncludesShadersStore.shadowMapFragmentSoftTransparentShadow="#if SM_SOFTTRANSPARENTSHADOW==1\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;\n#endif\n";class M{constructor(e,t,s){this.onBeforeShadowMapRenderObservable=new u.y$,this.onAfterShadowMapRenderObservable=new u.y$,this.onBeforeShadowMapRenderMeshObservable=new u.y$,this.onAfterShadowMapRenderMeshObservable=new u.y$,this._bias=5e-5,this._normalBias=0,this._blurBoxOffset=1,this._blurScale=2,this._blurKernel=1,this._useKernelBlur=!1,this._filter=M.FILTER_NONE,this._filteringQuality=M.QUALITY_HIGH,this._contactHardeningLightSizeUVRatio=.1,this._darkness=0,this._transparencyShadow=!1,this.enableSoftTransparentShadow=!1,this.useOpacityTextureForTransparentShadow=!1,this.frustumEdgeFalloff=0,this.forceBackFacesOnly=!1,this._lightDirection=i.P.Zero(),this._viewMatrix=i.y3.Zero(),this._projectionMatrix=i.y3.Zero(),this._transformMatrix=i.y3.Zero(),this._cachedPosition=new i.P(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cachedDirection=new i.P(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._currentFaceIndex=0,this._currentFaceIndexCache=0,this._defaultTextureMatrix=i.y3.Identity(),this._mapSize=e,this._light=t,this._scene=t.getScene(),t._shadowGenerator=this,this.id=t.id,this._useUBO=this._scene.getEngine().supportsUniformBuffers,this._useUBO&&(this._sceneUBOs=[],this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))),M._SceneComponentInitialization(this._scene);const n=this._scene.getEngine().getCaps();s?n.textureFloatRender&&n.textureFloatLinearFiltering?this._textureType=1:n.textureHalfFloatRender&&n.textureHalfFloatLinearFiltering?this._textureType=2:this._textureType=0:n.textureHalfFloatRender&&n.textureHalfFloatLinearFiltering?this._textureType=2:n.textureFloatRender&&n.textureFloatLinearFiltering?this._textureType=1:this._textureType=0,this._initializeGenerator(),this._applyFilterValues()}get bias(){return this._bias}set bias(e){this._bias=e}get normalBias(){return this._normalBias}set normalBias(e){this._normalBias=e}get blurBoxOffset(){return this._blurBoxOffset}set blurBoxOffset(e){this._blurBoxOffset!==e&&(this._blurBoxOffset=e,this._disposeBlurPostProcesses())}get blurScale(){return this._blurScale}set blurScale(e){this._blurScale!==e&&(this._blurScale=e,this._disposeBlurPostProcesses())}get blurKernel(){return this._blurKernel}set blurKernel(e){this._blurKernel!==e&&(this._blurKernel=e,this._disposeBlurPostProcesses())}get useKernelBlur(){return this._useKernelBlur}set useKernelBlur(e){this._useKernelBlur!==e&&(this._useKernelBlur=e,this._disposeBlurPostProcesses())}get depthScale(){return void 0!==this._depthScale?this._depthScale:this._light.getDepthScale()}set depthScale(e){this._depthScale=e}_validateFilter(e){return e}get filter(){return this._filter}set filter(e){if(e=this._validateFilter(e),this._light.needCube()){if(e===M.FILTER_BLUREXPONENTIALSHADOWMAP)return void(this.useExponentialShadowMap=!0);if(e===M.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP)return void(this.useCloseExponentialShadowMap=!0);if(e===M.FILTER_PCF||e===M.FILTER_PCSS)return void(this.usePoissonSampling=!0)}e!==M.FILTER_PCF&&e!==M.FILTER_PCSS||this._scene.getEngine()._features.supportShadowSamplers?this._filter!==e&&(this._filter=e,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty()):this.usePoissonSampling=!0}get usePoissonSampling(){return this.filter===M.FILTER_POISSONSAMPLING}set usePoissonSampling(e){const t=this._validateFilter(M.FILTER_POISSONSAMPLING);(e||this.filter===M.FILTER_POISSONSAMPLING)&&(this.filter=e?t:M.FILTER_NONE)}get useExponentialShadowMap(){return this.filter===M.FILTER_EXPONENTIALSHADOWMAP}set useExponentialShadowMap(e){const t=this._validateFilter(M.FILTER_EXPONENTIALSHADOWMAP);(e||this.filter===M.FILTER_EXPONENTIALSHADOWMAP)&&(this.filter=e?t:M.FILTER_NONE)}get useBlurExponentialShadowMap(){return this.filter===M.FILTER_BLUREXPONENTIALSHADOWMAP}set useBlurExponentialShadowMap(e){const t=this._validateFilter(M.FILTER_BLUREXPONENTIALSHADOWMAP);(e||this.filter===M.FILTER_BLUREXPONENTIALSHADOWMAP)&&(this.filter=e?t:M.FILTER_NONE)}get useCloseExponentialShadowMap(){return this.filter===M.FILTER_CLOSEEXPONENTIALSHADOWMAP}set useCloseExponentialShadowMap(e){const t=this._validateFilter(M.FILTER_CLOSEEXPONENTIALSHADOWMAP);(e||this.filter===M.FILTER_CLOSEEXPONENTIALSHADOWMAP)&&(this.filter=e?t:M.FILTER_NONE)}get useBlurCloseExponentialShadowMap(){return this.filter===M.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP}set useBlurCloseExponentialShadowMap(e){const t=this._validateFilter(M.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);(e||this.filter===M.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP)&&(this.filter=e?t:M.FILTER_NONE)}get usePercentageCloserFiltering(){return this.filter===M.FILTER_PCF}set usePercentageCloserFiltering(e){const t=this._validateFilter(M.FILTER_PCF);(e||this.filter===M.FILTER_PCF)&&(this.filter=e?t:M.FILTER_NONE)}get filteringQuality(){return this._filteringQuality}set filteringQuality(e){this._filteringQuality!==e&&(this._filteringQuality=e,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get useContactHardeningShadow(){return this.filter===M.FILTER_PCSS}set useContactHardeningShadow(e){const t=this._validateFilter(M.FILTER_PCSS);(e||this.filter===M.FILTER_PCSS)&&(this.filter=e?t:M.FILTER_NONE)}get contactHardeningLightSizeUVRatio(){return this._contactHardeningLightSizeUVRatio}set contactHardeningLightSizeUVRatio(e){this._contactHardeningLightSizeUVRatio=e}get darkness(){return this._darkness}set darkness(e){this.setDarkness(e)}getDarkness(){return this._darkness}setDarkness(e){return this._darkness=e>=1?1:e<=0?0:e,this}get transparencyShadow(){return this._transparencyShadow}set transparencyShadow(e){this.setTransparencyShadow(e)}setTransparencyShadow(e){return this._transparencyShadow=e,this}getShadowMap(){return this._shadowMap}getShadowMapForRendering(){return this._shadowMap2?this._shadowMap2:this._shadowMap}getClassName(){return M.CLASSNAME}addShadowCaster(e,t=!0){if(!this._shadowMap)return this;if(this._shadowMap.renderList||(this._shadowMap.renderList=[]),-1===this._shadowMap.renderList.indexOf(e)&&this._shadowMap.renderList.push(e),t)for(const t of e.getChildMeshes())-1===this._shadowMap.renderList.indexOf(t)&&this._shadowMap.renderList.push(t);return this}removeShadowCaster(e,t=!0){if(!this._shadowMap||!this._shadowMap.renderList)return this;const s=this._shadowMap.renderList.indexOf(e);if(-1!==s&&this._shadowMap.renderList.splice(s,1),t)for(const t of e.getChildren())this.removeShadowCaster(t);return this}getLight(){return this._light}get mapSize(){return this._mapSize}set mapSize(e){this._mapSize=e,this._light._markMeshesAsLightDirty(),this.recreateShadowMap()}_initializeGenerator(){this._light._markMeshesAsLightDirty(),this._initializeShadowMap()}_createTargetRenderTexture(){const e=this._scene.getEngine();e._features.supportDepthStencilTexture?(this._shadowMap=new d._(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube(),void 0,!1,!1),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0)):this._shadowMap=new d._(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube())}_initializeShadowMap(){if(this._createTargetRenderTexture(),null===this._shadowMap)return;this._shadowMap.wrapU=h.x.CLAMP_ADDRESSMODE,this._shadowMap.wrapV=h.x.CLAMP_ADDRESSMODE,this._shadowMap.anisotropicFilteringLevel=1,this._shadowMap.updateSamplingMode(h.x.BILINEAR_SAMPLINGMODE),this._shadowMap.renderParticles=!1,this._shadowMap.ignoreCameraViewport=!0,this._storedUniqueId&&(this._shadowMap.uniqueId=this._storedUniqueId),this._shadowMap.customRenderFunction=this._renderForShadowMap.bind(this),this._shadowMap.customIsReadyFunction=()=>!0;const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.add((()=>{var t;this._currentSceneUBO=this._scene.getSceneUniformBuffer(),null===(t=e._debugPushGroup)||void 0===t||t.call(e,`shadow map generation for pass id ${e.currentRenderPassId}`,1)})),this._shadowMap.onBeforeRenderObservable.add((t=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[0]),this._currentFaceIndex=t,this._filter===M.FILTER_PCF&&e.setColorWrite(!1),this.getTransformMatrix(),this._scene.setTransformMatrix(this._viewMatrix,this._projectionMatrix),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())})),this._shadowMap.onAfterUnbindObservable.add((()=>{var t,s;if(this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._currentSceneUBO),this._scene.updateTransformMatrix(),this._filter===M.FILTER_PCF&&e.setColorWrite(!0),!this.useBlurExponentialShadowMap&&!this.useBlurCloseExponentialShadowMap)return void(null===(t=e._debugPopGroup)||void 0===t||t.call(e,1));const i=this.getShadowMapForRendering();i&&(this._scene.postProcessManager.directRender(this._blurPostProcesses,i.renderTarget,!0),e.unBindFramebuffer(i.renderTarget,!0),null===(s=e._debugPopGroup)||void 0===s||s.call(e,1))}));const t=new n.HE(0,0,0,0),s=new n.HE(1,1,1,1);this._shadowMap.onClearObservable.add((e=>{this._filter===M.FILTER_PCF?e.clear(s,!1,!0,!1):this.useExponentialShadowMap||this.useBlurExponentialShadowMap?e.clear(t,!0,!0,!1):e.clear(s,!0,!0,!1)})),this._shadowMap.onResizeObservable.add((e=>{this._storedUniqueId=this._shadowMap.uniqueId,this._mapSize=e.getRenderSize(),this._light._markMeshesAsLightDirty(),this.recreateShadowMap()}));for(let e=f.$.MIN_RENDERINGGROUPS;e<f.$.MAX_RENDERINGGROUPS;e++)this._shadowMap.setRenderingAutoClearDepthStencil(e,!1)}_initializeBlurRTTAndPostProcesses(){const e=this._scene.getEngine(),t=this._mapSize/this.blurScale;this.useKernelBlur&&1===this.blurScale||(this._shadowMap2=new d._(this._light.name+"_shadowMap2",t,this._scene,!1,!0,this._textureType,void 0,void 0,!1),this._shadowMap2.wrapU=h.x.CLAMP_ADDRESSMODE,this._shadowMap2.wrapV=h.x.CLAMP_ADDRESSMODE,this._shadowMap2.updateSamplingMode(h.x.BILINEAR_SAMPLINGMODE)),this.useKernelBlur?(this._kernelBlurXPostprocess=new c.i(this._light.name+"KernelBlurX",new i.FM(1,0),this.blurKernel,1,null,h.x.BILINEAR_SAMPLINGMODE,e,!1,this._textureType),this._kernelBlurXPostprocess.width=t,this._kernelBlurXPostprocess.height=t,this._kernelBlurXPostprocess.externalTextureSamplerBinding=!0,this._kernelBlurXPostprocess.onApplyObservable.add((e=>{e.setTexture("textureSampler",this._shadowMap)})),this._kernelBlurYPostprocess=new c.i(this._light.name+"KernelBlurY",new i.FM(0,1),this.blurKernel,1,null,h.x.BILINEAR_SAMPLINGMODE,e,!1,this._textureType),this._kernelBlurXPostprocess.autoClear=!1,this._kernelBlurYPostprocess.autoClear=!1,0===this._textureType&&(this._kernelBlurXPostprocess.packedFloat=!0,this._kernelBlurYPostprocess.packedFloat=!0),this._blurPostProcesses=[this._kernelBlurXPostprocess,this._kernelBlurYPostprocess]):(this._boxBlurPostprocess=new l.D(this._light.name+"DepthBoxBlur","depthBoxBlur",["screenSize","boxOffset"],[],1,null,h.x.BILINEAR_SAMPLINGMODE,e,!1,"#define OFFSET "+this._blurBoxOffset,this._textureType),this._boxBlurPostprocess.externalTextureSamplerBinding=!0,this._boxBlurPostprocess.onApplyObservable.add((e=>{e.setFloat2("screenSize",t,t),e.setTexture("textureSampler",this._shadowMap)})),this._boxBlurPostprocess.autoClear=!1,this._blurPostProcesses=[this._boxBlurPostprocess])}_renderForShadowMap(e,t,s,i){let n;if(i.length)for(n=0;n<i.length;n++)this._renderSubMeshForShadowMap(i.data[n]);for(n=0;n<e.length;n++)this._renderSubMeshForShadowMap(e.data[n]);for(n=0;n<t.length;n++)this._renderSubMeshForShadowMap(t.data[n]);if(this._transparencyShadow)for(n=0;n<s.length;n++)this._renderSubMeshForShadowMap(s.data[n],!0);else for(n=0;n<s.length;n++)s.data[n].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}_bindCustomEffectForRenderSubMeshForShadowMap(e,t,s){t.setMatrix("viewProjection",this.getTransformMatrix())}_renderSubMeshForShadowMap(e,t=!1){var s,i;const n=e.getRenderingMesh(),r=e.getEffectiveMesh(),h=this._scene,d=h.getEngine(),l=e.getMaterial();if(r._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!l||0===e.verticesCount||e._renderId===h.getRenderId())return;const c=r._getWorldMatrixDeterminant()<0;let u=null!==(s=n.overrideMaterialSideOrientation)&&void 0!==s?s:l.sideOrientation;c&&(u=0===u?1:0);const _=0===u;d.setState(l.backFaceCulling,void 0,void 0,_,l.cullBackFaces);const p=n._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(p.mustReturn)return;const f=d.getCaps().instancedArrays&&(null!==p.visibleInstances[e._id]&&void 0!==p.visibleInstances[e._id]||n.hasThinInstances);if(!this.customAllowRendering||this.customAllowRendering(e))if(this.isReady(e,f,t)){e._renderId=h.getRenderId();const s=l.shadowDepthWrapper,c=null!==(i=null==s?void 0:s.getEffect(e,this,d.currentRenderPassId))&&void 0!==i?i:e._getDrawWrapper(),u=S.q.GetEffect(c);if(d.enableEffect(c),f||n._bind(e,u,l.fillMode),this.getTransformMatrix(),u.setFloat3("biasAndScaleSM",this.bias,this.normalBias,this.depthScale),this.getLight().getTypeID()===a._.LIGHTTYPEID_DIRECTIONALLIGHT?u.setVector3("lightDataSM",this._cachedDirection):u.setVector3("lightDataSM",this._cachedPosition),h.activeCamera&&u.setFloat2("depthValuesSM",this.getLight().getDepthMinZ(h.activeCamera),this.getLight().getDepthMinZ(h.activeCamera)+this.getLight().getDepthMaxZ(h.activeCamera)),t&&this.enableSoftTransparentShadow&&u.setFloat("softTransparentShadowSM",r.visibility*l.alpha),s)e._setMainDrawWrapperOverride(c),s.standalone?s.baseMaterial.bindForSubMesh(r.getWorldMatrix(),n,e):l.bindForSubMesh(r.getWorldMatrix(),n,e),e._setMainDrawWrapperOverride(null);else{if(l&&this.useOpacityTextureForTransparentShadow){const e=l.opacityTexture;e&&(u.setTexture("diffuseSampler",e),u.setMatrix("diffuseMatrix",e.getTextureMatrix()||this._defaultTextureMatrix))}else if(l&&l.needAlphaTesting()){const e=l.getAlphaTestTexture();e&&(u.setTexture("diffuseSampler",e),u.setMatrix("diffuseMatrix",e.getTextureMatrix()||this._defaultTextureMatrix))}if(n.useBones&&n.computeBonesUsingShaders&&n.skeleton){const e=n.skeleton;if(e.isUsingTextureForMatrices){const t=e.getTransformMatrixTexture(n);if(!t)return;u.setTexture("boneSampler",t),u.setFloat("boneTextureWidth",4*(e.bones.length+1))}else u.setMatrices("mBones",e.getTransformMatrices(n))}o.G.BindMorphTargetParameters(n,u),n.morphTargetManager&&n.morphTargetManager.isUsingTextureForTargets&&n.morphTargetManager._bind(u),o.G.BindClipPlane(u,h)}this._useUBO||s||this._bindCustomEffectForRenderSubMeshForShadowMap(e,u,r),o.G.BindSceneUniformBuffer(u,this._scene.getSceneUniformBuffer()),this._scene.getSceneUniformBuffer().bindUniformBuffer();const _=r.getWorldMatrix();f&&(r.getMeshUniformBuffer().bindToEffect(u,"Mesh"),r.transferToEffect(_)),this.forceBackFacesOnly&&d.setState(!0,0,!1,!0,l.cullBackFaces),this.onBeforeShadowMapRenderMeshObservable.notifyObservers(n),this.onBeforeShadowMapRenderObservable.notifyObservers(u),n._processRendering(r,e,u,l.fillMode,p,f,((e,t)=>{r===n||e?(r.getMeshUniformBuffer().bindToEffect(u,"Mesh"),r.transferToEffect(e?t:_)):(n.getMeshUniformBuffer().bindToEffect(u,"Mesh"),n.transferToEffect(t))})),this.forceBackFacesOnly&&d.setState(!0,0,!1,!1,l.cullBackFaces),this.onAfterShadowMapRenderObservable.notifyObservers(u),this.onAfterShadowMapRenderMeshObservable.notifyObservers(n)}else this._shadowMap&&this._shadowMap.resetRefreshCounter()}_applyFilterValues(){this._shadowMap&&(this.filter===M.FILTER_NONE||this.filter===M.FILTER_PCSS?this._shadowMap.updateSamplingMode(h.x.NEAREST_SAMPLINGMODE):this._shadowMap.updateSamplingMode(h.x.BILINEAR_SAMPLINGMODE))}forceCompilation(e,t){const s={useInstances:!1,...t},i=this.getShadowMap();if(!i)return void(e&&e(this));const n=i.renderList;if(!n)return void(e&&e(this));const r=new Array;for(const e of n)r.push(...e.subMeshes);if(0===r.length)return void(e&&e(this));let a=0;const o=()=>{var t,i;if(this._scene&&this._scene.getEngine()){for(;this.isReady(r[a],s.useInstances,null!==(i=null===(t=r[a].getMaterial())||void 0===t?void 0:t.needAlphaBlendingForMesh(r[a].getMesh()))&&void 0!==i&&i);)if(a++,a>=r.length)return void(e&&e(this));setTimeout(o,16)}};o()}forceCompilationAsync(e){return new Promise((t=>{this.forceCompilation((()=>{t()}),e)}))}_isReadyCustomDefines(e,t,s){}_prepareShadowDefines(e,t,s,i){s.push("#define SM_FLOAT "+(0!==this._textureType?"1":"0")),s.push("#define SM_ESM "+(this.useExponentialShadowMap||this.useBlurExponentialShadowMap?"1":"0")),s.push("#define SM_DEPTHTEXTURE "+(this.usePercentageCloserFiltering||this.useContactHardeningShadow?"1":"0"));const n=e.getMesh();return s.push("#define SM_NORMALBIAS "+(this.normalBias&&n.isVerticesDataPresent(r.o.NormalKind)?"1":"0")),s.push("#define SM_DIRECTIONINLIGHTDATA "+(this.getLight().getTypeID()===a._.LIGHTTYPEID_DIRECTIONALLIGHT?"1":"0")),s.push("#define SM_USEDISTANCE "+(this._light.needCube()?"1":"0")),s.push("#define SM_SOFTTRANSPARENTSHADOW "+(this.enableSoftTransparentShadow&&i?"1":"0")),this._isReadyCustomDefines(s,e,t),s}isReady(e,t,s){var i;const n=e.getMaterial(),a=null==n?void 0:n.shadowDepthWrapper,h=[];if(this._prepareShadowDefines(e,t,h,s),a){if(!a.isReadyForSubMesh(e,h,this,t,this._scene.getEngine().currentRenderPassId))return!1}else{const s=e._getDrawWrapper(void 0,!0);let a=s.effect,d=s.defines;const l=[r.o.PositionKind],c=e.getMesh();if(this.normalBias&&c.isVerticesDataPresent(r.o.NormalKind)&&(l.push(r.o.NormalKind),h.push("#define NORMAL"),c.nonUniformScaling&&h.push("#define NONUNIFORMSCALING")),n&&n.needAlphaTesting()){let e=null;if(e=this.useOpacityTextureForTransparentShadow?n.opacityTexture:n.getAlphaTestTexture(),e){if(!e.isReady())return!1;const t=null!==(i=n.alphaCutOff)&&void 0!==i?i:M.DEFAULT_ALPHA_CUTOFF;h.push("#define ALPHATEST"),h.push(`#define ALPHATESTVALUE ${t}${t%1==0?".":""}`),c.isVerticesDataPresent(r.o.UVKind)&&(l.push(r.o.UVKind),h.push("#define UV1")),c.isVerticesDataPresent(r.o.UV2Kind)&&1===e.coordinatesIndex&&(l.push(r.o.UV2Kind),h.push("#define UV2"))}}const u=new p.L;if(c.useBones&&c.computeBonesUsingShaders&&c.skeleton){l.push(r.o.MatricesIndicesKind),l.push(r.o.MatricesWeightsKind),c.numBoneInfluencers>4&&(l.push(r.o.MatricesIndicesExtraKind),l.push(r.o.MatricesWeightsExtraKind));const e=c.skeleton;h.push("#define NUM_BONE_INFLUENCERS "+c.numBoneInfluencers),c.numBoneInfluencers>0&&u.addCPUSkinningFallback(0,c),e.isUsingTextureForMatrices?h.push("#define BONETEXTURE"):h.push("#define BonesPerMesh "+(e.bones.length+1))}else h.push("#define NUM_BONE_INFLUENCERS 0");const _=c.morphTargetManager;let f=0;_&&_.numInfluencers>0&&(h.push("#define MORPHTARGETS"),f=_.numInfluencers,h.push("#define NUM_MORPH_INFLUENCERS "+f),_.isUsingTextureForTargets&&h.push("#define MORPHTARGETS_TEXTURE"),o.G.PrepareAttributesForMorphTargetsInfluencers(l,c,f));const S=this._scene;if(S.clipPlane&&h.push("#define CLIPPLANE"),S.clipPlane2&&h.push("#define CLIPPLANE2"),S.clipPlane3&&h.push("#define CLIPPLANE3"),S.clipPlane4&&h.push("#define CLIPPLANE4"),S.clipPlane5&&h.push("#define CLIPPLANE5"),S.clipPlane6&&h.push("#define CLIPPLANE6"),t&&(h.push("#define INSTANCES"),o.G.PushAttributesForInstances(l),e.getRenderingMesh().hasThinInstances&&h.push("#define THIN_INSTANCES")),this.customShaderOptions&&this.customShaderOptions.defines)for(const e of this.customShaderOptions.defines)-1===h.indexOf(e)&&h.push(e);const g=h.join("\n");if(d!==g){d=g;let e="shadowMap";const t=["world","mBones","viewProjection","diffuseMatrix","lightDataSM","depthValuesSM","biasAndScaleSM","morphTargetInfluences","boneTextureWidth","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","softTransparentShadowSM","morphTargetTextureInfo","morphTargetTextureIndices"],i=["diffuseSampler","boneSampler","morphTargets"],n=["Scene","Mesh"];if(this.customShaderOptions){if(e=this.customShaderOptions.shaderName,this.customShaderOptions.attributes)for(const e of this.customShaderOptions.attributes)-1===l.indexOf(e)&&l.push(e);if(this.customShaderOptions.uniforms)for(const e of this.customShaderOptions.uniforms)-1===t.indexOf(e)&&t.push(e);if(this.customShaderOptions.samplers)for(const e of this.customShaderOptions.samplers)-1===i.indexOf(e)&&i.push(e)}const r=this._scene.getEngine();a=r.createEffect(e,{attributes:l,uniformsNames:t,uniformBuffersNames:n,samplers:i,defines:g,fallbacks:u,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:f}},r),s.setEffect(a,d)}if(!a.isReady())return!1}return(this.useBlurExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(this._blurPostProcesses&&this._blurPostProcesses.length||this._initializeBlurRTTAndPostProcesses()),!(this._kernelBlurXPostprocess&&!this._kernelBlurXPostprocess.isReady()||this._kernelBlurYPostprocess&&!this._kernelBlurYPostprocess.isReady()||this._boxBlurPostprocess&&!this._boxBlurPostprocess.isReady())}prepareDefines(e,t){const s=this._scene,i=this._light;s.shadowsEnabled&&i.shadowEnabled&&(e["SHADOW"+t]=!0,this.useContactHardeningShadow?(e["SHADOWPCSS"+t]=!0,this._filteringQuality===M.QUALITY_LOW?e["SHADOWLOWQUALITY"+t]=!0:this._filteringQuality===M.QUALITY_MEDIUM&&(e["SHADOWMEDIUMQUALITY"+t]=!0)):this.usePercentageCloserFiltering?(e["SHADOWPCF"+t]=!0,this._filteringQuality===M.QUALITY_LOW?e["SHADOWLOWQUALITY"+t]=!0:this._filteringQuality===M.QUALITY_MEDIUM&&(e["SHADOWMEDIUMQUALITY"+t]=!0)):this.usePoissonSampling?e["SHADOWPOISSON"+t]=!0:this.useExponentialShadowMap||this.useBlurExponentialShadowMap?e["SHADOWESM"+t]=!0:(this.useCloseExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(e["SHADOWCLOSEESM"+t]=!0),i.needCube()&&(e["SHADOWCUBE"+t]=!0))}bindShadowLight(e,t){const s=this._light,i=this._scene;if(!i.shadowsEnabled||!s.shadowEnabled)return;const n=i.activeCamera;if(!n)return;const r=this.getShadowMap();r&&(s.needCube()||t.setMatrix("lightMatrix"+e,this.getTransformMatrix()),this._filter===M.FILTER_PCF?(t.setDepthStencilTexture("shadowSampler"+e,this.getShadowMapForRendering()),s._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),r.getSize().width,1/r.getSize().width,this.frustumEdgeFalloff,e)):this._filter===M.FILTER_PCSS?(t.setDepthStencilTexture("shadowSampler"+e,this.getShadowMapForRendering()),t.setTexture("depthSampler"+e,this.getShadowMapForRendering()),s._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/r.getSize().width,this._contactHardeningLightSizeUVRatio*r.getSize().width,this.frustumEdgeFalloff,e)):(t.setTexture("shadowSampler"+e,this.getShadowMapForRendering()),s._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),this.blurScale/r.getSize().width,this.depthScale,this.frustumEdgeFalloff,e)),s._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(n),this.getLight().getDepthMinZ(n)+this.getLight().getDepthMaxZ(n),e))}getTransformMatrix(){const e=this._scene;if(this._currentRenderId===e.getRenderId()&&this._currentFaceIndexCache===this._currentFaceIndex)return this._transformMatrix;this._currentRenderId=e.getRenderId(),this._currentFaceIndexCache=this._currentFaceIndex;let t=this._light.position;if(this._light.computeTransformedInformation()&&(t=this._light.transformedPosition),i.P.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex),this._lightDirection),1===Math.abs(i.P.Dot(this._lightDirection,i.P.Up()))&&(this._lightDirection.z=1e-13),this._light.needProjectionMatrixCompute()||!this._cachedPosition||!this._cachedDirection||!t.equals(this._cachedPosition)||!this._lightDirection.equals(this._cachedDirection)){this._cachedPosition.copyFrom(t),this._cachedDirection.copyFrom(this._lightDirection),i.y3.LookAtLHToRef(t,t.add(this._lightDirection),i.P.Up(),this._viewMatrix);const e=this.getShadowMap();if(e){const t=e.renderList;t&&this._light.setShadowProjectionMatrix(this._projectionMatrix,this._viewMatrix,t)}this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)}return this._transformMatrix}recreateShadowMap(){const e=this._shadowMap;if(!e)return;const t=e.renderList;if(this._disposeRTTandPostProcesses(),this._initializeGenerator(),this.filter=this._filter,this._applyFilterValues(),t){this._shadowMap.renderList||(this._shadowMap.renderList=[]);for(const e of t)this._shadowMap.renderList.push(e)}else this._shadowMap.renderList=null}_disposeBlurPostProcesses(){this._shadowMap2&&(this._shadowMap2.dispose(),this._shadowMap2=null),this._boxBlurPostprocess&&(this._boxBlurPostprocess.dispose(),this._boxBlurPostprocess=null),this._kernelBlurXPostprocess&&(this._kernelBlurXPostprocess.dispose(),this._kernelBlurXPostprocess=null),this._kernelBlurYPostprocess&&(this._kernelBlurYPostprocess.dispose(),this._kernelBlurYPostprocess=null),this._blurPostProcesses=[]}_disposeRTTandPostProcesses(){this._shadowMap&&(this._shadowMap.dispose(),this._shadowMap=null),this._disposeBlurPostProcesses()}_disposeSceneUBOs(){if(this._sceneUBOs){for(const e of this._sceneUBOs)e.dispose();this._sceneUBOs=[]}}dispose(){this._disposeRTTandPostProcesses(),this._disposeSceneUBOs(),this._light&&(this._light._shadowGenerator=null,this._light._markMeshesAsLightDirty()),this.onBeforeShadowMapRenderMeshObservable.clear(),this.onBeforeShadowMapRenderObservable.clear(),this.onAfterShadowMapRenderMeshObservable.clear(),this.onAfterShadowMapRenderObservable.clear()}serialize(){const e={},t=this.getShadowMap();if(!t)return e;if(e.className=this.getClassName(),e.lightId=this._light.id,e.id=this.id,e.mapSize=t.getRenderSize(),e.forceBackFacesOnly=this.forceBackFacesOnly,e.darkness=this.getDarkness(),e.transparencyShadow=this._transparencyShadow,e.frustumEdgeFalloff=this.frustumEdgeFalloff,e.bias=this.bias,e.normalBias=this.normalBias,e.usePercentageCloserFiltering=this.usePercentageCloserFiltering,e.useContactHardeningShadow=this.useContactHardeningShadow,e.contactHardeningLightSizeUVRatio=this.contactHardeningLightSizeUVRatio,e.filteringQuality=this.filteringQuality,e.useExponentialShadowMap=this.useExponentialShadowMap,e.useBlurExponentialShadowMap=this.useBlurExponentialShadowMap,e.useCloseExponentialShadowMap=this.useBlurExponentialShadowMap,e.useBlurCloseExponentialShadowMap=this.useBlurExponentialShadowMap,e.usePoissonSampling=this.usePoissonSampling,e.depthScale=this.depthScale,e.blurBoxOffset=this.blurBoxOffset,e.blurKernel=this.blurKernel,e.blurScale=this.blurScale,e.useKernelBlur=this.useKernelBlur,e.renderList=[],t.renderList)for(let s=0;s<t.renderList.length;s++){const i=t.renderList[s];e.renderList.push(i.id)}return e}static Parse(e,t,s){const i=t.getLightById(e.lightId),n=s?s(e.mapSize,i):new M(e.mapSize,i),r=n.getShadowMap();for(let s=0;s<e.renderList.length;s++)t.getMeshesById(e.renderList[s]).forEach((function(e){r&&(r.renderList||(r.renderList=[]),r.renderList.push(e))}));return void 0!==e.id&&(n.id=e.id),n.forceBackFacesOnly=!!e.forceBackFacesOnly,void 0!==e.darkness&&n.setDarkness(e.darkness),e.transparencyShadow&&n.setTransparencyShadow(!0),void 0!==e.frustumEdgeFalloff&&(n.frustumEdgeFalloff=e.frustumEdgeFalloff),void 0!==e.bias&&(n.bias=e.bias),void 0!==e.normalBias&&(n.normalBias=e.normalBias),e.usePercentageCloserFiltering?n.usePercentageCloserFiltering=!0:e.useContactHardeningShadow?n.useContactHardeningShadow=!0:e.usePoissonSampling?n.usePoissonSampling=!0:e.useExponentialShadowMap?n.useExponentialShadowMap=!0:e.useBlurExponentialShadowMap?n.useBlurExponentialShadowMap=!0:e.useCloseExponentialShadowMap?n.useCloseExponentialShadowMap=!0:e.useBlurCloseExponentialShadowMap?n.useBlurCloseExponentialShadowMap=!0:e.useVarianceShadowMap?n.useExponentialShadowMap=!0:e.useBlurVarianceShadowMap&&(n.useBlurExponentialShadowMap=!0),void 0!==e.contactHardeningLightSizeUVRatio&&(n.contactHardeningLightSizeUVRatio=e.contactHardeningLightSizeUVRatio),void 0!==e.filteringQuality&&(n.filteringQuality=e.filteringQuality),e.depthScale&&(n.depthScale=e.depthScale),e.blurScale&&(n.blurScale=e.blurScale),e.blurBoxOffset&&(n.blurBoxOffset=e.blurBoxOffset),e.useKernelBlur&&(n.useKernelBlur=e.useKernelBlur),e.blurKernel&&(n.blurKernel=e.blurKernel),n}}M.CLASSNAME="ShadowGenerator",M.FILTER_NONE=0,M.FILTER_EXPONENTIALSHADOWMAP=1,M.FILTER_POISSONSAMPLING=2,M.FILTER_BLUREXPONENTIALSHADOWMAP=3,M.FILTER_CLOSEEXPONENTIALSHADOWMAP=4,M.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP=5,M.FILTER_PCF=6,M.FILTER_PCSS=7,M.QUALITY_HIGH=0,M.QUALITY_MEDIUM=1,M.QUALITY_LOW=2,M.DEFAULT_ALPHA_CUTOFF=.5,M._SceneComponentInitialization=e=>{throw(0,_.S)("ShadowGeneratorSceneComponent")}},1723:(e,t,s)=>{s.d(t,{w:()=>a});var i=s(6070),n=s(6089),r=s(4686);s(4863).p.AddParser(r.l.NAME_SHADOWGENERATOR,((e,t)=>{if(void 0!==e.shadowGenerators&&null!==e.shadowGenerators)for(let s=0,r=e.shadowGenerators.length;s<r;s++){const r=e.shadowGenerators[s];r.className===n.R.CLASSNAME?n.R.Parse(r,t):i.u.Parse(r,t)}}));class a{constructor(e){this.name=r.l.NAME_SHADOWGENERATOR,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(r.l.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(e){e.shadowGenerators=[];const t=this.scene.lights;for(const s of t){const t=s.getShadowGenerator();t&&e.shadowGenerators.push(t.serialize())}}addFromContainer(e){}removeFromContainer(e,t){}dispose(){}_gatherRenderTargets(e){const t=this.scene;if(this.scene.shadowsEnabled)for(let s=0;s<t.lights.length;s++){const i=t.lights[s],n=i.getShadowGenerator();if(i.isEnabled()&&i.shadowEnabled&&n){const s=n.getShadowMap();-1!==t.textures.indexOf(s)&&e.push(s)}}}}i.u._SceneComponentInitialization=e=>{let t=e._getComponent(r.l.NAME_SHADOWGENERATOR);t||(t=new a(e),e._addComponent(t))}},889:(e,t,s)=>{s.d(t,{j:()=>r});var i=s(1984),n=s(8740);class r extends n.d{constructor(e){super(e)}get depthRenderer(){return this._depthRenderer}setDepthRenderer(e=null,t=2,s=!0){const n=this._camera.getScene();this._depthRenderer&&(delete n._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),null===e&&(n._depthRenderer||(n._depthRenderer={}),(e=this._depthRenderer=new i.g(n,t,this._camera,!1,1)).enabled=!1,this._depthRendererId="minmax"+this._camera.id,n._depthRenderer[this._depthRendererId]=e),super.setSourceTexture(e.getDepthMap(),!0,t,s)}setSourceTexture(e,t,s=2,i=!0){super.setSourceTexture(e,t,s,i)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(e=!0){if(super.dispose(e),this._depthRenderer&&e){const e=this._depthRenderer.getDepthMap().getScene();e&&delete e._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null}}}},8740:(e,t,s)=>{s.d(t,{d:()=>a});var i=s(4673),n=s(1932),r=s(3114);s(3127).v.ShadersStore.minmaxReduxPixelShader="varying vec2 vUV;\nuniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform sampler2D sourceTexture;\nuniform vec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*(texSize-1.0));\nfloat f1=texelFetch(sourceTexture,coord,0).r;\nfloat f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;\nfloat f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;\nfloat f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;\nfloat minz=min(min(min(f1,f2),f3),f4);\n#ifdef DEPTH_REDUX\nfloat maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#else\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(MAIN)\nuniform vec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*(texSize-1.0));\nvec2 f1=texelFetch(textureSampler,coord,0).rg;\nvec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;\nvec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;\nvec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;\nfloat minz=min(min(min(f1.x,f2.x),f3.x),f4.x);\nfloat maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*vec2(texSize-1));\nvec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;\nvec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;\nvec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;\nvec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;\nfloat minz=min(f1.x,f2.x);\nfloat maxz=max(f1.y,f2.y);\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(LAST)\nvoid main(void)\n{\nglFragColor=vec4(0.);\nif (true) { \ndiscard;\n}\n}\n#endif\n";class a{constructor(e){this.onAfterReductionPerformed=new i.y$,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=e,this._postProcessManager=new r.O(e.getScene()),this._onContextRestoredObserver=e.getEngine().onContextRestoredObservable.add((()=>{this._postProcessManager._rebuild()}))}get sourceTexture(){return this._sourceTexture}setSourceTexture(e,t,s=2,i=!0){if(e===this._sourceTexture)return;this.dispose(!1),this._sourceTexture=e,this._reductionSteps=[],this._forceFullscreenViewport=i;const r=this._camera.getScene(),a=new n.D("Initial reduction phase","minmaxRedux",["texSize"],["sourceTexture"],1,null,1,r.getEngine(),!1,"#define INITIAL"+(t?"\n#define DEPTH_REDUX":""),s,void 0,void 0,void 0,7);a.autoClear=!1,a.forceFullscreenViewport=i;let o=this._sourceTexture.getRenderWidth(),h=this._sourceTexture.getRenderHeight();a.onApply=((e,t)=>s=>{s.setTexture("sourceTexture",this._sourceTexture),s.setFloat2("texSize",e,t)})(o,h),this._reductionSteps.push(a);let d=1;for(;o>1||h>1;){o=Math.max(Math.round(o/2),1),h=Math.max(Math.round(h/2),1);const e=new n.D("Reduction phase "+d,"minmaxRedux",["texSize"],null,{width:o,height:h},null,1,r.getEngine(),!1,"#define "+(1==o&&1==h?"LAST":1==o||1==h?"ONEBEFORELAST":"MAIN"),s,void 0,void 0,void 0,7);if(e.autoClear=!1,e.forceFullscreenViewport=i,e.onApply=((e,t)=>s=>{1==e||1==t?s.setInt2("texSize",e,t):s.setFloat2("texSize",e,t)})(o,h),this._reductionSteps.push(e),d++,1==o&&1==h){const t=(e,t,s)=>{const i=new Float32Array(4*e*t),n={min:0,max:0};return()=>{r.getEngine()._readTexturePixels(s.inputTexture.texture,e,t,-1,0,i,!1),n.min=i[0],n.max=i[1],this.onAfterReductionPerformed.notifyObservers(n)}};e.onAfterRenderObservable.add(t(o,h,e))}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(e){this._sourceTexture&&(this._sourceTexture.refreshRate=e)}get activated(){return this._activated}activate(){!this._onAfterUnbindObserver&&this._sourceTexture&&(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add((()=>{var e,t;const s=this._camera.getScene().getEngine();null===(e=s._debugPushGroup)||void 0===e||e.call(s,"min max reduction",1),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport),s.unBindFramebuffer(this._reductionSteps[0].inputTexture,!1),null===(t=s._debugPopGroup)||void 0===t||t.call(s,1)})),this._activated=!0)}deactivate(){this._onAfterUnbindObserver&&this._sourceTexture&&(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(e=!0){if(e&&(this.onAfterReductionPerformed.clear(),this._onContextRestoredObserver&&(this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)),this.deactivate(),this._reductionSteps){for(let e=0;e<this._reductionSteps.length;++e)this._reductionSteps[e].dispose();this._reductionSteps=null}this._postProcessManager&&e&&this._postProcessManager.dispose(),this._sourceTexture=null}}},1984:(e,t,s)=>{s.d(t,{g:()=>c});var i=s(9859),n=s(7959),r=s(4684),a=s(3073),o=s(6721),h=s(5593),d=s(3127);s(3476),s(2310),s(8380);d.v.ShadersStore.depthPixelShader="#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n}",s(7992);var l=s(9938);class c{constructor(e,t=1,s=null,n=!1,d=r.x.TRILINEAR_SAMPLINGMODE){this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this._scene=e,this._storeNonLinearDepth=n,this.isPacked=0===t,this.isPacked?this._clearColor=new i.HE(1,1,1,1):this._clearColor=new i.HE(1,0,0,1),c._SceneComponentInitialization(this._scene);const l=e.getEngine();this._camera=s,d!==r.x.NEAREST_SAMPLINGMODE&&(1!==t||l._caps.textureFloatLinearFiltering||(d=r.x.NEAREST_SAMPLINGMODE),2!==t||l._caps.textureHalfFloatLinearFiltering||(d=r.x.NEAREST_SAMPLINGMODE));const u=this.isPacked||!l._features.supportExtendedTextureFormats?5:6;this._depthMap=new a._("DepthRenderer",{width:l.getRenderWidth(),height:l.getRenderHeight()},this._scene,!1,!0,t,!1,d,void 0,void 0,void 0,u),this._depthMap.wrapU=r.x.CLAMP_ADDRESSMODE,this._depthMap.wrapV=r.x.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add((e=>{e.clear(this._clearColor,!0,!0,!0)})),this._depthMap.onBeforeBindObservable.add((()=>{var e;null===(e=l._debugPushGroup)||void 0===e||e.call(l,"depth renderer",1)})),this._depthMap.onAfterUnbindObservable.add((()=>{var e;null===(e=l._debugPopGroup)||void 0===e||e.call(l,1)})),this._depthMap.customIsReadyFunction=(e,t,s)=>{if((s||0===t)&&e.subMeshes)for(let t=0;t<e.subMeshes.length;++t){const s=e.subMeshes[t],i=s.getRenderingMesh(),n=i._getInstancesRenderList(s._id,!!s.getReplacementMesh()),r=l.getCaps().instancedArrays&&(null!==n.visibleInstances[s._id]&&void 0!==n.visibleInstances[s._id]||i.hasThinInstances);if(!this.isReady(s,r))return!1}return!0};const _=e=>{var t,s;const i=e.getRenderingMesh(),n=e.getEffectiveMesh(),r=this._scene,a=r.getEngine(),d=e.getMaterial();if(n._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!d||n.infiniteDistance||d.disableDepthWrite||0===e.verticesCount||e._renderId===r.getRenderId())return;const l=n._getWorldMatrixDeterminant()<0;let c=null!==(t=i.overrideMaterialSideOrientation)&&void 0!==t?t:d.sideOrientation;l&&(c=0===c?1:0);const u=0===c;a.setState(d.backFaceCulling,0,!1,u,d.cullBackFaces);const _=i._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(_.mustReturn)return;const p=a.getCaps().instancedArrays&&(null!==_.visibleInstances[e._id]&&void 0!==_.visibleInstances[e._id]||i.hasThinInstances),f=this._camera||r.activeCamera;if(this.isReady(e,p)&&f){e._renderId=r.getRenderId();const t=null===(s=n._internalAbstractMeshDataInfo._materialForRenderPass)||void 0===s?void 0:s[a.currentRenderPassId];let l=e._getDrawWrapper();!l&&t&&(l=t._getDrawWrapper());const c=f.mode===h.V.ORTHOGRAPHIC_CAMERA;if(!l)return;const u=l.effect;let S,M;if(a.enableEffect(l),p||i._bind(e,u,d.fillMode),t?t.bindForSubMesh(n.getWorldMatrix(),n,e):(u.setMatrix("viewProjection",r.getTransformMatrix()),u.setMatrix("world",n.getWorldMatrix())),c?(S=!a.useReverseDepthBuffer&&a.isNDCHalfZRange?0:1,M=a.useReverseDepthBuffer&&a.isNDCHalfZRange?0:1):(S=a.useReverseDepthBuffer&&a.isNDCHalfZRange?f.minZ:a.isNDCHalfZRange?0:f.minZ,M=a.useReverseDepthBuffer&&a.isNDCHalfZRange?0:f.maxZ),u.setFloat2("depthValues",S,S+M),!t){if(d&&d.needAlphaTesting()){const e=d.getAlphaTestTexture();e&&(u.setTexture("diffuseSampler",e),u.setMatrix("diffuseMatrix",e.getTextureMatrix()))}if(i.useBones&&i.computeBonesUsingShaders&&i.skeleton){const e=i.skeleton;if(e.isUsingTextureForMatrices){const t=e.getTransformMatrixTexture(i);if(!t)return;u.setTexture("boneSampler",t),u.setFloat("boneTextureWidth",4*(e.bones.length+1))}else u.setMatrices("mBones",e.getTransformMatrices(i))}o.G.BindClipPlane(u,r),o.G.BindMorphTargetParameters(i,u),i.morphTargetManager&&i.morphTargetManager.isUsingTextureForTargets&&i.morphTargetManager._bind(u)}i._processRendering(n,e,u,d.fillMode,_,p,((e,t)=>u.setMatrix("world",t)))}};this._depthMap.customRenderFunction=(e,t,s,i)=>{let n;if(i.length)for(n=0;n<i.length;n++)_(i.data[n]);for(n=0;n<e.length;n++)_(e.data[n]);for(n=0;n<t.length;n++)_(t.data[n]);if(this.forceDepthWriteTransparentMeshes)for(n=0;n<s.length;n++)_(s.data[n]);else for(n=0;n<s.length;n++)s.data[n].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}setMaterialForRendering(e,t){this._depthMap.setMaterialForRendering(e,t)}isReady(e,t){var s;const i=this._scene.getEngine(),r=e.getMesh(),a=r.getScene(),h=null===(s=r._internalAbstractMeshDataInfo._materialForRenderPass)||void 0===s?void 0:s[i.currentRenderPassId];if(h)return h.isReadyForSubMesh(r,e,t);const d=e.getMaterial();if(!d||d.disableDepthWrite)return!1;const l=[],c=[n.o.PositionKind];if(d&&d.needAlphaTesting()&&d.getAlphaTestTexture()&&(l.push("#define ALPHATEST"),r.isVerticesDataPresent(n.o.UVKind)&&(c.push(n.o.UVKind),l.push("#define UV1")),r.isVerticesDataPresent(n.o.UV2Kind)&&(c.push(n.o.UV2Kind),l.push("#define UV2"))),r.useBones&&r.computeBonesUsingShaders){c.push(n.o.MatricesIndicesKind),c.push(n.o.MatricesWeightsKind),r.numBoneInfluencers>4&&(c.push(n.o.MatricesIndicesExtraKind),c.push(n.o.MatricesWeightsExtraKind)),l.push("#define NUM_BONE_INFLUENCERS "+r.numBoneInfluencers),l.push("#define BonesPerMesh "+(r.skeleton?r.skeleton.bones.length+1:0));const t=e.getRenderingMesh().skeleton;(null==t?void 0:t.isUsingTextureForMatrices)&&l.push("#define BONETEXTURE")}else l.push("#define NUM_BONE_INFLUENCERS 0");const u=r.morphTargetManager;let _=0;u&&u.numInfluencers>0&&(_=u.numInfluencers,l.push("#define MORPHTARGETS"),l.push("#define NUM_MORPH_INFLUENCERS "+_),u.isUsingTextureForTargets&&l.push("#define MORPHTARGETS_TEXTURE"),o.G.PrepareAttributesForMorphTargetsInfluencers(c,r,_)),t&&(l.push("#define INSTANCES"),o.G.PushAttributesForInstances(c),e.getRenderingMesh().hasThinInstances&&l.push("#define THIN_INSTANCES")),this._storeNonLinearDepth&&l.push("#define NONLINEARDEPTH"),this.isPacked&&l.push("#define PACKED"),a.clipPlane&&l.push("#define CLIPPLANE"),a.clipPlane2&&l.push("#define CLIPPLANE2"),a.clipPlane3&&l.push("#define CLIPPLANE3"),a.clipPlane4&&l.push("#define CLIPPLANE4"),a.clipPlane5&&l.push("#define CLIPPLANE5"),a.clipPlane6&&l.push("#define CLIPPLANE6");const p=e._getDrawWrapper(void 0,!0),f=p.defines,S=l.join("\n");return f!==S&&p.setEffect(i.createEffect("depth",c,["world","mBones","boneTextureWidth","viewProjection","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetTextureInfo","morphTargetTextureIndices","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6"],["diffuseSampler","morphTargets","boneSampler"],S,void 0,void 0,void 0,{maxSimultaneousMorphTargets:_}),S),p.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const e=[];for(const t in this._scene._depthRenderer)this._scene._depthRenderer[t]===this&&e.push(t);if(e.length>0){this._depthMap.dispose();for(const t of e)delete this._scene._depthRenderer[t]}}}c._SceneComponentInitialization=e=>{throw(0,l.S)("DepthRendererSceneComponent")}},7992:(e,t,s)=>{var i=s(3127);s(1041),s(3652),s(1279),s(6409),s(2475),s(3816),s(6842),s(4608),s(7154),s(6886),s(4120),s(1252);i.v.ShadersStore.depthVertexShader="attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nuniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvarying float vDepthMetric;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}\n"},2106:(e,t,s)=>{s(3127).v.ShadersStore.depthBoxBlurPixelShader="varying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 screenSize;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\nvec4 colorDepth=vec4(0.0);\nfor (int x=-OFFSET; x<=OFFSET; x++)\nfor (int y=-OFFSET; y<=OFFSET; y++)\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\n}"},1358:(e,t,s)=>{var i=s(3127);s(2310);i.v.IncludesShadersStore.bayerDitherFunctions="float bayerDither2(vec2 _P) {\nreturn mod(2.0*_P.y+_P.x+1.0,4.0);\n}\nfloat bayerDither4(vec2 _P) {\nvec2 P1=mod(_P,2.0); \nvec2 P2=floor(0.5*mod(_P,4.0)); \nreturn 4.0*bayerDither2(P1)+bayerDither2(P2);\n}\nfloat bayerDither8(vec2 _P) {\nvec2 P1=mod(_P,2.0); \nvec2 P2=floor(0.5 *mod(_P,4.0)); \nvec2 P4=floor(0.25*mod(_P,8.0)); \nreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);\n}\n";i.v.IncludesShadersStore.shadowMapFragmentExtraDeclaration="#if SM_FLOAT==0\n#include<packingFunctions>\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#include<bayerDitherFunctions>\nuniform float softTransparentShadowSM;\n#endif\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE==1\nuniform vec3 lightDataSM;\nvarying vec3 vPositionWSM;\n#endif\nuniform vec3 biasAndScaleSM;\nuniform vec2 depthValuesSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying float zSM;\n#endif\n",s(3476),s(8380);i.v.IncludesShadersStore.shadowMapFragment="float depthSM=vDepthMetricSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\n#if SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\ndepthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\ndepthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_FragDepth=clamp(1.0-depthSM,0.0,1.0);\n#else\ngl_FragDepth=clamp(depthSM,0.0,1.0); \n#endif\n#elif SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#if SM_ESM==1\ndepthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);\n#endif\n#if SM_FLOAT==1\ngl_FragColor=vec4(depthSM,1.0,1.0,1.0);\n#else\ngl_FragColor=pack(depthSM);\n#endif\nreturn;";i.v.ShadersStore.shadowMapPixelShader="#include<shadowMapFragmentExtraDeclaration>\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nfloat alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;\nif (alphaFromAlphaTexture<ALPHATESTVALUE)\ndiscard;\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#ifdef ALPHATEST\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;\n#else\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;\n#endif\n#endif\n#include<shadowMapFragment>\n}"},7827:(e,t,s)=>{var i=s(3127);s(1041),s(3652),s(1279),s(6409),s(2339);i.v.IncludesShadersStore.sceneVertexDeclaration="uniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec4 vEyePosition;\n";i.v.IncludesShadersStore.meshVertexDeclaration="uniform mat4 world;\nuniform float visibility;\n";i.v.IncludesShadersStore.shadowMapVertexDeclaration="#include<sceneVertexDeclaration>\n#include<meshVertexDeclaration>\n",s(1233),s(7234);i.v.IncludesShadersStore.shadowMapUboDeclaration="layout(std140,column_major) uniform;\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n";i.v.IncludesShadersStore.shadowMapVertexExtraDeclaration="#if SM_NORMALBIAS==1\nuniform vec3 lightDataSM;\n#endif\nuniform vec3 biasAndScaleSM;\nuniform vec2 depthValuesSM;\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE==1\nvarying vec3 vPositionWSM;\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying float zSM;\n#endif\n",s(2475),s(6842),s(4608),s(7154),s(6886),s(4120);i.v.IncludesShadersStore.shadowMapVertexNormalBias="#if SM_NORMALBIAS==1\n#if SM_DIRECTIONINLIGHTDATA==1\nvec3 worldLightDirSM=normalize(-lightDataSM.xyz);\n#else\nvec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;\nvec3 worldLightDirSM=normalize(directionToLightSM);\n#endif\nfloat ndlSM=dot(vNormalW,worldLightDirSM);\nfloat sinNLSM=sqrt(1.0-ndlSM*ndlSM);\nfloat normalBiasSM=biasAndScaleSM.y*sinNLSM;\nworldPos.xyz-=vNormalW*normalBiasSM;\n#endif\n";i.v.IncludesShadersStore.shadowMapVertexMetric="#if SM_USEDISTANCE==1\nvPositionWSM=worldPos.xyz;\n#endif\n#if SM_DEPTHTEXTURE==1\n#ifdef IS_NDC_HALF_ZRANGE\n#define BIASFACTOR 0.5\n#else\n#define BIASFACTOR 1.0\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\n#else\ngl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\n#endif\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nzSM=gl_Position.z;\ngl_Position.z=0.0;\n#elif SM_USEDISTANCE==0\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\nvDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#endif\n",s(1252);i.v.ShadersStore.shadowMapVertexShader="attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#endif\n#include<helperFunctions>\n#include<__decl__shadowMapVertex>\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<shadowMapVertexExtraDeclaration>\n#include<clipPlaneVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normWorldSM=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));\nvNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvec3 vNormalW=normalize(normWorldSM*normalUpdated);\n#endif\n#endif\n#include<shadowMapVertexNormalBias>\ngl_Position=viewProjection*worldPos;\n#include<shadowMapVertexMetric>\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<clipPlaneVertex>\n}"}}]);
//# sourceMappingURL=723.babylonBundle.js.map