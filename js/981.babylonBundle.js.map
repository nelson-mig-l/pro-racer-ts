{"version":3,"file":"js/981.babylonBundle.js","mappings":"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","sources":["webpack://pro-racer/../lts/core/generated/Meshes/Builders/groundBuilder.ts","webpack://pro-racer/../lts/core/generated/Meshes/Builders/sphereBuilder.ts","webpack://pro-racer/../lts/core/generated/Meshes/groundMesh.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ground\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n *  - width the width (x direction) of the ground, optional, default 1\r\n *  - height the height (z direction) of the ground, optional, default 1\r\n *  - subdivisions the number of subdivisions per side, optional, default 1\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.subdivisionsX\r\n * @param options.subdivisionsY\r\n * @returns the VertexData of the Ground\r\n */\r\nexport function CreateGroundVertexData(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row: number, col: number;\r\n\r\n    const width: number = options.width || 1;\r\n    const height: number = options.height || 1;\r\n    const subdivisionsX: number = options.subdivisionsX || options.subdivisions || 1;\r\n    const subdivisionsY: number = options.subdivisionsY || options.subdivisions || 1;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            const position = new Vector3((col * width) / subdivisionsX - width / 2.0, 0, ((subdivisionsY - row) * height) / subdivisionsY - height / 2.0);\r\n            const normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n * * xmin the ground minimum X coordinate, optional, default -1\r\n * * zmin the ground minimum Z coordinate, optional, default -1\r\n * * xmax the ground maximum X coordinate, optional, default 1\r\n * * zmax the ground maximum Z coordinate, optional, default 1\r\n * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n * @param options.xmin\r\n * @param options.zmin\r\n * @param options.xmax\r\n * @param options.zmax\r\n * @param options.subdivisions\r\n * @param options.subdivisions.w\r\n * @param options.subdivisions.h\r\n * @param options.precision\r\n * @param options.precision.w\r\n * @param options.precision.h\r\n * @returns the VertexData of the TiledGround\r\n */\r\nexport function CreateTiledGroundVertexData(options: {\r\n    xmin: number;\r\n    zmin: number;\r\n    xmax: number;\r\n    zmax: number;\r\n    subdivisions?: { w: number; h: number };\r\n    precision?: { w: number; h: number };\r\n}): VertexData {\r\n    const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\r\n    const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\r\n    const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\r\n    const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\r\n    const subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    const precision = options.precision || { w: 1, h: 1 };\r\n\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n    let row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\r\n    subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\r\n    precision.w = precision.w < 1 ? 1 : precision.w;\r\n    precision.h = precision.h < 1 ? 1 : precision.h;\r\n\r\n    const tileSize = {\r\n        w: (xmax - xmin) / subdivisions.w,\r\n        h: (zmax - zmin) / subdivisions.h,\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        const base = positions.length / 3;\r\n        const rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        const position = Vector3.Zero();\r\n        const normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData of the Ground designed from a heightmap\r\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n * * width the width (x direction) of the ground\r\n * * height the height (z direction) of the ground\r\n * * subdivisions the number of subdivisions per side\r\n * * minHeight the minimum altitude on the ground, optional, default 0\r\n * * maxHeight the maximum altitude on the ground, optional default 1\r\n * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n * * buffer the array holding the image color data\r\n * * bufferWidth the width of image\r\n * * bufferHeight the height of image\r\n * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.minHeight\r\n * @param options.maxHeight\r\n * @param options.colorFilter\r\n * @param options.buffer\r\n * @param options.bufferWidth\r\n * @param options.bufferHeight\r\n * @param options.alphaFilter\r\n * @returns the VertexData of the Ground designed from a heightmap\r\n */\r\nexport function CreateGroundFromHeightMapVertexData(options: {\r\n    width: number;\r\n    height: number;\r\n    subdivisions: number;\r\n    minHeight: number;\r\n    maxHeight: number;\r\n    colorFilter: Color3;\r\n    buffer: Uint8Array;\r\n    bufferWidth: number;\r\n    bufferHeight: number;\r\n    alphaFilter: number;\r\n}): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row, col;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    let invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        const temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            const position = new Vector3(\r\n                (col * options.width) / options.subdivisions - options.width / 2.0,\r\n                0,\r\n                ((options.subdivisions - row) * options.height) / options.subdivisions - options.height / 2.0\r\n            );\r\n\r\n            // Compute height\r\n            const heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            const heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n\r\n            const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            let r = options.buffer[pos] / 255.0;\r\n            let g = options.buffer[pos + 1] / 255.0;\r\n            let b = options.buffer[pos + 2] / 255.0;\r\n            const a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            const gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            } else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\r\n            const idx2 = col + 1 + row * (options.subdivisions + 1);\r\n            const idx3 = col + row * (options.subdivisions + 1);\r\n            const idx4 = col + (row + 1) * (options.subdivisions + 1);\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh\r\n * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.subdivisionsX\r\n * @param options.subdivisionsY\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n */\r\nexport function CreateGround(\r\n    name: string,\r\n    options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number; updatable?: boolean } = {},\r\n    scene?: Scene\r\n): GroundMesh {\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._setReady(false);\r\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n    ground._width = options.width || 1;\r\n    ground._height = options.height || 1;\r\n    ground._maxX = ground._width / 2;\r\n    ground._maxZ = ground._height / 2;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    const vertexData = CreateGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(ground, options.updatable);\r\n\r\n    ground._setReady(true);\r\n\r\n    return ground;\r\n}\r\n\r\n/**\r\n * Creates a tiled ground mesh\r\n * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.xmin\r\n * @param options.zmin\r\n * @param options.xmax\r\n * @param options.zmax\r\n * @param options.subdivisions\r\n * @param options.subdivisions.w\r\n * @param options.subdivisions.h\r\n * @param options.precision\r\n * @param options.precision.w\r\n * @param options.precision.h\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the tiled ground mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n */\r\nexport function CreateTiledGround(\r\n    name: string,\r\n    options: { xmin: number; zmin: number; xmax: number; zmax: number; subdivisions?: { w: number; h: number }; precision?: { w: number; h: number }; updatable?: boolean },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const tiledGround = new Mesh(name, scene);\r\n\r\n    const vertexData = CreateTiledGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n    return tiledGround;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh from a height map\r\n * * The parameter `url` sets the URL of the height map image resource.\r\n * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param url defines the url to the height map\r\n * @param options defines the options used to create the mesh\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.minHeight\r\n * @param options.maxHeight\r\n * @param options.colorFilter\r\n * @param options.alphaFilter\r\n * @param options.updatable\r\n * @param options.onReady\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/babylon101/height_map\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n */\r\nexport function CreateGroundFromHeightMap(\r\n    name: string,\r\n    url: string,\r\n    options: {\r\n        width?: number;\r\n        height?: number;\r\n        subdivisions?: number;\r\n        minHeight?: number;\r\n        maxHeight?: number;\r\n        colorFilter?: Color3;\r\n        alphaFilter?: number;\r\n        updatable?: boolean;\r\n        onReady?: (mesh: GroundMesh) => void;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): GroundMesh {\r\n    const width = options.width || 10.0;\r\n    const height = options.height || 10.0;\r\n    const subdivisions = options.subdivisions || 1 | 0;\r\n    const minHeight = options.minHeight || 0.0;\r\n    const maxHeight = options.maxHeight || 1.0;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    const updatable = options.updatable;\r\n    const onReady = options.onReady;\r\n\r\n    scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._subdivisionsX = subdivisions;\r\n    ground._subdivisionsY = subdivisions;\r\n    ground._width = width;\r\n    ground._height = height;\r\n    ground._maxX = ground._width / 2.0;\r\n    ground._maxZ = ground._height / 2.0;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    ground._setReady(false);\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        const bufferWidth = img.width;\r\n        const bufferHeight = img.height;\r\n\r\n        if (scene!.isDisposed) {\r\n            return;\r\n        }\r\n\r\n        const buffer = <Uint8Array>scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\r\n\r\n        const vertexData = CreateGroundFromHeightMapVertexData({\r\n            width: width,\r\n            height: height,\r\n            subdivisions: subdivisions,\r\n            minHeight: minHeight,\r\n            maxHeight: maxHeight,\r\n            colorFilter: filter,\r\n            buffer: buffer,\r\n            bufferWidth: bufferWidth,\r\n            bufferHeight: bufferHeight,\r\n            alphaFilter: alphaFilter,\r\n        });\r\n\r\n        vertexData.applyToMesh(ground, updatable);\r\n\r\n        //execute ready callback, if set\r\n        if (onReady) {\r\n            onReady(ground);\r\n        }\r\n\r\n        ground._setReady(true);\r\n    };\r\n\r\n    Tools.LoadImage(url, onload, () => {}, scene.offlineProvider);\r\n\r\n    return ground;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const GroundBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGround,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGroundFromHeightMap,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledGround,\r\n};\r\n\r\nVertexData.CreateGround = CreateGroundVertexData;\r\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\r\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\r\n\r\n(Mesh as any).CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        updatable,\r\n    };\r\n\r\n    return CreateGround(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateTiledGround = (\r\n    name: string,\r\n    xmin: number,\r\n    zmin: number,\r\n    xmax: number,\r\n    zmax: number,\r\n    subdivisions: { w: number; h: number },\r\n    precision: { w: number; h: number },\r\n    scene: Scene,\r\n    updatable?: boolean\r\n): Mesh => {\r\n    const options = {\r\n        xmin,\r\n        zmin,\r\n        xmax,\r\n        zmax,\r\n        subdivisions,\r\n        precision,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTiledGround(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateGroundFromHeightMap = (\r\n    name: string,\r\n    url: string,\r\n    width: number,\r\n    height: number,\r\n    subdivisions: number,\r\n    minHeight: number,\r\n    maxHeight: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    onReady?: (mesh: GroundMesh) => void,\r\n    alphaFilter?: number\r\n): GroundMesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        minHeight,\r\n        maxHeight,\r\n        updatable,\r\n        onReady,\r\n        alphaFilter,\r\n    };\r\n\r\n    return CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n","import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.dedupTopBottomIndices\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = options.segments || 32;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\n(Mesh as any).CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n","import type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the ground\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @internal */\r\n    public _subdivisionsX: number;\r\n    /** @internal */\r\n    public _subdivisionsY: number;\r\n    /** @internal */\r\n    public _width: number;\r\n    /** @internal */\r\n    public _height: number;\r\n    /** @internal */\r\n    public _minX: number;\r\n    /** @internal */\r\n    public _maxX: number;\r\n    /** @internal */\r\n    public _minZ: number;\r\n    /** @internal */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes\r\n     * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes\r\n     * to get performance improvements when using an octree.\r\n     * @param chunksCount the number of submeshes the mesh will be divided into\r\n     * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the World system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        const normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        const world = this.getWorldMatrix();\r\n        const tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n     * if the ground has been updated.\r\n     * This can be used in the render loop.\r\n     * @returns the GroundMesh.\r\n     */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        const col = Math.floor(((x + this._maxX) * this._subdivisionsX) / this._width);\r\n        const row = Math.floor((-(z + this._maxZ) * this._subdivisionsY) / this._height + this._subdivisionsY);\r\n        const quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        let facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                const quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        const v1 = TmpVectors.Vector3[3];\r\n        const v2 = TmpVectors.Vector3[2];\r\n        const v3 = TmpVectors.Vector3[1];\r\n        const v4 = TmpVectors.Vector3[0];\r\n        const v1v2 = TmpVectors.Vector3[4];\r\n        const v1v3 = TmpVectors.Vector3[5];\r\n        const v1v4 = TmpVectors.Vector3[6];\r\n        const norm1 = TmpVectors.Vector3[7];\r\n        const norm2 = TmpVectors.Vector3[8];\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        let cd = 0; // 2D slope coefficient : z = cd * x + h\r\n        let h = 0;\r\n        let d1 = 0; // facet plane equation : ax + by + cz + d = 0\r\n        let d2 = 0;\r\n\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x; // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                const quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        const result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n"],"names":["CreateGroundVertexData","options","indices","positions","normals","uvs","row","col","width","height","subdivisionsX","subdivisions","subdivisionsY","position","normal","push","x","y","z","vertexData","CreateTiledGroundVertexData","xmin","undefined","zmin","xmax","zmax","w","h","precision","Array","tileRow","tileCol","tileSize","applyTile","xTileMin","zTileMin","xTileMax","zTileMax","base","length","rowLength","square","CreateGroundFromHeightMapVertexData","filter","colorFilter","alphaFilter","invert","minHeight","maxHeight","temp","pos","bufferWidth","bufferHeight","r","buffer","g","b","a","gradient","idx1","idx2","idx3","idx4","isVisibleIdx1","isVisibleIdx2","isVisibleIdx3","CreateGround","name","scene","ground","_setReady","_subdivisionsX","_subdivisionsY","_width","_height","_maxX","_maxZ","_minX","_minZ","applyToMesh","updatable","CreateTiledGround","tiledGround","CreateGroundFromHeightMap","url","onReady","img","isDisposed","getEngine","resizeImageBitmap","offlineProvider","GroundBuilder","CreateSphereVertexData","segments","diameterX","diameter","diameterY","diameterZ","arc","slice","sideOrientation","dedupTopBottomIndices","radius","totalZRotationSteps","totalYRotationSteps","zRotationStep","normalizedZ","angleZ","Math","PI","yRotationStep","normalizedY","angleY","rotationZ","rotationY","afterRotZ","complete","vertex","multiply","divide","normalize","verticesCount","firstIndex","frontUVs","backUVs","CreateSphere","sphere","_originalBuilderSideOrientation","SphereBuilder","parsedMesh","GroundMesh","Parse","constructor","super","generateOctree","getClassName","min","this","optimize","chunksCount","octreeBlocksSize","subdivide","createOrUpdateSubmeshesOctree","getHeightAtCoordinates","world","getWorldMatrix","invMat","invertToRef","tmpVect","_heightQuads","_initHeightQuads","_computeHeightQuads","facet","_getFacetAt","getNormalAtCoordinates","getNormalAtCoordinatesToRef","ref","tmpMat","updateCoordinateHeights","floor","quad","slope","facet1","facet2","getVerticesData","v1","v2","v3","v4","v1v2","v1v3","v1v4","norm1","norm2","i","j","k","cd","d1","d2","subtractToRef","copyFromFloats","serialize","serializationObject","minX","maxX","minZ","maxZ","static","result"],"sourceRoot":""}