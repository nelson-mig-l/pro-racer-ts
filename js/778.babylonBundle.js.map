{"version":3,"file":"js/778.babylonBundle.js","mappings":"oOA0BA,MAAMA,EAA4B,CAAEC,OAAQ,KAA2BC,QAAS,MA0EzE,MAAMC,UAAuB,IAqDhCC,YAAYC,EAAcC,EAAcC,EAAiBC,EAA2C,CAAC,EAAGC,GAAyB,GAC7HC,MAAML,EAAMC,EAAOG,GAnDf,KAAAE,UAA6C,CAAC,EAC9C,KAAAC,eAAoD,CAAC,EACrD,KAAAC,kBAAyD,CAAC,EAC1D,KAAAC,QAAsC,CAAC,EACvC,KAAAC,MAAoC,CAAC,EACrC,KAAAC,cAA8C,CAAC,EAC/C,KAAAC,SAAuC,CAAC,EACxC,KAAAC,eAA+C,CAAC,EAChD,KAAAC,SAAuC,CAAC,EACxC,KAAAC,eAA+C,CAAC,EAChD,KAAAC,UAAyC,CAAC,EAC1C,KAAAC,UAAyC,CAAC,EAC1C,KAAAC,UAAyC,CAAC,EAC1C,KAAAC,aAA+C,CAAC,EAChD,KAAAC,mBAAmD,CAAC,EACpD,KAAAC,UAAwC,CAAC,EACzC,KAAAC,cAAkE,CAAC,EACnE,KAAAC,aAAiE,CAAC,EAClE,KAAAC,aAAiE,CAAC,EAClE,KAAAC,gBAAgD,CAAC,EACjD,KAAAC,gBAAgD,CAAC,EACjD,KAAAC,gBAAgD,CAAC,EACjD,KAAAC,gBAAqD,CAAC,EACtD,KAAAC,iBAAuD,CAAC,EACxD,KAAAC,gBAAqD,CAAC,EACtD,KAAAC,uBAAyB,IAAI,KAC7B,KAAAC,iCAAmC,IAAI,KACvC,KAAAC,YAAsB,EAyB1BC,KAAKC,YAAcjC,EAEnBgC,KAAKE,SAAW,CACZC,mBAAmB,EACnBC,kBAAkB,EAClBC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CAAC,uBACXC,eAAgB,GAChBC,SAAU,GACVC,iBAAkB,GAClBC,eAAgB,GAChBC,eAAgB,GAChBC,QAAS,GACTC,cAAc,KACX5C,EAEX,CAMWD,iBACP,OAAOgC,KAAKC,WAChB,CAMWjC,eAAWA,GAClBgC,KAAKC,YAAcjC,CACvB,CAMWC,cACP,OAAO+B,KAAKE,QAChB,CAOOY,eACH,MAAO,gBACX,CAMOX,oBACH,OAAOH,KAAKe,MAAQ,GAAOf,KAAKE,SAASC,iBAC7C,CAMOC,mBACH,OAAOJ,KAAKE,SAASE,gBACzB,CAEQY,cAAcC,IACmC,IAAjDjB,KAAKE,SAASI,SAASY,QAAQD,IAC/BjB,KAAKE,SAASI,SAASa,KAAKF,EAEpC,CAQOG,WAAWtD,EAAcuD,GAM5B,OAL8C,IAA1CrB,KAAKE,SAASM,SAASU,QAAQpD,IAC/BkC,KAAKE,SAASM,SAASW,KAAKrD,GAEhCkC,KAAK5B,UAAUN,GAAQuD,EAEhBrB,IACX,CAQOsB,gBAAgBxD,EAAcyD,GASjC,OAR8C,IAA1CvB,KAAKE,SAASM,SAASU,QAAQpD,IAC/BkC,KAAKE,SAASM,SAASW,KAAKrD,GAGhCkC,KAAKgB,cAAclD,GAEnBkC,KAAK3B,eAAeP,GAAQyD,EAErBvB,IACX,CAQOwB,mBAAmB1D,EAAcuD,GAMpC,OALsD,IAAlDrB,KAAKE,SAASO,iBAAiBS,QAAQpD,IACvCkC,KAAKE,SAASO,iBAAiBU,KAAKrD,GAExCkC,KAAK1B,kBAAkBR,GAAQuD,EAExBrB,IACX,CAQOyB,SAAS3D,EAAc4D,GAI1B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKzB,QAAQT,GAAQ4D,EAEd1B,IACX,CAQO2B,OAAO7D,EAAc4D,GAIxB,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKxB,MAAMV,GAAQ4D,EAEZ1B,IACX,CAQO4B,UAAU9D,EAAc4D,GAI3B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKvB,cAAcX,GAAQ4D,EAEpB1B,IACX,CAQO6B,UAAU/D,EAAc4D,GAI3B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKtB,SAASZ,GAAQ4D,EAEf1B,IACX,CAQO8B,eAAehE,EAAc4D,GAMhC,OALA1B,KAAKgB,cAAclD,GACnBkC,KAAKrB,eAAeb,GAAQ4D,EAAMK,QAAO,CAACC,EAAKC,KAC3CA,EAAMC,QAAQF,EAAKA,EAAIG,QAChBH,IACR,IACIhC,IACX,CAQOoC,UAAUtE,EAAc4D,GAI3B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKpB,SAASd,GAAQ4D,EAEf1B,IACX,CAQOqC,eAAevE,EAAc4D,GAMhC,OALA1B,KAAKgB,cAAclD,GACnBkC,KAAKnB,eAAef,GAAQ4D,EAAMK,QAAO,CAACC,EAAKC,KAC3CA,EAAMC,QAAQF,EAAKA,EAAIG,QAChBH,IACR,IACIhC,IACX,CAQOsC,WAAWxE,EAAc4D,GAI5B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKlB,UAAUhB,GAAQ4D,EAEhB1B,IACX,CAQOuC,WAAWzE,EAAc4D,GAI5B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKjB,UAAUjB,GAAQ4D,EAEhB1B,IACX,CAQOwC,WAAW1E,EAAc4D,GAI5B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKhB,UAAUlB,GAAQ4D,EAEhB1B,IACX,CAQOyC,cAAc3E,EAAc4D,GAI/B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKf,aAAanB,GAAQ4D,EAEnB1B,IACX,CAQO0C,mBAAmB5E,EAAc4D,GAMpC,OALA1B,KAAKgB,cAAclD,GACnBkC,KAAKd,mBAAmBpB,GAAQ4D,EAAMK,QAAO,CAACC,EAAKW,KAC/CA,EAAWT,QAAQF,EAAKA,EAAIG,QACrBH,IACR,IACIhC,IACX,CAQO4C,UAAU9E,EAAc4D,GAI3B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKb,UAAUrB,GAAQ4D,EAEhB1B,IACX,CAQO6C,YAAY/E,EAAc4D,GAC7B1B,KAAKgB,cAAclD,GAEnB,MAAMgF,EAAe,IAAIC,aAA4B,GAAfrB,EAAMS,QAE5C,IAAK,IAAIa,EAAQ,EAAGA,EAAQtB,EAAMS,OAAQa,IACvBtB,EAAMsB,GAEdC,YAAYH,EAAsB,GAARE,GAKrC,OAFAhD,KAAKZ,cAActB,GAAQgF,EAEpB9C,IACX,CAQOkD,aAAapF,EAAc4D,GAI9B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKX,aAAavB,GAAQ4D,EAEnB1B,IACX,CAQOmD,aAAarF,EAAc4D,GAI9B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKV,aAAaxB,GAAQ4D,EAEnB1B,IACX,CAQOoD,UAAUtF,EAAc4D,GAI3B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKT,gBAAgBzB,GAAQ4D,EAEtB1B,IACX,CAQOqD,UAAUvF,EAAc4D,GAI3B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKR,gBAAgB1B,GAAQ4D,EAEtB1B,IACX,CAQOsD,UAAUxF,EAAc4D,GAI3B,OAHA1B,KAAKgB,cAAclD,GACnBkC,KAAKP,gBAAgB3B,GAAQ4D,EAEtB1B,IACX,CAQOuD,iBAAiBzF,EAAc0F,GAMlC,OALoD,IAAhDxD,KAAKE,SAASK,eAAeW,QAAQpD,IACrCkC,KAAKE,SAASK,eAAeY,KAAKrD,GAEtCkC,KAAKN,gBAAgB5B,GAAQ0F,EAEtBxD,IACX,CAQOyD,kBAAkB3F,EAAc4F,GAMnC,OALoD,IAAhD1D,KAAKE,SAASQ,eAAeQ,QAAQpD,IACrCkC,KAAKE,SAASQ,eAAeS,KAAKrD,GAEtCkC,KAAKL,iBAAiB7B,GAAQ4F,EAEvB1D,IACX,CAQO2D,iBAAiB7F,EAAc0F,GAMlC,OALoD,IAAhDxD,KAAKE,SAASS,eAAeO,QAAQpD,IACrCkC,KAAKE,SAASS,eAAeQ,KAAKrD,GAEtCkC,KAAKJ,gBAAgB9B,GAAQ0F,EAEtBxD,IACX,CASO4D,kBAAkBC,EAAoBlG,EAAkBmG,GAC3D,OAAO9D,KAAK+D,QAAQF,EAAMC,EAAcnG,EAC5C,CASOoG,QAAQF,EAAqBC,EAAwBnG,G,YACxD,MAAMO,EAAyBP,GAAWqC,KAAKgE,wBAE/C,GAAIhE,KAAKiE,SACL,GAAI/F,GACA,GAAIP,EAAQD,QAAUC,EAAQD,OAAOwG,oBACjC,OAAO,MAER,CACH,MAAMxG,EAASsC,KAAKmE,aAAazG,OACjC,GAAIA,GAAUA,EAAOwG,qBAAuBxG,EAAO0G,+BAAiCN,EAChF,OAAO,C,CAKnB,MAAM/F,EAAQiC,KAAKqE,WACbC,EAASvG,EAAMwG,YAGf3D,EAAU,GACV4D,EAAU,GACVC,EAAY,IAAI,IAEtB,IAAIC,EAAa1E,KAAKC,YAClBK,EAAWN,KAAKE,SAASI,SACzBC,EAAiBP,KAAKE,SAASK,eAC/BC,EAAWR,KAAKE,SAASM,SAGzB8D,EAAOK,UAAUC,WAAa7G,EAAM8G,cAAgB9G,EAAM8G,aAAaC,oBAAsB/G,EAAM8G,aAAaC,mBAAmBC,eAAiB,IACpJ/E,KAAKD,YAAa,EAClBa,EAAQO,KAAK,sBAC6C,IAAtDnB,KAAKE,SAASI,SAASY,QAAQ,oBAAmF,IAAvDlB,KAAKE,SAASI,SAASY,QAAQ,oBAC1FlB,KAAKE,SAASI,SAASa,KAAK,oBAIpC,IAAK,IAAI6B,EAAQ,EAAGA,EAAQhD,KAAKE,SAASU,QAAQuB,OAAQa,IAAS,CAC/D,MAAMgC,EAAkE,IAApDhF,KAAKE,SAASU,QAAQoC,GAAO9B,QAAQ,WAAmBlB,KAAKE,SAASU,QAAQoC,GAAS,WAAWhD,KAAKE,SAASU,QAAQoC,KAC5IpC,EAAQO,KAAK6D,E,CAGjB,IAAK,IAAIhC,EAAQ,EAAGA,EAAQhD,KAAKE,SAASG,WAAW8B,OAAQa,IACzDwB,EAAQrD,KAAKnB,KAAKE,SAASG,WAAW2C,IAqB1C,GAlBIa,GAAQA,EAAKoB,sBAAsB,iBACnCT,EAAQrD,KAAK,eACbP,EAAQO,KAAK,wBAGb2C,IACAlD,EAAQO,KAAK,qBACb,+BAA0CqD,IACtCX,aAAI,EAAJA,EAAMqB,oBACNtE,EAAQO,KAAK,0BACT0C,GAAQA,EAAKoB,sBAAsB,yBACnCT,EAAQrD,KAAK,uBACbP,EAAQO,KAAK,6BAMrB0C,GAAQA,EAAKsB,UAAYtB,EAAKuB,0BAA4BvB,EAAKwB,SAAU,CACzEb,EAAQrD,KAAK,yBACbqD,EAAQrD,KAAK,yBACT0C,EAAKyB,mBAAqB,IAC1Bd,EAAQrD,KAAK,8BACbqD,EAAQrD,KAAK,+BAGjB,MAAMkE,EAAWxB,EAAKwB,SAEtBzE,EAAQO,KAAK,gCAAkC0C,EAAKyB,oBACpDb,EAAUc,uBAAuB,EAAG1B,GAEhCwB,EAASG,2BACT5E,EAAQO,KAAK,wBAE+C,IAAxDnB,KAAKE,SAASI,SAASY,QAAQ,qBAC/BlB,KAAKE,SAASI,SAASa,KAAK,qBAGuB,IAAnDnB,KAAKE,SAASM,SAASU,QAAQ,gBAC/BlB,KAAKE,SAASM,SAASW,KAAK,iBAGhCP,EAAQO,KAAK,yBAA2BkE,EAASI,MAAMtD,OAAS,KAEd,IAA9CnC,KAAKE,SAASI,SAASY,QAAQ,WAC/BlB,KAAKE,SAASI,SAASa,KAAK,U,MAIpCP,EAAQO,KAAK,kCAIjB,IAAIuE,EAAiB,EACrB,MAAMC,EAAU9B,EAAcA,EAAM+B,mBAAqB,KACzD,GAAID,EAAS,CACT,MAAME,EAAKF,EAAQG,cAAmD,IAApClF,EAAQM,QAAQ,eAC5C6E,EAAUJ,EAAQK,mBAA4D,IAAxCpF,EAAQM,QAAQ,mBACtD+E,EAASN,EAAQO,kBAA0D,IAAvCtF,EAAQM,QAAQ,kBAC1DwE,EAAiBC,EAAQD,eACrBG,GACAjF,EAAQO,KAAK,2BAEb4E,GACAnF,EAAQO,KAAK,gCAEb8E,GACArF,EAAQO,KAAK,+BAEbuE,EAAiB,GACjB9E,EAAQO,KAAK,wBAEbwE,EAAQQ,2BACRvF,EAAQO,KAAK,iCAEwD,IAAjEnB,KAAKE,SAASI,SAASY,QAAQ,8BAC/BlB,KAAKE,SAASI,SAASa,KAAK,8BAGwB,IAApDnB,KAAKE,SAASM,SAASU,QAAQ,iBAC/BlB,KAAKE,SAASM,SAASW,KAAK,iBAGpCP,EAAQO,KAAK,iCAAmCuE,GAChD,IAAK,IAAI1C,EAAQ,EAAGA,EAAQ0C,EAAgB1C,IACxCwB,EAAQrD,KAAK,iBAA4B6B,GAErCiD,GACAzB,EAAQrD,KAAK,eAA0B6B,GAGvC+C,GACAvB,EAAQrD,KAAK,gBAA2B6B,GAGxC6C,GACArB,EAAQrD,KAAK,WAAsB,IAAM6B,GAG7C0C,EAAiB,IACjBpF,EAAWA,EAAS8F,QACpB9F,EAASa,KAAK,yBACdb,EAASa,KAAK,0BACdb,EAASa,KAAK,6B,MAGlBP,EAAQO,KAAK,mCAIjB,GAAI0C,EAAM,CACN,MAAMwC,EAAoBxC,EAAMyC,4BAE5BD,GAAcA,EAAWE,YACzB3F,EAAQO,KAAK,2CAC2D,IAApEnB,KAAKE,SAASI,SAASY,QAAQ,iCAC/BlB,KAAKE,SAASI,SAASa,KAAK,iCAEmD,IAA/EnB,KAAKE,SAASI,SAASY,QAAQ,4CAC/BlB,KAAKE,SAASI,SAASa,KAAK,4CAEoC,IAAhEnB,KAAKE,SAASI,SAASY,QAAQ,6BAC/BlB,KAAKE,SAASI,SAASa,KAAK,6BAGuC,IAAnEnB,KAAKE,SAASM,SAASU,QAAQ,gCAC/BlB,KAAKE,SAASM,SAASW,KAAK,gCAIpC,6CAAwDqD,EAASX,EAAMjD,E,CAI3E,IAAK,MAAM9C,KAAQkC,KAAK5B,UACpB,IAAK4B,KAAK5B,UAAUN,GAAMiG,UACtB,OAAO,EAKXF,GAAQ7D,KAAKwG,uBAAuB3C,IACpCjD,EAAQO,KAAK,sBAImB,OAA/BnB,KAAKE,SAASW,cAA2B9C,EAAM0I,WAAczG,KAAKE,SAASW,gBAC5ED,EAAQO,KAAK,sBAC2B,IAApCb,EAASY,QAAQ,eACjBZ,EAASa,KAAK,gBAIc,OAA/BnB,KAAKE,SAASW,cAA2B9C,EAAM2I,YAAe1G,KAAKE,SAASW,gBAC7ED,EAAQO,KAAK,uBAC4B,IAArCb,EAASY,QAAQ,gBACjBZ,EAASa,KAAK,iBAIc,OAA/BnB,KAAKE,SAASW,cAA2B9C,EAAM4I,YAAe3G,KAAKE,SAASW,gBAC7ED,EAAQO,KAAK,uBAC4B,IAArCb,EAASY,QAAQ,gBACjBZ,EAASa,KAAK,iBAIc,OAA/BnB,KAAKE,SAASW,cAA2B9C,EAAM6I,YAAe5G,KAAKE,SAASW,gBAC7ED,EAAQO,KAAK,uBAC4B,IAArCb,EAASY,QAAQ,gBACjBZ,EAASa,KAAK,iBAIc,OAA/BnB,KAAKE,SAASW,cAA2B9C,EAAM8I,YAAe7G,KAAKE,SAASW,gBAC7ED,EAAQO,KAAK,uBAC4B,IAArCb,EAASY,QAAQ,gBACjBZ,EAASa,KAAK,iBAIc,OAA/BnB,KAAKE,SAASW,cAA2B9C,EAAM+I,YAAe9G,KAAKE,SAASW,gBAC7ED,EAAQO,KAAK,uBAC4B,IAArCb,EAASY,QAAQ,gBACjBZ,EAASa,KAAK,gBAIlBnB,KAAK+G,0BACLzG,EAAWA,EAAS8F,QACpB7F,EAAiBA,EAAe6F,QAChC5F,EAAWA,EAAS4F,QACpB1B,EAAa1E,KAAK+G,wBAAwBrC,EAAYpE,EAAUC,EAAgBC,EAAUI,EAAS4D,IAGvG,MAAMwC,EAAc9I,EAAyBP,EAAQsJ,kBAAoBjH,KAAKmE,aACxE+C,EAAoC,QAAnB,EAAAF,aAAW,EAAXA,EAAatJ,cAAM,QAAI,KACxCyJ,EAAsC,QAApB,EAAAH,aAAW,EAAXA,EAAapG,eAAO,QAAI,KAC1CwG,EAAOxG,EAAQwG,KAAK,MAE1B,IAAI1J,EAASwJ,EAkCb,OAjCIC,IAAoBC,IACpB1J,EAAS4G,EAAO+C,aACZ3C,EACwB,CACpBrE,WAAYmE,EACZ8C,cAAehH,EACfiH,oBAAqBhH,EACrBC,SAAUA,EACVI,QAASwG,EACT3C,UAAWA,EACX+C,WAAYxH,KAAKwH,WACjBC,QAASzH,KAAKyH,QACdC,gBAAiB,CAAEC,4BAA6BjC,GAChDkC,eAAgB5H,KAAKE,SAAS0H,gBAElCtD,GAGApG,EACAP,EAAQkK,UAAUnK,EAAQ0J,EAAMpH,KAAK8H,kBAC9Bd,GACPA,EAAYa,UAAUnK,EAAQ0J,GAG9BpH,KAAK+H,6BACLtK,EAA0BC,OAASA,EACnCD,EAA0BE,QAAuC,QAA7B,EAAAA,QAAAA,EAAWkG,aAAI,EAAJA,EAAMmE,UAAU,UAAE,QAAI,KACrEhI,KAAK+H,2BAA2BE,gBAAgBxK,KAIxDC,EAAQ0G,+BAAiCN,EAEnB,QAAlB,IAACpG,aAAM,EAANA,EAAQqG,kBAAS,YAIlBmD,IAAmBxJ,GACnBK,EAAMmK,sBAGVxK,EAAOwG,qBAAsB,GAEtB,EACX,CAOOiE,oBAAoBC,EAAeC,GACtC,MAAMtK,EAAQiC,KAAKqE,WAEb3G,EAAS2K,QAAAA,EAAkBrI,KAAKsI,YAEjC5K,KAI4C,IAA7CsC,KAAKE,SAASI,SAASY,QAAQ,UAC/BxD,EAAOkF,UAAU,QAASwF,IAGuB,IAAjDpI,KAAKE,SAASI,SAASY,QAAQ,eAC/BkH,EAAMG,cAAcxK,EAAMyK,gBAAiBxI,KAAKH,wBAChDnC,EAAOkF,UAAU,YAAa5C,KAAKH,0BAGwB,IAA3DG,KAAKE,SAASI,SAASY,QAAQ,yBAC/BkH,EAAMG,cAAcxK,EAAM0K,qBAAsBzI,KAAKF,kCACrDpC,EAAOkF,UAAU,sBAAuB5C,KAAKF,mCAErD,CAQO4I,eAAeN,EAAevE,EAAYlG,G,MAC7CqC,KAAK2I,KAAKP,EAAOvE,EAAkC,QAA5B,EAAAlG,EAAQiL,4BAAoB,eAAElL,OAAQC,EACjE,CASOgL,KAAKP,EAAevE,EAAawE,EAAmC1K,G,MAEvE,MAAMO,EAAyBP,GAAWqC,KAAKgE,wBACzCtG,EAAS2K,QAAAA,EAAmBnK,EAAyBP,EAAQD,OAASsC,KAAKsI,YAEjF,IAAK5K,EACD,OAGJsC,KAAK6I,cAAgBnL,EAErBsC,KAAKmI,oBAAoBC,EAAOC,GAEhC,MAAM9H,EAAiBP,KAAKE,SAASK,eAErC,IAAIuI,GAAc,EAElB,GAAIpL,GAAU6C,GAAkBA,EAAe4B,OAAS,GAAKnC,KAAKqE,WAAWE,YAAYwE,uBACrF,IAAK,IAAIC,EAAI,EAAGA,EAAIzI,EAAe4B,SAAU6G,EAEzC,OADmBzI,EAAeyI,IAE9B,IAAK,OACGnF,IACAA,EAAKoF,uBAAuBC,aAAaxL,EAAQ,QACjDmG,EAAKsF,iBAAiBf,IAE1B,MACJ,IAAK,QACD,2BAAsC1K,EAAQsC,KAAKqE,WAAW+E,yBAC9DpJ,KAAKqE,WAAWgF,mBAChBP,GAAc,EAM9B,MAAMQ,EAAazF,GAAQ3F,EAAyB8B,KAAKuJ,YAAYvJ,KAAKqE,WAAY3G,EAAQmG,EAAK2F,YAAcxJ,KAAKqE,WAAWoF,sBAAwBzJ,KAEzJ,GAAItC,GAAU4L,EAAY,CA0BtB,IAAIxL,EAEJ,IAAKA,KA3BAgL,IAA2D,IAA5C9I,KAAKE,SAASI,SAASY,QAAQ,SAC/CxD,EAAOkF,UAAU,OAAQ5C,KAAKqE,WAAWmE,iBAGxCM,IAAiE,IAAlD9I,KAAKE,SAASI,SAASY,QAAQ,eAC/CxD,EAAOkF,UAAU,aAAc5C,KAAKqE,WAAWqF,uBAG9CZ,IAAqE,IAAtD9I,KAAKE,SAASI,SAASY,QAAQ,oBAC/CxD,EAAOkF,UAAU,iBAAkB5C,KAAKqE,WAAWoE,sBAC/CzI,KAAKD,YACLrC,EAAOkF,UAAU,kBAAmB5C,KAAKqE,WAAWsF,oBAIxD3J,KAAKqE,WAAWQ,eAAsE,IAAtD7E,KAAKE,SAASI,SAASY,QAAQ,mBAC/DxD,EAAO6E,WAAW,iBAAkBvC,KAAKqE,WAAWQ,aAAc+E,gBAItE,wBAAmC/F,EAAMnG,GAGzC,kBAA6BA,EAAQsC,KAAKqE,YAI7BrE,KAAK5B,UACdV,EAAO0D,WAAWtD,EAAMkC,KAAK5B,UAAUN,IAI3C,IAAKA,KAAQkC,KAAK3B,eACdX,EAAO4D,gBAAgBxD,EAAMkC,KAAK3B,eAAeP,IAIrD,IAAKA,KAAQkC,KAAK1B,kBACdZ,EAAO8D,mBAAmB1D,EAAMkC,KAAK1B,kBAAkBR,IAI3D,IAAKA,KAAQkC,KAAKxB,MACdd,EAAOiE,OAAO7D,EAAMkC,KAAKxB,MAAMV,IAInC,IAAKA,KAAQkC,KAAKzB,QACdb,EAAO+D,SAAS3D,EAAMkC,KAAKzB,QAAQT,IAIvC,IAAKA,KAAQkC,KAAKvB,cACdf,EAAOmM,SAAS/L,EAAMkC,KAAKvB,cAAcX,IAI7C,IAAKA,KAAQkC,KAAKtB,SACdhB,EAAOmE,UAAU/D,EAAMkC,KAAKtB,SAASZ,IAIzC,IAAKA,KAAQkC,KAAKrB,eACdjB,EAAO2F,UAAUvF,EAAMkC,KAAKrB,eAAeb,IAI/C,IAAKA,KAAQkC,KAAKpB,SAAU,CACxB,MAAMqD,EAAQjC,KAAKpB,SAASd,GAC5BJ,EAAOoM,UAAUhM,EAAMmE,EAAM8H,EAAG9H,EAAM+H,EAAG/H,EAAMgI,EAAGhI,EAAMiI,E,CAI5D,IAAKpM,KAAQkC,KAAKnB,eACdnB,EAAO4F,UAAUxF,EAAMkC,KAAKnB,eAAef,IAI/C,IAAKA,KAAQkC,KAAKlB,UACdpB,EAAO4E,WAAWxE,EAAMkC,KAAKlB,UAAUhB,IAI3C,IAAKA,KAAQkC,KAAKjB,UACdrB,EAAO6E,WAAWzE,EAAMkC,KAAKjB,UAAUjB,IAI3C,IAAKA,KAAQkC,KAAKhB,UACdtB,EAAO8E,WAAW1E,EAAMkC,KAAKhB,UAAUlB,IAI3C,IAAKA,KAAQkC,KAAKf,aACdvB,EAAO+E,cAAc3E,EAAMkC,KAAKf,aAAanB,IAIjD,IAAKA,KAAQkC,KAAKb,UACdzB,EAAOkF,UAAU9E,EAAMkC,KAAKb,UAAUrB,IAI1C,IAAKA,KAAQkC,KAAKZ,cACd1B,EAAOmF,YAAY/E,EAAMkC,KAAKZ,cAActB,IAIhD,IAAKA,KAAQkC,KAAKX,aACd3B,EAAOwF,aAAapF,EAAMkC,KAAKX,aAAavB,IAIhD,IAAKA,KAAQkC,KAAKV,aACd5B,EAAOyF,aAAarF,EAAMkC,KAAKV,aAAaxB,IAIhD,IAAKA,KAAQkC,KAAKT,gBACd7B,EAAO0F,UAAUtF,EAAMkC,KAAKT,gBAAgBzB,IAIhD,IAAKA,KAAQkC,KAAKR,gBACd9B,EAAO2F,UAAUvF,EAAMkC,KAAKR,gBAAgB1B,IAIhD,IAAKA,KAAQkC,KAAKP,gBACd/B,EAAO4F,UAAUxF,EAAMkC,KAAKP,gBAAgB3B,IAIhD,IAAKA,KAAQkC,KAAKd,mBACdxB,EAAO4F,UAAUxF,EAAMkC,KAAKd,mBAAmBpB,IAInD,IAAKA,KAAQkC,KAAKN,gBAAiB,CAC/B,MAAM8D,EAASxD,KAAKN,gBAAgB5B,GAAMqM,YACtC3G,GACA9F,EAAO0M,kBAAkB5G,EAAQ1F,E,CAKzC,IAAKA,KAAQkC,KAAKL,iBACdjC,EAAO+F,kBAAkB3F,EAAMkC,KAAKL,iBAAiB7B,IAIzD,IAAKA,KAAQkC,KAAKJ,gBACdlC,EAAOiG,iBAAiB7F,EAAMkC,KAAKJ,gBAAgB9B,G,CAI3D,GAAIJ,GAAUmG,IAASyF,IAAetJ,KAAKiE,UAAW,CAElD,MAAM0B,EAAiB9B,EAAM+B,mBACzBD,GAAWA,EAAQD,eAAiB,GACpC,8BAA+C7B,EAAMnG,GAGzD,MAAM2I,EAAoBxC,EAAMyC,4BAE5BD,GAAcA,EAAWE,YACO,QAAhC,EAAA1C,EAAKyC,mCAA2B,SAAEqC,KAAKjL,IAAUA,EAAO0G,8B,CAIhEpE,KAAKqK,WAAWxG,EAAMnG,EAC1B,CAMO4M,oBACH,MAAMC,EAAiBpM,MAAMmM,oBAE7B,IAAK,MAAMxM,KAAQkC,KAAK5B,UACpBmM,EAAepJ,KAAKnB,KAAK5B,UAAUN,IAGvC,IAAK,MAAMA,KAAQkC,KAAK3B,eAAgB,CACpC,MAAMmM,EAAQxK,KAAK3B,eAAeP,GAClC,IAAK,IAAIkF,EAAQ,EAAGA,EAAQwH,EAAMrI,OAAQa,IACtCuH,EAAepJ,KAAKqJ,EAAMxH,G,CAIlC,OAAOuH,CACX,CAOOE,WAAWpJ,GACd,GAAIlD,MAAMsM,WAAWpJ,GACjB,OAAO,EAGX,IAAK,MAAMvD,KAAQkC,KAAK5B,UACpB,GAAI4B,KAAK5B,UAAUN,KAAUuD,EACzB,OAAO,EAIf,IAAK,MAAMvD,KAAQkC,KAAK3B,eAAgB,CACpC,MAAMmM,EAAQxK,KAAK3B,eAAeP,GAClC,IAAK,IAAIkF,EAAQ,EAAGA,EAAQwH,EAAMrI,OAAQa,IACtC,GAAIwH,EAAMxH,KAAW3B,EACjB,OAAO,C,CAKnB,OAAO,CACX,CAOOqJ,MAAM5M,GACT,MAAM6M,EAAS,YAA0B,IAAM,IAAI/M,EAAeE,EAAMkC,KAAKqE,WAAYrE,KAAKC,YAAaD,KAAKE,SAAUF,KAAKgE,0BAA0BhE,MAEzJ2K,EAAO7M,KAAOA,EACd6M,EAAOC,GAAK9M,EAGsB,iBAAvB6M,EAAO1K,cACd0K,EAAO1K,YAAc,IAAK0K,EAAO1K,cAIrCD,KAAKE,SAAW,IAAKF,KAAKE,UAEzB2K,OAAOC,KAAK9K,KAAKE,UAAkD6K,SAASC,IACzE,MAAMC,EAAYjL,KAAKE,SAAS8K,GAC5BE,MAAMC,QAAQF,KACHjL,KAAKE,SAAS8K,GAAaC,EAAU7E,MAAM,G,IAK9DpG,KAAKoL,QAAQC,OAAOV,EAAOS,SAG3B,IAAK,MAAME,KAAOtL,KAAK5B,UACnBuM,EAAOvJ,WAAWkK,EAAKtL,KAAK5B,UAAUkN,IAI1C,IAAK,MAAMA,KAAOtL,KAAK3B,eACnBsM,EAAOrJ,gBAAgBgK,EAAKtL,KAAK3B,eAAeiN,IAIpD,IAAK,MAAMA,KAAOtL,KAAK1B,kBACnBqM,EAAOnJ,mBAAmB8J,EAAKtL,KAAK1B,kBAAkBgN,IAI1D,IAAK,MAAMA,KAAOtL,KAAKxB,MACnBmM,EAAOhJ,OAAO2J,EAAKtL,KAAKxB,MAAM8M,IAIlC,IAAK,MAAMA,KAAOtL,KAAKzB,QACnBoM,EAAOlJ,SAAS6J,EAAKtL,KAAKzB,QAAQ+M,IAItC,IAAK,MAAMA,KAAOtL,KAAKvB,cACnBkM,EAAO/I,UAAU0J,EAAKtL,KAAKvB,cAAc6M,IAI7C,IAAK,MAAMA,KAAOtL,KAAKtB,SACnBiM,EAAO9I,UAAUyJ,EAAKtL,KAAKtB,SAAS4M,IAIxC,IAAK,MAAMA,KAAOtL,KAAKrB,eACnBgM,EAAOhM,eAAe2M,GAAOtL,KAAKrB,eAAe2M,GAIrD,IAAK,MAAMA,KAAOtL,KAAKpB,SACnB+L,EAAOvI,UAAUkJ,EAAKtL,KAAKpB,SAAS0M,IAIxC,IAAK,MAAMA,KAAOtL,KAAKnB,eACnB8L,EAAO9L,eAAeyM,GAAOtL,KAAKnB,eAAeyM,GAIrD,IAAK,MAAMA,KAAOtL,KAAKlB,UACnB6L,EAAOrI,WAAWgJ,EAAKtL,KAAKlB,UAAUwM,IAI1C,IAAK,MAAMA,KAAOtL,KAAKjB,UACnB4L,EAAOpI,WAAW+I,EAAKtL,KAAKjB,UAAUuM,IAI1C,IAAK,MAAMA,KAAOtL,KAAKhB,UACnB2L,EAAOnI,WAAW8I,EAAKtL,KAAKhB,UAAUsM,IAI1C,IAAK,MAAMA,KAAOtL,KAAKf,aACnB0L,EAAOlI,cAAc6I,EAAKtL,KAAKf,aAAaqM,IAIhD,IAAK,MAAMA,KAAOtL,KAAKd,mBACnByL,EAAOzL,mBAAmBoM,GAAOtL,KAAKd,mBAAmBoM,GAI7D,IAAK,MAAMA,KAAOtL,KAAKb,UACnBwL,EAAO/H,UAAU0I,EAAKtL,KAAKb,UAAUmM,IAIzC,IAAK,MAAMA,KAAOtL,KAAKZ,cACnBuL,EAAOvL,cAAckM,GAAOtL,KAAKZ,cAAckM,GAAKlF,QAIxD,IAAK,MAAMkF,KAAOtL,KAAKX,aACnBsL,EAAOzH,aAAaoI,EAAKtL,KAAKX,aAAaiM,IAI/C,IAAK,MAAMA,KAAOtL,KAAKV,aACnBqL,EAAOxH,aAAamI,EAAKtL,KAAKV,aAAagM,IAI/C,IAAK,MAAMA,KAAOtL,KAAKT,gBACnBoL,EAAOvH,UAAUkI,EAAKtL,KAAKT,gBAAgB+L,IAI/C,IAAK,MAAMA,KAAOtL,KAAKR,gBACnBmL,EAAOtH,UAAUiI,EAAKtL,KAAKR,gBAAgB8L,IAI/C,IAAK,MAAMA,KAAOtL,KAAKP,gBACnBkL,EAAOrH,UAAUgI,EAAKtL,KAAKP,gBAAgB6L,IAI/C,IAAK,MAAMA,KAAOtL,KAAKN,gBACnBiL,EAAOpH,iBAAiB+H,EAAKtL,KAAKN,gBAAgB4L,IAItD,IAAK,MAAMA,KAAOtL,KAAKL,iBACnBgL,EAAOlH,kBAAkB6H,EAAKtL,KAAKL,iBAAiB2L,IAIxD,IAAK,MAAMA,KAAOtL,KAAKJ,gBACnB+K,EAAOhH,iBAAiB2H,EAAKtL,KAAKJ,gBAAgB0L,IAGtD,OAAOX,CACX,CAQOY,QAAQC,EAA8BC,EAAgCC,GACzE,GAAID,EAAsB,CACtB,IAAI3N,EACJ,IAAKA,KAAQkC,KAAK5B,UACd4B,KAAK5B,UAAUN,GAAMyN,UAGzB,IAAKzN,KAAQkC,KAAK3B,eAAgB,CAC9B,MAAMmM,EAAQxK,KAAK3B,eAAeP,GAClC,IAAK,IAAIkF,EAAQ,EAAGA,EAAQwH,EAAMrI,OAAQa,IACtCwH,EAAMxH,GAAOuI,S,EAKzBvL,KAAK5B,UAAY,CAAC,EAElBD,MAAMoN,QAAQC,EAAoBC,EAAsBC,EAC5D,CAMOC,YACH,MAAMC,EAAsB,eAA8B5L,MAQ1D,IAAIlC,EAOJ,IAAKA,KAdL8N,EAAoBC,WAAa,yBACjCD,EAAoBE,SAAW9L,KAAK8L,SAEpCF,EAAoB3N,QAAU+B,KAAKE,SACnC0L,EAAoB5N,WAAagC,KAAKC,YACtC2L,EAAoB1N,uBAAyB8B,KAAKgE,wBAKlD4H,EAAoBR,QAAUpL,KAAKoL,QAAQO,YAG3CC,EAAoBrK,SAAW,CAAC,EACnBvB,KAAK5B,UACdwN,EAAoBrK,SAASzD,GAAQkC,KAAK5B,UAAUN,GAAM6N,YAK9D,IAAK7N,KADL8N,EAAoBG,cAAgB,CAAC,EACxB/L,KAAK3B,eAAgB,CAC9BuN,EAAoBG,cAAcjO,GAAQ,GAC1C,MAAM0M,EAAQxK,KAAK3B,eAAeP,GAClC,IAAK,IAAIkF,EAAQ,EAAGA,EAAQwH,EAAMrI,OAAQa,IACtC4I,EAAoBG,cAAcjO,GAAMqD,KAAKqJ,EAAMxH,GAAO2I,Y,CAMlE,IAAK7N,KADL8N,EAAoBI,KAAO,CAAC,EACfhM,KAAKxB,MACdoN,EAAoBI,KAAKlO,GAAQkC,KAAKxB,MAAMV,GAKhD,IAAKA,KADL8N,EAAoBK,OAAS,CAAC,EACjBjM,KAAKzB,QACdqN,EAAoBK,OAAOnO,GAAQkC,KAAKzB,QAAQT,GAKpD,IAAKA,KADL8N,EAAoBM,YAAc,CAAC,EACtBlM,KAAKvB,cACdmN,EAAoBM,YAAYpO,GAAQkC,KAAKvB,cAAcX,GAK/D,IAAKA,KADL8N,EAAoBO,QAAU,CAAC,EAClBnM,KAAKtB,SACdkN,EAAoBO,QAAQrO,GAAQkC,KAAKtB,SAASZ,GAAMsO,UAK5D,IAAKtO,KADL8N,EAAoBS,cAAgB,CAAC,EACxBrM,KAAKrB,eACdiN,EAAoBS,cAAcvO,GAAQkC,KAAKrB,eAAeb,GAKlE,IAAKA,KADL8N,EAAoBU,QAAU,CAAC,EAClBtM,KAAKpB,SACdgN,EAAoBU,QAAQxO,GAAQkC,KAAKpB,SAASd,GAAMsO,UAK5D,IAAKtO,KADL8N,EAAoBW,cAAgB,CAAC,EACxBvM,KAAKnB,eACd+M,EAAoBW,cAAczO,GAAQkC,KAAKnB,eAAef,GAKlE,IAAKA,KADL8N,EAAoBY,SAAW,CAAC,EACnBxM,KAAKlB,UACd8M,EAAoBY,SAAS1O,GAAQkC,KAAKlB,UAAUhB,GAAMsO,UAK9D,IAAKtO,KADL8N,EAAoBa,SAAW,CAAC,EACnBzM,KAAKjB,UACd6M,EAAoBa,SAAS3O,GAAQkC,KAAKjB,UAAUjB,GAAMsO,UAK9D,IAAKtO,KADL8N,EAAoBc,SAAW,CAAC,EACnB1M,KAAKhB,UACd4M,EAAoBc,SAAS5O,GAAQkC,KAAKhB,UAAUlB,GAAMsO,UAK9D,IAAKtO,KADL8N,EAAoBe,YAAc,CAAC,EACtB3M,KAAKf,aACd2M,EAAoBe,YAAY7O,GAAQkC,KAAKf,aAAanB,GAAMsO,UAKpE,IAAKtO,KADL8N,EAAoBgB,SAAW,CAAC,EACnB5M,KAAKb,UACdyM,EAAoBgB,SAAS9O,GAAQkC,KAAKb,UAAUrB,GAAMsO,UAK9D,IAAKtO,KADL8N,EAAoBiB,YAAc,CAAC,EACtB7M,KAAKZ,cACdwM,EAAoBiB,YAAY/O,GAAQkC,KAAKZ,cAActB,GAK/D,IAAKA,KADL8N,EAAoBkB,YAAc,CAAC,EACtB9M,KAAKX,aACduM,EAAoBkB,YAAYhP,GAAQkC,KAAKX,aAAavB,GAK9D,IAAKA,KADL8N,EAAoBmB,YAAc,CAAC,EACtB/M,KAAKV,aACdsM,EAAoBmB,YAAYjP,GAAQkC,KAAKV,aAAaxB,GAK9D,IAAKA,KADL8N,EAAoBoB,eAAiB,CAAC,EACzBhN,KAAKT,gBACdqM,EAAoBoB,eAAelP,GAAQkC,KAAKT,gBAAgBzB,GAKpE,IAAKA,KADL8N,EAAoBqB,eAAiB,CAAC,EACzBjN,KAAKR,gBACdoM,EAAoBqB,eAAenP,GAAQkC,KAAKR,gBAAgB1B,GAKpE,IAAKA,KADL8N,EAAoBsB,eAAiB,CAAC,EACzBlN,KAAKP,gBACdmM,EAAoBsB,eAAepP,GAAQkC,KAAKP,gBAAgB3B,GAKpE,IAAKA,KADL8N,EAAoBuB,kBAAoB,CAAC,EAC5BnN,KAAKd,mBACd0M,EAAoBuB,kBAAkBrP,GAAQkC,KAAKd,mBAAmBpB,GAG1E,OAAO8N,CACX,CASOwB,aAAaC,EAAatP,EAAcuP,GAC3C,MAAMC,EAAW,YACb,IAAM,IAAI3P,EAAeyP,EAAOvP,KAAMC,EAAOsP,EAAOrP,WAAYqP,EAAOpP,QAASoP,EAAOnP,yBACvFmP,EACAtP,EACAuP,GAGJ,IAAIxP,EAQJ,IAAKA,KALDuP,EAAOjC,SACPmC,EAASnC,QAAQoC,MAAMH,EAAOjC,QAASrN,EAAOuP,GAIrCD,EAAO9L,SAChBgM,EAASnM,WAAWtD,EAAe,UAAcuP,EAAO9L,SAASzD,GAAOC,EAAOuP,IAInF,IAAKxP,KAAQuP,EAAOtB,cAAe,CAC/B,MAAMvB,EAAQ6C,EAAOtB,cAAcjO,GAC7B2P,EAAe,IAAIvC,MAEzB,IAAK,IAAIlI,EAAQ,EAAGA,EAAQwH,EAAMrI,OAAQa,IACtCyK,EAAatM,KAAc,UAAcqJ,EAAMxH,GAAQjF,EAAOuP,IAElEC,EAASjM,gBAAgBxD,EAAM2P,E,CAInC,IAAK3P,KAAQuP,EAAOrB,KAChBuB,EAAS5L,OAAO7D,EAAMuP,EAAOrB,KAAKlO,IAItC,IAAKA,KAAQuP,EAAOpB,OAChBsB,EAAS9L,SAAS3D,EAAMuP,EAAOpB,OAAOnO,IAI1C,IAAKA,KAAQuP,EAAOK,aAChBH,EAAS3L,UAAU9D,EAAMuP,EAAOK,aAAa5P,IAIjD,IAAKA,KAAQuP,EAAOlB,QAChBoB,EAAS1L,UAAU/D,EAAM,eAAiBuP,EAAOlB,QAAQrO,KAI7D,IAAKA,KAAQuP,EAAOhB,cAAe,CAC/B,MAAMsB,EAAmBN,EAAOhB,cAAcvO,GACzCiE,QAAO,CAACC,EAA2B4L,EAAa5E,KACzCA,EAAI,GAAM,EACVhH,EAAIb,KAAK,CAACyM,IAEV5L,EAAIA,EAAIG,OAAS,GAAGhB,KAAKyM,GAEtB5L,IACR,IACF6L,KAAK5L,GAA6B,eAAiBA,KACxDsL,EAASzL,eAAehE,EAAM6P,E,CAIlC,IAAK7P,KAAQuP,EAAOf,QAChBiB,EAASnL,UAAUtE,EAAM,eAAiBuP,EAAOf,QAAQxO,KAI7D,IAAKA,KAAQuP,EAAOd,cAAe,CAC/B,MAAMoB,EAAmBN,EAAOd,cAAczO,GACzCiE,QAAO,CAACC,EAA2B4L,EAAa5E,KACzCA,EAAI,GAAM,EACVhH,EAAIb,KAAK,CAACyM,IAEV5L,EAAIA,EAAIG,OAAS,GAAGhB,KAAKyM,GAEtB5L,IACR,IACF6L,KAAK5L,GAA6B,eAAiBA,KACxDsL,EAASlL,eAAevE,EAAM6P,E,CAIlC,IAAK7P,KAAQuP,EAAOb,SAChBe,EAASjL,WAAWxE,EAAM,eAAkBuP,EAAOb,SAAS1O,KAIhE,IAAKA,KAAQuP,EAAOZ,SAChBc,EAAShL,WAAWzE,EAAM,cAAkBuP,EAAOZ,SAAS3O,KAIhE,IAAKA,KAAQuP,EAAOX,SAChBa,EAAS/K,WAAW1E,EAAM,eAAkBuP,EAAOX,SAAS5O,KAIhE,IAAKA,KAAQuP,EAAOV,YAChBY,EAAS9K,cAAc3E,EAAM,eAAqBuP,EAAOV,YAAY7O,KAIzE,IAAKA,KAAQuP,EAAOT,SAChBW,EAAS3K,UAAU9E,EAAM,eAAiBuP,EAAOT,SAAS9O,KAI9D,IAAKA,KAAQuP,EAAOR,YAChBU,EAASnO,cAActB,GAAQ,IAAIiF,aAAasK,EAAOR,YAAY/O,IAIvE,IAAKA,KAAQuP,EAAOP,YAChBS,EAASrK,aAAapF,EAAMuP,EAAOP,YAAYhP,IAInD,IAAKA,KAAQuP,EAAON,YAChBQ,EAASpK,aAAarF,EAAMuP,EAAON,YAAYjP,IAInD,IAAKA,KAAQuP,EAAOL,eAChBO,EAASnK,UAAUtF,EAAMuP,EAAOL,eAAelP,IAInD,IAAKA,KAAQuP,EAAOJ,eAChBM,EAASlK,UAAUvF,EAAMuP,EAAOJ,eAAenP,IAInD,IAAKA,KAAQuP,EAAOH,eAChBK,EAASjK,UAAUxF,EAAMuP,EAAOH,eAAepP,IAInD,IAAKA,KAAQuP,EAAOF,kBAChBI,EAASjK,UAAUxF,EAAMuP,EAAOF,kBAAkBrP,IAGtD,OAAOyP,CACX,CAUOH,0BAA0BtP,EAAwBgQ,EAAa/P,EAAcuP,EAAkB,IAClG,OAAO,IAAIS,SAAQ,CAACC,EAASC,KACzB,MAAMC,EAAU,IAAI,IACpBA,EAAQC,iBAAiB,oBAAoB,KACzC,GAA0B,GAAtBD,EAAQE,WACR,GAAsB,KAAlBF,EAAQG,OAAe,CACvB,MAAMzC,EAAsB0C,KAAKd,MAAMU,EAAQK,cACzCC,EAASxO,KAAKyO,MAAM7C,EAAqB7N,GAAS,qBAA8BuP,GAElFxP,IACA0Q,EAAO1Q,KAAOA,GAGlBkQ,EAAQQ,E,MAERP,EAAO,oC,IAKnBC,EAAQQ,KAAK,MAAOZ,GACpBI,EAAQS,MAAM,GAEtB,CASOvB,6BAA6BwB,EAAmB7Q,EAAcuP,EAAkB,IACnF,OAAO,IAAIS,SAAQ,CAACC,EAASC,KACzB,MAAMC,EAAU,IAAI,IACpBA,EAAQC,iBAAiB,oBAAoB,KACzC,GAA0B,GAAtBD,EAAQE,WACR,GAAsB,KAAlBF,EAAQG,OAAe,CACvB,MAAMQ,EAAUP,KAAKd,MAAMc,KAAKd,MAAMU,EAAQK,cAAcO,aACtDlD,EAAsB0C,KAAKd,MAAMqB,EAAQE,gBACzCP,EAASxO,KAAKyO,MAAM7C,EAAqB7N,GAAS,qBAA8BuP,GAEtFkB,EAAOI,UAAYA,EAEnBZ,EAAQQ,E,MAERP,EAAO,8BAAgCW,E,IAKnDV,EAAQQ,KAAK,MAAO1O,KAAKgP,WAAa,IAAMJ,EAAUK,QAAQ,KAAM,MACpEf,EAAQS,MAAM,GAEtB,EArlDc,EAAAK,WAAa,gCA+lDb,EAAAE,uBAAyBtR,EAAeuR,uBAG1D,OAAc,yBAA0BvR,E","sources":["webpack://pro-racer/../lts/core/generated/Materials/shaderMaterial.ts"],"sourcesContent":["import { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { TextureSampler } from \"./Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\ndeclare type ExternalTexture = import(\"./Textures/externalTexture\").ExternalTexture;\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler (texture) names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of external texture names used in the shader\r\n     */\r\n    externalTextures: string[];\r\n\r\n    /**\r\n     * The list of sampler object names used in the shader\r\n     */\r\n    samplerObjects: string[];\r\n\r\n    /**\r\n     * The list of storage buffer names used in the shader\r\n     */\r\n    storageBuffers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n\r\n    /**\r\n     * Defines if clip planes have to be turned on: true to turn them on, false to turn them off and null to turn them on/off depending on the scene configuration (scene.clipPlaneX)\r\n     */\r\n    useClipPlane: Nullable<boolean>;\r\n\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/advanced_topics/shaders/shaderMaterial\r\n */\r\nexport class ShaderMaterial extends PushMaterial {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _externalTextures: { [name: string]: ExternalTexture } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _quaternions: { [name: string]: Quaternion } = {};\r\n    private _quaternionsArrays: { [name: string]: number[] } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _uniformBuffers: { [name: string]: UniformBuffer } = {};\r\n    private _textureSamplers: { [name: string]: TextureSampler } = {};\r\n    private _storageBuffers: { [name: string]: StorageBuffer } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _multiview: boolean = false;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/how_to/shader_material\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: { vertex: \"custom\", fragment: \"custom\" }, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: { vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }, used with shader code in script tags\r\n     *  * object: { vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" } using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}, storeEffectOnSubMeshes = true) {\r\n        super(name, scene, storeEffectOnSubMeshes);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            externalTextures: [],\r\n            samplerObjects: [],\r\n            storageBuffers: [],\r\n            defines: [],\r\n            useClipPlane: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an internal texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): ShaderMaterial {\r\n        if (this._options.externalTextures.indexOf(name) === -1) {\r\n            this._options.externalTextures.push(name);\r\n        }\r\n        this._externalTextures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Quaternion.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternion(name: string, value: Quaternion): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternions[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Quaternion array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternionArray(name: string, value: Quaternion[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\r\n            quaternion.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        const float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (let index = 0; index < value.length; index++) {\r\n            const matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a uniform buffer in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): ShaderMaterial {\r\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\r\n            this._options.uniformBuffers.push(name);\r\n        }\r\n        this._uniformBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture sampler in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param sampler Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): ShaderMaterial {\r\n        if (this._options.samplerObjects.indexOf(name) === -1) {\r\n            this._options.samplerObjects.push(name);\r\n        }\r\n        this._textureSamplers[name] = sampler;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a storage buffer in the shader\r\n     * @param name Define the name of the storage buffer as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): ShaderMaterial {\r\n        if (this._options.storageBuffers.indexOf(name) === -1) {\r\n            this._options.storageBuffers.push(name);\r\n        }\r\n        this._storageBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @param subMesh defines which submesh to render\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean, subMesh?: SubMesh): boolean {\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n\r\n        if (this.isFrozen) {\r\n            if (storeEffectOnSubMeshes) {\r\n                if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                const effect = this._drawWrapper.effect;\r\n                if (effect && effect._wasPreviouslyReady && effect._wasPreviouslyUsingInstances === useInstances) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Instances\r\n        const defines = [];\r\n        const attribs = [];\r\n        const fallbacks = new EffectFallbacks();\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 && this._options.uniforms.indexOf(\"viewProjectionR\") === -1) {\r\n                this._options.uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._options.defines.length; index++) {\r\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\r\n            defines.push(defineToAdd);\r\n        }\r\n\r\n        for (let index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n                    attribs.push(VertexBuffer.ColorInstanceKind);\r\n                    defines.push(\"#define INSTANCESCOLOR\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph\r\n        let numInfluencers = 0;\r\n        const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n        if (manager) {\r\n            const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\r\n            const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\r\n            const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\r\n            numInfluencers = manager.numInfluencers;\r\n            if (uv) {\r\n                defines.push(\"#define MORPHTARGETS_UV\");\r\n            }\r\n            if (tangent) {\r\n                defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n            }\r\n            if (normal) {\r\n                defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n            }\r\n            if (numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n            }\r\n            if (manager.isUsingTextureForTargets) {\r\n                defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                    this._options.uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\r\n                    this._options.samplers.push(\"morphTargets\");\r\n                }\r\n            }\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\r\n            for (let index = 0; index < numInfluencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n            if (numInfluencers > 0) {\r\n                uniforms = uniforms.slice();\r\n                uniforms.push(\"morphTargetInfluences\");\r\n                uniforms.push(\"morphTargetTextureInfo\");\r\n                uniforms.push(\"morphTargetTextureIndices\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Baked Vertex Animation\r\n        if (mesh) {\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n        }\r\n\r\n        // Textures\r\n        for (const name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        // Clip planes\r\n        if ((this._options.useClipPlane === null && !!scene.clipPlane) || this._options.useClipPlane) {\r\n            defines.push(\"#define CLIPPLANE\");\r\n            if (uniforms.indexOf(\"vClipPlane\") === -1) {\r\n                uniforms.push(\"vClipPlane\");\r\n            }\r\n        }\r\n\r\n        if ((this._options.useClipPlane === null && !!scene.clipPlane2) || this._options.useClipPlane) {\r\n            defines.push(\"#define CLIPPLANE2\");\r\n            if (uniforms.indexOf(\"vClipPlane2\") === -1) {\r\n                uniforms.push(\"vClipPlane2\");\r\n            }\r\n        }\r\n\r\n        if ((this._options.useClipPlane === null && !!scene.clipPlane3) || this._options.useClipPlane) {\r\n            defines.push(\"#define CLIPPLANE3\");\r\n            if (uniforms.indexOf(\"vClipPlane3\") === -1) {\r\n                uniforms.push(\"vClipPlane3\");\r\n            }\r\n        }\r\n\r\n        if ((this._options.useClipPlane === null && !!scene.clipPlane4) || this._options.useClipPlane) {\r\n            defines.push(\"#define CLIPPLANE4\");\r\n            if (uniforms.indexOf(\"vClipPlane4\") === -1) {\r\n                uniforms.push(\"vClipPlane4\");\r\n            }\r\n        }\r\n\r\n        if ((this._options.useClipPlane === null && !!scene.clipPlane5) || this._options.useClipPlane) {\r\n            defines.push(\"#define CLIPPLANE5\");\r\n            if (uniforms.indexOf(\"vClipPlane5\") === -1) {\r\n                uniforms.push(\"vClipPlane5\");\r\n            }\r\n        }\r\n\r\n        if ((this._options.useClipPlane === null && !!scene.clipPlane6) || this._options.useClipPlane) {\r\n            defines.push(\"#define CLIPPLANE6\");\r\n            if (uniforms.indexOf(\"vClipPlane6\") === -1) {\r\n                uniforms.push(\"vClipPlane6\");\r\n            }\r\n        }\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;\r\n        const previousEffect = drawWrapper?.effect ?? null;\r\n        const previousDefines = drawWrapper?.defines ?? null;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        let effect = previousEffect;\r\n        if (previousDefines !== join) {\r\n            effect = engine.createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    shaderLanguage: this._options.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (storeEffectOnSubMeshes) {\r\n                subMesh.setEffect(effect, join, this._materialContext);\r\n            } else if (drawWrapper) {\r\n                drawWrapper.setEffect(effect, join);\r\n            }\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        effect!._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        if (!effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        const scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this.getEffect();\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>, subMesh?: SubMesh): void {\r\n        // Std values\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const uniformBuffers = this._options.uniformBuffers;\r\n\r\n        let useSceneUBO = false;\r\n\r\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && this.getScene().getEngine().supportsUniformBuffers) {\r\n            for (let i = 0; i < uniformBuffers.length; ++i) {\r\n                const bufferName = uniformBuffers[i];\r\n                switch (bufferName) {\r\n                    case \"Mesh\":\r\n                        if (mesh) {\r\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                            mesh.transferToEffect(world);\r\n                        }\r\n                        break;\r\n                    case \"Scene\":\r\n                        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                        this.getScene().finalizeSceneUbo();\r\n                        useSceneUBO = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(this.getScene(), effect, mesh.visibility) : this.getScene().getCachedMaterial() !== this;\r\n\r\n        if (effect && mustRebind) {\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", this.getScene().activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(effect, this.getScene());\r\n\r\n            let name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // External texture\r\n            for (name in this._externalTextures) {\r\n                effect.setExternalTexture(name, this._externalTextures[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Quaternion\r\n            for (name in this._quaternions) {\r\n                effect.setQuaternion(name, this._quaternions[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n\r\n            // QuaternionArray\r\n            for (name in this._quaternionsArrays) {\r\n                effect.setArray4(name, this._quaternionsArrays[name]);\r\n            }\r\n\r\n            // Uniform buffers\r\n            for (name in this._uniformBuffers) {\r\n                const buffer = this._uniformBuffers[name].getBuffer();\r\n                if (buffer) {\r\n                    effect.bindUniformBuffer(buffer, name);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            for (name in this._textureSamplers) {\r\n                effect.setTextureSampler(name, this._textureSamplers[name]);\r\n            }\r\n\r\n            // Storage buffers\r\n            for (name in this._storageBuffers) {\r\n                effect.setStorageBuffer(name, this._storageBuffers[name]);\r\n            }\r\n        }\r\n\r\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\r\n            // Morph targets\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.numInfluencers > 0) {\r\n                MaterialHelper.BindMorphTargetParameters(<Mesh>mesh, effect);\r\n            }\r\n\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, !!effect._wasPreviouslyUsingInstances);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, effect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        for (const name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === \"object\") {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Stencil\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        // Texture\r\n        for (const key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // TextureArray\r\n        for (const key in this._textureArrays) {\r\n            result.setTextureArray(key, this._textureArrays[key]);\r\n        }\r\n\r\n        // External texture\r\n        for (const key in this._externalTextures) {\r\n            result.setExternalTexture(key, this._externalTextures[key]);\r\n        }\r\n\r\n        // Int\r\n        for (const key in this._ints) {\r\n            result.setInt(key, this._ints[key]);\r\n        }\r\n\r\n        // Float\r\n        for (const key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (const key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (const key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color3Array\r\n        for (const key in this._colors3Arrays) {\r\n            result._colors3Arrays[key] = this._colors3Arrays[key];\r\n        }\r\n\r\n        // Color4\r\n        for (const key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Color4Array\r\n        for (const key in this._colors4Arrays) {\r\n            result._colors4Arrays[key] = this._colors4Arrays[key];\r\n        }\r\n\r\n        // Vector2\r\n        for (const key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (const key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (const key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Quaternion\r\n        for (const key in this._quaternions) {\r\n            result.setQuaternion(key, this._quaternions[key]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (const key in this._quaternionsArrays) {\r\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\r\n        }\r\n\r\n        // Matrix\r\n        for (const key in this._matrices) {\r\n            result.setMatrix(key, this._matrices[key]);\r\n        }\r\n\r\n        // MatrixArray\r\n        for (const key in this._matrixArrays) {\r\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (const key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (const key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (const key in this._vectors2Arrays) {\r\n            result.setArray2(key, this._vectors2Arrays[key]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (const key in this._vectors3Arrays) {\r\n            result.setArray3(key, this._vectors3Arrays[key]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (const key in this._vectors4Arrays) {\r\n            result.setArray4(key, this._vectors4Arrays[key]);\r\n        }\r\n\r\n        // Uniform buffers\r\n        for (const key in this._uniformBuffers) {\r\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\r\n        }\r\n\r\n        // Samplers\r\n        for (const key in this._textureSamplers) {\r\n            result.setTextureSampler(key, this._textureSamplers[key]);\r\n        }\r\n\r\n        // Storag buffers\r\n        for (const key in this._storageBuffers) {\r\n            result.setStorageBuffer(key, this._storageBuffers[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            let name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                const array = this._textureArrays[name];\r\n                for (let index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        serializationObject.stencil = this.stencil.serialize();\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Int\r\n        serializationObject.ints = {};\r\n        for (name in this._ints) {\r\n            serializationObject.ints[name] = this._ints[name];\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Quaternion\r\n        serializationObject.quaternions = {};\r\n        for (name in this._quaternions) {\r\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        // QuaternionArray\r\n        serializationObject.quaternionsArrays = {};\r\n        for (name in this._quaternionsArrays) {\r\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        const material = SerializationHelper.Parse(\r\n            () => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            const array = source.textureArrays[name];\r\n            const textureArray = new Array<Texture>();\r\n\r\n            for (let index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Int\r\n        for (name in source.ints) {\r\n            material.setInt(name, source.ints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 3 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 4 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Quaternion\r\n        for (name in source.quaternions) {\r\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (name in source.quaternionsArrays) {\r\n            material.setArray4(name, source.quaternionsArrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\r\n"],"names":["onCreatedEffectParameters","effect","subMesh","ShaderMaterial","constructor","name","scene","shaderPath","options","storeEffectOnSubMeshes","super","_textures","_textureArrays","_externalTextures","_floats","_ints","_floatsArrays","_colors3","_colors3Arrays","_colors4","_colors4Arrays","_vectors2","_vectors3","_vectors4","_quaternions","_quaternionsArrays","_matrices","_matrixArrays","_matrices3x3","_matrices2x2","_vectors2Arrays","_vectors3Arrays","_vectors4Arrays","_uniformBuffers","_textureSamplers","_storageBuffers","_cachedWorldViewMatrix","_cachedWorldViewProjectionMatrix","_multiview","this","_shaderPath","_options","needAlphaBlending","needAlphaTesting","attributes","uniforms","uniformBuffers","samplers","externalTextures","samplerObjects","storageBuffers","defines","useClipPlane","getClassName","alpha","_checkUniform","uniformName","indexOf","push","setTexture","texture","setTextureArray","textures","setExternalTexture","setFloat","value","setInt","setFloats","setColor3","setColor3Array","reduce","arr","color","toArray","length","setColor4","setColor4Array","setVector2","setVector3","setVector4","setQuaternion","setQuaternionArray","quaternion","setMatrix","setMatrices","float32Array","Float32Array","index","copyToArray","setMatrix3x3","setMatrix2x2","setArray2","setArray3","setArray4","setUniformBuffer","buffer","setTextureSampler","sampler","setStorageBuffer","isReadyForSubMesh","mesh","useInstances","isReady","_storeEffectOnSubMeshes","isFrozen","_wasPreviouslyReady","_drawWrapper","_wasPreviouslyUsingInstances","getScene","engine","getEngine","attribs","fallbacks","shaderName","getCaps","multiview","activeCamera","outputRenderTarget","getViewCount","defineToAdd","isVerticesDataPresent","hasThinInstances","useBones","computeBonesUsingShaders","skeleton","numBoneInfluencers","addCPUSkinningFallback","isUsingTextureForMatrices","bones","numInfluencers","manager","morphTargetManager","uv","supportsUVs","tangent","supportsTangents","normal","supportsNormals","isUsingTextureForTargets","slice","bvaManager","bakedVertexAnimationManager","isEnabled","_shouldTurnAlphaTestOn","clipPlane","clipPlane2","clipPlane3","clipPlane4","clipPlane5","clipPlane6","customShaderNameResolve","drawWrapper","_getDrawWrapper","previousEffect","previousDefines","join","createEffect","uniformsNames","uniformBuffersNames","onCompiled","onError","indexParameters","maxSimultaneousMorphTargets","shaderLanguage","setEffect","_materialContext","_onEffectCreatedObservable","subMeshes","notifyObservers","resetCachedMaterial","bindOnlyWorldMatrix","world","effectOverride","getEffect","multiplyToRef","getViewMatrix","getTransformMatrix","bindForSubMesh","bind","_drawWrapperOverride","_activeEffect","useSceneUBO","supportsUniformBuffers","i","getMeshUniformBuffer","bindToEffect","transferToEffect","getSceneUniformBuffer","finalizeSceneUbo","mustRebind","_mustRebind","visibility","getCachedMaterial","getProjectionMatrix","_transformMatrixR","globalPosition","setArray","setFloat4","r","g","b","a","getBuffer","bindUniformBuffer","_afterBind","getActiveTextures","activeTextures","array","hasTexture","clone","result","id","Object","keys","forEach","propName","propValue","Array","isArray","stencil","copyTo","key","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","serialize","serializationObject","customType","uniqueId","textureArrays","ints","floats","FloatArrays","colors3","asArray","colors3Arrays","colors4","colors4Arrays","vectors2","vectors3","vectors4","quaternions","matrices","matrixArray","matrices3x3","matrices2x2","vectors2Arrays","vectors3Arrays","vectors4Arrays","quaternionsArrays","static","source","rootUrl","material","parse","textureArray","floatsArrays","colors","num","map","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","responseText","output","Parse","open","send","snippetId","snippet","jsonPayload","shaderMaterial","SnippetUrl","replace","CreateFromSnippetAsync","ParseFromSnippetAsync"],"sourceRoot":""}