{"version":3,"file":"js/217.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Meshes/Builders/linesBuilder.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Meshes/Builders/ribbonBuilder.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Meshes/Builders/shapeBuilder.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Meshes/instancedMesh.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Meshes/linesMesh.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Physics/physicsImpostor.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Physics/physicsJoint.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Shaders/color.fragment.ts","webpack://babylonjs-typescript-webpack-simple-scene/../lts/core/generated/Shaders/color.vertex.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\ndeclare type Material = import(\"../../Materials/material\").Material;\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @param options.lines\r\n * @param options.colors\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.lines\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene>\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.points\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\n(Mesh as any).CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n","import type { Nullable, FloatArray } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3, Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ribbon\r\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n * * pathArray array of paths, each of which an array of successive Vector3\r\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @returns the VertexData of the ribbon\r\n */\r\nexport function CreateRibbonVertexData(options: {\r\n    pathArray: Vector3[][];\r\n    closeArray?: boolean;\r\n    closePath?: boolean;\r\n    offset?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    invertUV?: boolean;\r\n    uvs?: Vector2[];\r\n    colors?: Color4[];\r\n}): VertexData {\r\n    let pathArray: Vector3[][] = options.pathArray;\r\n    const closeArray: boolean = options.closeArray || false;\r\n    const closePath: boolean = options.closePath || false;\r\n    const invertUV: boolean = options.invertUV || false;\r\n    const defaultOffset: number = Math.floor(pathArray[0].length / 2);\r\n    let offset: number = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const customUV = options.uvs;\r\n    const customColors = options.colors;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const us: number[][] = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    const vs: number[][] = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\r\n    const uTotalDistance: number[] = []; // uTotalDistance[p] : total distance of path p\r\n    const vTotalDistance: number[] = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    let minlg: number; // minimal length among all paths from pathArray\r\n    const lg: number[] = []; // array of path lengths : nb of vertex per path\r\n    const idx: number[] = []; // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    let p: number; // path iterator\r\n    let i: number; // point iterator\r\n    let j: number; // point iterator\r\n\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        const ar1: Vector3[] = [];\r\n        const ar2: Vector3[] = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n\r\n    // positions and horizontal distances (u)\r\n    let idc: number = 0;\r\n    const closePathCorr: number = closePath ? 1 : 0; // the final index will be +1 if closePath\r\n    let path: Vector3[];\r\n    let l: number;\r\n    minlg = pathArray[0].length;\r\n    let vectlg: number;\r\n    let dist: number;\r\n    for (p = 0; p < pathArray.length; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = pathArray[p];\r\n        l = path.length;\r\n        minlg = minlg < l ? minlg : l;\r\n\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n\r\n        if (closePath) {\r\n            // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += l + closePathCorr;\r\n    }\r\n\r\n    // vertical distances (v)\r\n    let path1: Vector3[];\r\n    let path2: Vector3[];\r\n    let vertex1: Nullable<Vector3> = null;\r\n    let vertex2: Nullable<Vector3> = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[p + 1];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            } else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n\r\n        if (closeArray && vertex2 && vertex1) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[0];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex2 = path2[0];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n\r\n    // uvs\r\n    let u: number;\r\n    let v: number;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\r\n        }\r\n    } else {\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                } else {\r\n                    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    p = 0; // path index\r\n    let pi: number = 0; // positions array index\r\n    let l1: number = lg[p] - 1; // path1 length\r\n    let l2: number = lg[p + 1] - 1; // path2 length\r\n    let min: number = l1 < l2 ? l1 : l2; // current path stop index\r\n    let shft: number = idx[1] - idx[0]; // shift\r\n    const path1nb: number = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\r\n\r\n    while (pi <= min && p < path1nb) {\r\n        //  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) {\r\n            // if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            if (p === lg.length - 1) {\r\n                // last path of pathArray reached <=> closeArray == true\r\n                shft = idx[0] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[0] - 1;\r\n            } else {\r\n                shft = idx[p + 1] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[p + 1] - 1;\r\n            }\r\n            pi = idx[p];\r\n            min = l1 < l2 ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n\r\n    // normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    if (closePath) {\r\n        // update both the first and last vertex normals to their average value\r\n        let indexFirst: number = 0;\r\n        let indexLast: number = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            } else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Colors\r\n    let colors: Nullable<Float32Array> = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (let c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    const positions32 = new Float32Array(positions);\r\n    const normals32 = new Float32Array(normals);\r\n    const uvs32 = new Float32Array(uvs);\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, VertexBuffer.ColorKind);\r\n    }\r\n\r\n    if (closePath) {\r\n        (<any>vertexData)._idx = idx;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @param scene defines the hosting scene\r\n * @returns the ribbon mesh\r\n * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n */\r\nexport function CreateRibbon(\r\n    name: string,\r\n    options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const pathArray = options.pathArray;\r\n    const closeArray = options.closeArray;\r\n    const closePath = options.closePath;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const updatable = options.updatable;\r\n\r\n    if (instance) {\r\n        // existing ribbon instance update\r\n        // positionFunction : ribbon case\r\n        // only pathArray and sideOrientation parameters are taken into account for positions update\r\n        const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\r\n        const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\r\n        const positionFunction = (positions: FloatArray) => {\r\n            let minlg = pathArray[0].length;\r\n            const mesh = <Mesh>instance;\r\n            let i = 0;\r\n            const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\r\n            for (let si = 1; si <= ns; ++si) {\r\n                for (let p = 0; p < pathArray.length; ++p) {\r\n                    const path = pathArray[p];\r\n                    const l = path.length;\r\n                    minlg = minlg < l ? minlg : l;\r\n                    for (let j = 0; j < minlg; ++j) {\r\n                        const pathPoint = path[j];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        i += 3;\r\n                    }\r\n                    if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                        const pathPoint = path[0];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        i += 3;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        const positions = <FloatArray>instance.getVerticesData(VertexBuffer.PositionKind);\r\n        positionFunction(positions);\r\n        if (instance.hasBoundingInfo) {\r\n            instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);\r\n        } else {\r\n            instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (options.colors) {\r\n            const colors = <FloatArray>instance.getVerticesData(VertexBuffer.ColorKind);\r\n            for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\r\n                const color = options.colors[c];\r\n                colors[colorIndex] = color.r;\r\n                colors[colorIndex + 1] = color.g;\r\n                colors[colorIndex + 2] = color.b;\r\n                colors[colorIndex + 3] = color.a;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\r\n        }\r\n        if (options.uvs) {\r\n            const uvs = <FloatArray>instance.getVerticesData(VertexBuffer.UVKind);\r\n            for (let i = 0; i < options.uvs.length; i++) {\r\n                uvs[i * 2] = options.uvs[i].x;\r\n                uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\r\n        }\r\n        if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n            const indices = instance.getIndices();\r\n            const normals = <FloatArray>instance.getVerticesData(VertexBuffer.NormalKind);\r\n            const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n            VertexData.ComputeNormals(positions, indices, normals, params);\r\n\r\n            if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                let indexFirst: number = 0;\r\n                let indexLast: number = 0;\r\n                for (let p = 0; p < pathArray.length; p++) {\r\n                    indexFirst = instance._creationDataStorage!.idx[p] * 3;\r\n                    if (p + 1 < pathArray.length) {\r\n                        indexLast = (instance._creationDataStorage!.idx[p + 1] - 1) * 3;\r\n                    } else {\r\n                        indexLast = normals.length - 3;\r\n                    }\r\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                    normals[indexLast] = normals[indexFirst];\r\n                    normals[indexLast + 1] = normals[indexFirst + 1];\r\n                    normals[indexLast + 2] = normals[indexFirst + 2];\r\n                }\r\n            }\r\n            if (!instance.areNormalsFrozen) {\r\n                instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    } else {\r\n        // new ribbon creation\r\n\r\n        const ribbon = new Mesh(name, scene);\r\n        ribbon._originalBuilderSideOrientation = sideOrientation;\r\n        ribbon._creationDataStorage = new _CreationDataStorage();\r\n\r\n        const vertexData = CreateRibbonVertexData(options);\r\n        if (closePath) {\r\n            ribbon._creationDataStorage.idx = (<any>vertexData)._idx;\r\n        }\r\n        ribbon._creationDataStorage.closePath = closePath;\r\n        ribbon._creationDataStorage.closeArray = closeArray;\r\n\r\n        vertexData.applyToMesh(ribbon, updatable);\r\n\r\n        return ribbon;\r\n    }\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateRibbon directly\r\n */\r\nexport const RibbonBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateRibbon,\r\n};\r\n\r\nVertexData.CreateRibbon = CreateRibbonVertexData;\r\n\r\n(Mesh as any).CreateRibbon = (\r\n    name: string,\r\n    pathArray: Vector3[][],\r\n    closeArray: boolean = false,\r\n    closePath: boolean,\r\n    offset: number,\r\n    scene?: Scene,\r\n    updatable: boolean = false,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n) => {\r\n    return CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: closeArray,\r\n            closePath: closePath,\r\n            offset: offset,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            instance: instance,\r\n        },\r\n        scene\r\n    );\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. Consider using this for any path that is straight, and particular for paths in the xy plane.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scale\r\n * @param options.rotation\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.firstNormal\r\n * @param options.adjustFrame\r\n * @param scene defines the hosting scene\r\n * @returns the extruded shape mesh\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n */\r\nexport function ExtrudeShape(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scale?: number;\r\n        rotation?: number;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scale = options.scale || 1;\r\n    const rotation = options.rotation || 0;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance || null;\r\n    const invertUV = options.invertUV || false;\r\n    const closeShape = options.closeShape || false;\r\n    const closePath = options.closePath || false;\r\n\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        scale,\r\n        rotation,\r\n        null,\r\n        null,\r\n        closePath,\r\n        closeShape,\r\n        cap,\r\n        false,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        options.firstNormal || null,\r\n        options.adjustFrame ? true : false\r\n    );\r\n}\r\n\r\n/**\r\n * Creates an custom extruded shape mesh.\r\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\r\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. It should be supplied when the path is in the xy plane, and particularly if these sections are straight, because the underlying Path3D object will pick a normal in the xy plane that causes the extrusion to be collapsed into the plane. This should be used for any path that is straight.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scaleFunction\r\n * @param options.rotationFunction\r\n * @param options.ribbonCloseArray\r\n * @param options.ribbonClosePath\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.firstNormal\r\n * @param options.adjustFrame\r\n * @param scene defines the hosting scene\r\n * @returns the custom extruded shape mesh\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n */\r\nexport function ExtrudeShapeCustom(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scaleFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        rotationFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        ribbonCloseArray?: boolean;\r\n        ribbonClosePath?: boolean;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scaleFunction =\r\n        options.scaleFunction ||\r\n        (() => {\r\n            return 1;\r\n        });\r\n    const rotationFunction =\r\n        options.rotationFunction ||\r\n        (() => {\r\n            return 0;\r\n        });\r\n    const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\r\n    const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const firstNormal = options.firstNormal || null;\r\n    const adjustFrame = options.adjustFrame || false;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const invertUV = options.invertUV || false;\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        null,\r\n        null,\r\n        scaleFunction,\r\n        rotationFunction,\r\n        ribbonCloseArray,\r\n        ribbonClosePath,\r\n        cap,\r\n        true,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance || null,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        firstNormal,\r\n        adjustFrame\r\n    );\r\n}\r\n\r\nfunction _ExtrudeShapeGeneric(\r\n    name: string,\r\n    shape: Vector3[],\r\n    curve: Vector3[],\r\n    scale: Nullable<number>,\r\n    rotation: Nullable<number>,\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rbCA: boolean,\r\n    rbCP: boolean,\r\n    cap: number,\r\n    custom: boolean,\r\n    scene: Nullable<Scene>,\r\n    updtbl: boolean,\r\n    side: number,\r\n    instance: Nullable<Mesh>,\r\n    invertUV: boolean,\r\n    frontUVs: Nullable<Vector4>,\r\n    backUVs: Nullable<Vector4>,\r\n    firstNormal: Nullable<Vector3>,\r\n    adjustFrame: boolean\r\n): Mesh {\r\n    // extrusion geometry\r\n    const extrusionPathArray = (\r\n        shape: Vector3[],\r\n        curve: Vector3[],\r\n        path3D: Path3D,\r\n        shapePaths: Vector3[][],\r\n        scale: Nullable<number>,\r\n        rotation: Nullable<number>,\r\n        scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        custom: boolean,\r\n        adjustFrame: boolean\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const binormals = path3D.getBinormals();\r\n        const distances = path3D.getDistances();\r\n        if (adjustFrame) {\r\n            /* fix tangents,normals, binormals */\r\n            for (let i = 0; i < tangents.length; i++) {\r\n                if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {\r\n                    tangents[i].copyFrom(tangents[i - 1]);\r\n                }\r\n                if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {\r\n                    normals[i].copyFrom(normals[i - 1]);\r\n                }\r\n                if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {\r\n                    binormals[i].copyFrom(binormals[i - 1]);\r\n                }\r\n                if (i > 0) {\r\n                    let v = tangents[i - 1];\r\n                    if (Vector3.Dot(v, tangents[i]) < 0) {\r\n                        tangents[i].scaleInPlace(-1);\r\n                    }\r\n                    v = normals[i - 1];\r\n                    if (Vector3.Dot(v, normals[i]) < 0) {\r\n                        normals[i].scaleInPlace(-1);\r\n                    }\r\n                    v = binormals[i - 1];\r\n                    if (Vector3.Dot(v, binormals[i]) < 0) {\r\n                        binormals[i].scaleInPlace(-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let angle = 0;\r\n        const returnScale = () => {\r\n            return scale !== null ? scale : 1;\r\n        };\r\n        const returnRotation = () => {\r\n            return rotation !== null ? rotation : 0;\r\n        };\r\n        const rotate: { (i: number, distance: number): number } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n        const scl: { (i: number, distance: number): number } = custom && scaleFunction ? scaleFunction : returnScale;\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n        for (let i = 0; i < curve.length; i++) {\r\n            const shapePath = new Array<Vector3>();\r\n            const angleStep = rotate(i, distances[i]);\r\n            const scaleRatio = scl(i, distances[i]);\r\n            Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n            for (let p = 0; p < shape.length; p++) {\r\n                const planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\r\n                const rotated = Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                shapePath[p] = rotated;\r\n            }\r\n            shapePaths[index] = shapePath;\r\n            angle += angleStep;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (shapePath: Vector3[]) => {\r\n            const pointCap = Array<Vector3>();\r\n            const barycenter = Vector3.Zero();\r\n            let i: number;\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                barycenter.addInPlace(shapePath[i]);\r\n            }\r\n            barycenter.scaleInPlace(1.0 / shapePath.length);\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                pointCap.push(barycenter);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                break;\r\n            case Mesh.CAP_END:\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return shapePaths;\r\n    };\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // instance update\r\n        const storage = instance._creationDataStorage!;\r\n        path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);\r\n        pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);\r\n        instance = CreateRibbon(\"\", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || undefined);\r\n\r\n        return instance;\r\n    }\r\n    // extruded shape creation\r\n    path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);\r\n    const newShapePaths = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);\r\n    const extrudedGeneric = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: rbCA,\r\n            closePath: rbCP,\r\n            updatable: updtbl,\r\n            sideOrientation: side,\r\n            invertUV: invertUV,\r\n            frontUVs: frontUVs || undefined,\r\n            backUVs: backUVs || undefined,\r\n        },\r\n        scene\r\n    );\r\n    extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n    extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n    extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n    return extrudedGeneric;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use the functions directly from the module\r\n */\r\nexport const ShapeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShape,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShapeCustom,\r\n};\r\n\r\n(Mesh as any).ExtrudeShape = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scale: number,\r\n    rotation: number,\r\n    cap: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShape(name, options, scene);\r\n};\r\n\r\n(Mesh as any).ExtrudeShapeCustom = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotationFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    ribbonCloseArray: boolean,\r\n    ribbonClosePath: boolean,\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShapeCustom(name, options, scene);\r\n};\r\n","import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updatable\r\n     * @param stride\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updateExtends\r\n     * @param makeItUnique\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices\r\n     * @param totalVertices\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse\r\n     * @param disposeMaterialAndTextures\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n\r\n        if (!this._userInstancedBuffersStorage) {\r\n            this._userInstancedBuffersStorage = {\r\n                data: {},\r\n                vertexBuffers: {},\r\n                strides: {},\r\n                sizes: {},\r\n                vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n            };\r\n        }\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n","import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        const colorEffect = this._lineMaterial.getEffect();\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     */\r\n    public dispose(doNotRecurse?: boolean): void {\r\n        this._lineMaterial.dispose(false, false, true);\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name\r\n     * @param newParent\r\n     * @param doNotCloneChildren\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n","import type { Nullable, IndicesArray } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport type { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport type { PhysicsJointData } from \"./physicsJoint\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\n/**\r\n * The interface for the physics imposter parameters\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface PhysicsImpostorParameters {\r\n    /**\r\n     * The mass of the physics imposter\r\n     */\r\n    mass: number;\r\n    /**\r\n     * The friction of the physics imposter\r\n     */\r\n    friction?: number;\r\n    /**\r\n     * The coefficient of restitution of the physics imposter\r\n     */\r\n    restitution?: number;\r\n    /**\r\n     * The native options of the physics imposter\r\n     */\r\n    nativeOptions?: any;\r\n    /**\r\n     * Specifies if the parent should be ignored\r\n     */\r\n    ignoreParent?: boolean;\r\n    /**\r\n     * Specifies if bi-directional transformations should be disabled\r\n     */\r\n    disableBidirectionalTransformation?: boolean;\r\n    /**\r\n     * The pressure inside the physics imposter, soft object only\r\n     */\r\n    pressure?: number;\r\n    /**\r\n     * The stiffness the physics imposter, soft object only\r\n     */\r\n    stiffness?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex velocities, soft object only\r\n     */\r\n    velocityIterations?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex positions, soft object only\r\n     */\r\n    positionIterations?: number;\r\n    /**\r\n     * The number used to fix points on a cloth (0, 1, 2, 4, 8) or rope (0, 1, 2) only\r\n     * 0 None, 1, back left or top, 2, back right or bottom, 4, front left, 8, front right\r\n     * Add to fix multiple points\r\n     */\r\n    fixedPoints?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    margin?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    damping?: number;\r\n    /**\r\n     * The path for a rope based on an extrusion\r\n     */\r\n    path?: any;\r\n    /**\r\n     * The shape of an extrusion used for a rope based on an extrusion\r\n     */\r\n    shape?: any;\r\n}\r\n\r\n/**\r\n * Interface for a physics-enabled object\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface IPhysicsEnabledObject {\r\n    /**\r\n     * The position of the physics-enabled object\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scale of the physics-enabled object\r\n     */\r\n    scaling: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotation?: Vector3;\r\n    /**\r\n     * The parent of the physics-enabled object\r\n     */\r\n    parent?: any;\r\n    /**\r\n     * The bounding info of the physics-enabled object\r\n     * @returns The bounding info of the physics-enabled object\r\n     */\r\n    getBoundingInfo(): BoundingInfo;\r\n    /**\r\n     * Computes the world matrix\r\n     * @param force Specifies if the world matrix should be computed by force\r\n     * @returns A world matrix\r\n     */\r\n    computeWorldMatrix(force: boolean): Matrix;\r\n    /**\r\n     * Gets the world matrix\r\n     * @returns A world matrix\r\n     */\r\n    getWorldMatrix?(): Matrix;\r\n    /**\r\n     * Gets the child meshes\r\n     * @param directDescendantsOnly Specifies if only direct-descendants should be obtained\r\n     * @returns An array of abstract meshes\r\n     */\r\n    getChildMeshes?(directDescendantsOnly?: boolean): Array<AbstractMesh>;\r\n    /**\r\n     * Gets the vertex data\r\n     * @param kind The type of vertex data\r\n     * @returns A nullable array of numbers, or a float32 array\r\n     */\r\n    getVerticesData(kind: string): Nullable<Array<number> | Float32Array>;\r\n    /**\r\n     * Gets the indices from the mesh\r\n     * @returns A nullable array of index arrays\r\n     */\r\n    getIndices?(): Nullable<IndicesArray>;\r\n    /**\r\n     * Gets the scene from the mesh\r\n     * @returns the indices array or null\r\n     */\r\n    getScene?(): Scene;\r\n    /**\r\n     * Gets the absolute position from the mesh\r\n     * @returns the absolute position\r\n     */\r\n    getAbsolutePosition(): Vector3;\r\n    /**\r\n     * Gets the absolute pivot point from the mesh\r\n     * @returns the absolute pivot point\r\n     */\r\n    getAbsolutePivotPoint(): Vector3;\r\n    /**\r\n     * Rotates the mesh\r\n     * @param axis The axis of rotation\r\n     * @param amount The amount of rotation\r\n     * @param space The space of the rotation\r\n     * @returns The rotation transform node\r\n     */\r\n    rotate(axis: Vector3, amount: number, space?: Space): TransformNode;\r\n    /**\r\n     * Translates the mesh\r\n     * @param axis The axis of translation\r\n     * @param distance The distance of translation\r\n     * @param space The space of the translation\r\n     * @returns The transform node\r\n     */\r\n    translate(axis: Vector3, distance: number, space?: Space): TransformNode;\r\n    /**\r\n     * Sets the absolute position of the mesh\r\n     * @param absolutePosition The absolute position of the mesh\r\n     * @returns The transform node\r\n     */\r\n    setAbsolutePosition(absolutePosition: Vector3): TransformNode;\r\n    /**\r\n     * Gets the class name of the mesh\r\n     * @returns The class name\r\n     */\r\n    getClassName(): string;\r\n}\r\n\r\nMesh._PhysicsImpostorParser = function (scene: Scene, physicObject: IPhysicsEnabledObject, jsonObject: any): PhysicsImpostor {\r\n    return new PhysicsImpostor(\r\n        physicObject,\r\n        jsonObject.physicsImpostor,\r\n        {\r\n            mass: jsonObject.physicsMass,\r\n            friction: jsonObject.physicsFriction,\r\n            restitution: jsonObject.physicsRestitution,\r\n        },\r\n        scene\r\n    );\r\n};\r\n\r\n/**\r\n * Represents a physics imposter\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsImpostor {\r\n    /**\r\n     * The default object size of the imposter\r\n     */\r\n    public static DEFAULT_OBJECT_SIZE: Vector3 = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * The identity quaternion of the imposter\r\n     */\r\n    public static IDENTITY_QUATERNION = Quaternion.Identity();\r\n\r\n    /** @internal */\r\n    public _pluginData: any = {};\r\n\r\n    private _physicsEngine: Nullable<IPhysicsEngine>;\r\n    //The native cannon/oimo/energy physics body object.\r\n    private _physicsBody: any;\r\n    private _bodyUpdateRequired: boolean = false;\r\n\r\n    private _onBeforePhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    private _onAfterPhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    /** @internal */\r\n    public _onPhysicsCollideCallbacks: Array<{\r\n        callback: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>, distance: number, impulse: number, normal: Nullable<Vector3>) => void;\r\n        otherImpostors: Array<PhysicsImpostor>;\r\n    }> = [];\r\n\r\n    private _deltaPosition: Vector3 = Vector3.Zero();\r\n    private _deltaRotation: Quaternion;\r\n    private _deltaRotationConjugated: Quaternion;\r\n\r\n    /** @internal */\r\n    public _isFromLine: boolean;\r\n\r\n    //If set, this is this impostor's parent\r\n    private _parent: Nullable<PhysicsImpostor>;\r\n\r\n    private _isDisposed = false;\r\n\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    private static _TmpQuat: Quaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * Specifies if the physics imposter is disposed\r\n     */\r\n    get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics imposter\r\n     */\r\n    get mass(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\r\n    }\r\n\r\n    set mass(value: number) {\r\n        this.setMass(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of friction\r\n     */\r\n    get friction(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of friction\r\n     */\r\n    set friction(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of restitution\r\n     */\r\n    get restitution(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of restitution\r\n     */\r\n    set restitution(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get pressure(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPressure!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set pressure(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return;\r\n        }\r\n        plugin.setBodyPressure!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get stiffness(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyStiffness) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyStiffness!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set stiffness(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyStiffness) {\r\n            return;\r\n        }\r\n        plugin.setBodyStiffness!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get velocityIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyVelocityIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyVelocityIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set velocityIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyVelocityIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyVelocityIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get positionIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyPositionIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPositionIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set positionIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPositionIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyPositionIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * The unique id of the physics imposter\r\n     * set by the physics engine when adding this impostor to the array\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public soft: boolean = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public segments: number = 0;\r\n\r\n    private _joints: Array<{\r\n        joint: PhysicsJoint;\r\n        otherImpostor: PhysicsImpostor;\r\n    }>;\r\n\r\n    /**\r\n     * Initializes the physics imposter\r\n     * @param object The physics-enabled object used as the physics imposter\r\n     * @param type The type of the physics imposter. Types are available as static members of this class.\r\n     * @param _options The options for the physics imposter\r\n     * @param _scene The Babylon scene\r\n     */\r\n    constructor(\r\n        /**\r\n         * The physics-enabled object used as the physics imposter\r\n         */\r\n        public object: IPhysicsEnabledObject,\r\n        /**\r\n         * The type of the physics imposter\r\n         */\r\n        public type: number,\r\n        private _options: PhysicsImpostorParameters = { mass: 0 },\r\n        private _scene?: Scene\r\n    ) {\r\n        //sanity check!\r\n        if (!this.object) {\r\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\r\n            return;\r\n        }\r\n        if (this.object.parent && _options.mass !== 0) {\r\n            Logger.Warn(\"A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.\");\r\n        }\r\n\r\n        // Legacy support for old syntax.\r\n        if (!this._scene && object.getScene) {\r\n            this._scene = object.getScene();\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        if (this.type > 100) {\r\n            this.soft = true;\r\n        }\r\n\r\n        this._physicsEngine = this._scene.getPhysicsEngine();\r\n        if (!this._physicsEngine) {\r\n            Logger.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\r\n        } else {\r\n            //set the object's quaternion, if not set\r\n            if (!this.object.rotationQuaternion) {\r\n                if (this.object.rotation) {\r\n                    this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\r\n                } else {\r\n                    this.object.rotationQuaternion = new Quaternion();\r\n                }\r\n            }\r\n            //default options params\r\n            this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\r\n            this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\r\n            this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\r\n            if (this.soft) {\r\n                //softbody mass must be above 0;\r\n                this._options.mass = this._options.mass > 0 ? this._options.mass : 1;\r\n                this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;\r\n                this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;\r\n                this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;\r\n                this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;\r\n                this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;\r\n                this._options.margin = _options.margin === void 0 ? 0 : _options.margin;\r\n                this._options.damping = _options.damping === void 0 ? 0 : _options.damping;\r\n                this._options.path = _options.path === void 0 ? null : _options.path;\r\n                this._options.shape = _options.shape === void 0 ? null : _options.shape;\r\n            }\r\n            this._joints = [];\r\n            //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\r\n            if (!this.object.parent || this._options.ignoreParent) {\r\n                this._init();\r\n            } else if (this.object.parent.physicsImpostor) {\r\n                Logger.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will completely initialize this impostor.\r\n     * It will create a new body - but only if this mesh has no parent.\r\n     * If it has, this impostor will not be used other than to define the impostor\r\n     * of the child mesh.\r\n     * @internal\r\n     */\r\n    public _init() {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._physicsEngine.removeImpostor(this);\r\n        this.physicsBody = null;\r\n        this._parent = this._parent || this._getPhysicsParent();\r\n        if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {\r\n            this._physicsEngine.addImpostor(this);\r\n        }\r\n    }\r\n\r\n    private _getPhysicsParent(): Nullable<PhysicsImpostor> {\r\n        if (this.object.parent instanceof AbstractMesh) {\r\n            const parentMesh: AbstractMesh = <AbstractMesh>this.object.parent;\r\n            return parentMesh.physicsImpostor;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Should a new body be generated.\r\n     * @returns boolean specifying if body initialization is required\r\n     */\r\n    public isBodyInitRequired(): boolean {\r\n        return this._bodyUpdateRequired || (!this._physicsBody && (!this._parent || !!this._options.ignoreParent));\r\n    }\r\n\r\n    /**\r\n     * Sets the updated scaling\r\n     */\r\n    public setScalingUpdated() {\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Force a regeneration of this or the parent's impostor's body.\r\n     * Use with caution - This will remove all previously-instantiated joints.\r\n     */\r\n    public forceUpdate() {\r\n        this._init();\r\n        if (this.parent && !this._options.ignoreParent) {\r\n            this.parent.forceUpdate();\r\n        }\r\n    }\r\n\r\n    /*public get mesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }*/\r\n\r\n    /**\r\n     * Gets the body that holds this impostor. Either its own, or its parent.\r\n     */\r\n    public get physicsBody(): any {\r\n        return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;\r\n    }\r\n\r\n    /**\r\n     * Get the parent of the physics imposter\r\n     * @returns Physics imposter or null\r\n     */\r\n    public get parent(): Nullable<PhysicsImpostor> {\r\n        return !this._options.ignoreParent && this._parent ? this._parent : null;\r\n    }\r\n\r\n    /**\r\n     * Sets the parent of the physics imposter\r\n     */\r\n    public set parent(value: Nullable<PhysicsImpostor>) {\r\n        this._parent = value;\r\n    }\r\n\r\n    /**\r\n     * Set the physics body. Used mainly by the physics engine/plugin\r\n     */\r\n    public set physicsBody(physicsBody: any) {\r\n        if (this._physicsBody && this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\r\n        }\r\n        this._physicsBody = physicsBody;\r\n        this.resetUpdateFlags();\r\n    }\r\n\r\n    /**\r\n     * Resets the update flags\r\n     */\r\n    public resetUpdateFlags() {\r\n        this._bodyUpdateRequired = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the object extents\r\n     * @returns the object extents\r\n     */\r\n    public getObjectExtents(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const q = this.object.rotationQuaternion;\r\n            const scaling = this.object.scaling.clone();\r\n            //reset rotation\r\n            this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;\r\n            //calculate the world matrix with no rotation\r\n            const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            if (worldMatrix) {\r\n                worldMatrix.decompose(scaling, undefined, undefined);\r\n            }\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            // get the global scaling of the object\r\n            const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);\r\n            size.x = Math.abs(size.x);\r\n            size.y = Math.abs(size.y);\r\n            size.z = Math.abs(size.z);\r\n            //bring back the rotation\r\n            this.object.rotationQuaternion = q;\r\n            //calculate the world matrix with the new rotation\r\n            this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            return size;\r\n        } else {\r\n            return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the object center\r\n     * @returns The object center\r\n     */\r\n    public getObjectCenter(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            return boundingInfo.boundingBox.centerWorld;\r\n        } else {\r\n            return this.object.position;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a specific parameter from the options parameters\r\n     * @param paramName The object parameter name\r\n     * @returns The object parameter\r\n     */\r\n    public getParam(paramName: string): any {\r\n        return (<any>this._options)[paramName];\r\n    }\r\n\r\n    /**\r\n     * Sets a specific parameter in the options given to the physics plugin\r\n     * @param paramName The parameter name\r\n     * @param value The value of the parameter\r\n     */\r\n    public setParam(paramName: string, value: number) {\r\n        (<any>this._options)[paramName] = value;\r\n        this._bodyUpdateRequired = true;\r\n    }\r\n\r\n    /**\r\n     * Specifically change the body's mass. Won't recreate the physics body object\r\n     * @param mass The mass of the physics imposter\r\n     */\r\n    public setMass(mass: number) {\r\n        if (this.getParam(\"mass\") !== mass) {\r\n            this.setParam(\"mass\", mass);\r\n        }\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity\r\n     * @returns  linear velocity or null\r\n     */\r\n    public getLinearVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity\r\n     * @param velocity  linear velocity or null\r\n     */\r\n    public setLinearVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity\r\n     * @returns angular velocity or null\r\n     */\r\n    public getAngularVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity\r\n     * @param velocity The velocity or null\r\n     */\r\n    public setAngularVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a function with the physics plugin native code\r\n     * Provide a function the will have two variables - the world object and the physics body object\r\n     * @param func The function to execute with the physics plugin native code\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsBody: any) => void) {\r\n        if (this._physicsEngine) {\r\n            func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public registerBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onBeforePhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregister a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public unregisterBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onBeforePhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onBeforePhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public registerAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onAfterPhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public unregisterAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onAfterPhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onAfterPhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * register a function that will be executed when this impostor collides against a different body\r\n     * @param collideAgainst Physics imposter, or array of physics imposters to collide against\r\n     * @param func Callback that is executed on collision\r\n     */\r\n    public registerOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });\r\n    }\r\n\r\n    /**\r\n     * Unregisters the physics imposter's collision callback\r\n     * @param collideAgainst The physics object to collide against\r\n     * @param func Callback to execute on collision\r\n     */\r\n    public unregisterOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor | Array<PhysicsImpostor>, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        let index = -1;\r\n        const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {\r\n            if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {\r\n                // chcek the arrays match\r\n                const sameList = cbDef.otherImpostors.every((impostor) => {\r\n                    return collidedAgainstList.indexOf(impostor) > -1;\r\n                });\r\n                if (sameList) {\r\n                    index = idx;\r\n                }\r\n                return sameList;\r\n            }\r\n            return false;\r\n        });\r\n\r\n        if (found) {\r\n            this._onPhysicsCollideCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    //temp variables for parent rotation calculations\r\n    //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _tmpQuat2: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Get the parent rotation\r\n     * @returns The parent rotation\r\n     */\r\n    public getParentsRotation(): Quaternion {\r\n        let parent = this.object.parent;\r\n        this._tmpQuat.copyFromFloats(0, 0, 0, 1);\r\n        while (parent) {\r\n            if (parent.rotationQuaternion) {\r\n                this._tmpQuat2.copyFrom(parent.rotationQuaternion);\r\n            } else {\r\n                Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);\r\n            }\r\n            this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);\r\n            parent = parent.parent;\r\n        }\r\n        return this._tmpQuat;\r\n    }\r\n\r\n    /**\r\n     * this function is executed by the physics engine.\r\n     */\r\n    public beforeStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this.object.translate(this._deltaPosition, -1);\r\n        this._deltaRotationConjugated &&\r\n            this.object.rotationQuaternion &&\r\n            this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);\r\n        this.object.computeWorldMatrix(false);\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);\r\n        } else {\r\n            this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());\r\n        }\r\n        if (!this._options.disableBidirectionalTransformation) {\r\n            this.object.rotationQuaternion &&\r\n                this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this, /*bInfo.boundingBox.centerWorld*/ this.object.getAbsolutePosition(), this._tmpQuat);\r\n        }\r\n\r\n        this._onBeforePhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * this function is executed by the physics engine\r\n     */\r\n    public afterStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._onAfterPhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n\r\n        this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);\r\n        // object has now its world rotation. needs to be converted to local.\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.conjugateInPlace();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);\r\n        }\r\n        // take the position set and make it the absolute position of this object.\r\n        this.object.setAbsolutePosition(this.object.position);\r\n        if (this._deltaRotation) {\r\n            this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);\r\n            this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, PhysicsImpostor._TmpVecs[0]);\r\n            this.object.translate(PhysicsImpostor._TmpVecs[0], 1);\r\n        } else {\r\n            this.object.translate(this._deltaPosition, 1);\r\n        }\r\n        this.object.computeWorldMatrix(true);\r\n    };\r\n\r\n    /**\r\n     * Legacy collision detection event support\r\n     */\r\n    public onCollideEvent: Nullable<(collider: PhysicsImpostor, collidedWith: PhysicsImpostor) => void> = null;\r\n\r\n    /**\r\n     * event and body object due to cannon's event-based architecture.\r\n     * @param e\r\n     * @param e.body\r\n     * @param e.point\r\n     * @param e.distance\r\n     * @param e.impulse\r\n     * @param e.normal\r\n     */\r\n    public onCollide = (e: { body: any; point: Nullable<Vector3>; distance: number; impulse: number; normal: Nullable<Vector3> }) => {\r\n        if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {\r\n            return;\r\n        }\r\n\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);\r\n        if (otherImpostor) {\r\n            // Legacy collision detection event support\r\n            if (this.onCollideEvent) {\r\n                this.onCollideEvent(this, otherImpostor);\r\n            }\r\n            this._onPhysicsCollideCallbacks\r\n                .filter((obj) => {\r\n                    return obj.otherImpostors.indexOf(<PhysicsImpostor>otherImpostor) !== -1;\r\n                })\r\n                .forEach((obj) => {\r\n                    obj.callback(this, <PhysicsImpostor>otherImpostor, e.point, e.distance, e.impulse, e.normal);\r\n                });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply a force\r\n     * @param force The force to apply\r\n     * @param contactPoint The contact point for the force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyForce(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Apply an impulse\r\n     * @param force The impulse force\r\n     * @param contactPoint The contact point for the impulse force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyImpulse(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A help function to create a joint\r\n     * @param otherImpostor A physics imposter used to create a joint\r\n     * @param jointType The type of joint\r\n     * @param jointData The data for the joint\r\n     * @returns The physics imposter\r\n     */\r\n    public createJoint(otherImpostor: PhysicsImpostor, jointType: number, jointData: PhysicsJointData): PhysicsImpostor {\r\n        const joint = new PhysicsJoint(jointType, jointData);\r\n        this.addJoint(otherImpostor, joint);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a joint to this impostor with a different impostor\r\n     * @param otherImpostor A physics imposter used to add a joint\r\n     * @param joint The joint to add\r\n     * @returns The physics imposter\r\n     */\r\n    public addJoint(otherImpostor: PhysicsImpostor, joint: PhysicsJoint): PhysicsImpostor {\r\n        this._joints.push({\r\n            otherImpostor: otherImpostor,\r\n            joint: joint,\r\n        });\r\n\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.addJoint(this, otherImpostor, joint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add an anchor to a cloth impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false\r\n     * @returns impostor the soft imposter\r\n     */\r\n    public addAnchor(otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendAnchor!(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a hook to a rope impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param length ratio across rope from 0 to 1\r\n     * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     * @returns impostor the rope imposter\r\n     */\r\n    public addHook(otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendHook!(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will keep this body still, in a sleep mode.\r\n     * @returns the physics imposter\r\n     */\r\n    public sleep(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().sleepBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Wake the body up.\r\n     * @returns The physics imposter\r\n     */\r\n    public wakeUp(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clones the physics imposter\r\n     * @param newObject The physics imposter clones to this physics-enabled object\r\n     * @returns A nullable physics imposter\r\n     */\r\n    public clone(newObject: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        if (!newObject) {\r\n            return null;\r\n        }\r\n        return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\r\n    }\r\n\r\n    /**\r\n     * Disposes the physics imposter\r\n     */\r\n    public dispose(/*disposeChildren: boolean = true*/) {\r\n        //no dispose if no physics engine is available.\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._joints.forEach((j) => {\r\n            if (this._physicsEngine) {\r\n                this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);\r\n            }\r\n        });\r\n        //dispose the physics body\r\n        this._physicsEngine.removeImpostor(this);\r\n        if (this.parent) {\r\n            this.parent.forceUpdate();\r\n        } else {\r\n            /*this._object.getChildMeshes().forEach(function(mesh) {\r\n                if (mesh.physicsImpostor) {\r\n                    if (disposeChildren) {\r\n                        mesh.physicsImpostor.dispose();\r\n                        mesh.physicsImpostor = null;\r\n                    }\r\n                }\r\n            })*/\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the delta position\r\n     * @param position The delta position amount\r\n     */\r\n    public setDeltaPosition(position: Vector3) {\r\n        this._deltaPosition.copyFrom(position);\r\n    }\r\n\r\n    /**\r\n     * Sets the delta rotation\r\n     * @param rotation The delta rotation amount\r\n     */\r\n    public setDeltaRotation(rotation: Quaternion) {\r\n        if (!this._deltaRotation) {\r\n            this._deltaRotation = new Quaternion();\r\n        }\r\n        this._deltaRotation.copyFrom(rotation);\r\n        this._deltaRotationConjugated = this._deltaRotation.conjugate();\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the physics imposter and stores the result in the input parameter\r\n     * @param result Stores the box size\r\n     * @returns The physics imposter\r\n     */\r\n    public getBoxSizeToRef(result: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the physics imposter\r\n     * @returns Radius of the physics imposter\r\n     */\r\n    public getRadius(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sync a bone with this impostor\r\n     * @param bone The bone to sync to the impostor.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     */\r\n    public syncBoneWithImpostor(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion) {\r\n        const tempVec = PhysicsImpostor._TmpVecs[0];\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\r\n                bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);\r\n            } else {\r\n                bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);\r\n            }\r\n        }\r\n\r\n        tempVec.x = 0;\r\n        tempVec.y = 0;\r\n        tempVec.z = 0;\r\n\r\n        if (jointPivot) {\r\n            tempVec.x = jointPivot.x;\r\n            tempVec.y = jointPivot.y;\r\n            tempVec.z = jointPivot.z;\r\n\r\n            bone.getDirectionToRef(tempVec, boneMesh, tempVec);\r\n\r\n            if (distToJoint === undefined || distToJoint === null) {\r\n                distToJoint = jointPivot.length();\r\n            }\r\n\r\n            tempVec.x *= distToJoint;\r\n            tempVec.y *= distToJoint;\r\n            tempVec.z *= distToJoint;\r\n        }\r\n\r\n        if (bone.getParent()) {\r\n            tempVec.addInPlace(mesh.getAbsolutePosition());\r\n            bone.setAbsolutePosition(tempVec, boneMesh);\r\n        } else {\r\n            boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\r\n            boneMesh.position.x -= tempVec.x;\r\n            boneMesh.position.y -= tempVec.y;\r\n            boneMesh.position.z -= tempVec.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sync impostor to a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncImpostorWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = PhysicsImpostor._TmpVecs[0];\r\n        const boneDir = PhysicsImpostor._TmpVecs[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = PhysicsImpostor._TmpVecs[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    //Impostor types\r\n    /**\r\n     * No-Imposter type\r\n     */\r\n    public static NoImpostor = 0;\r\n    /**\r\n     * Sphere-Imposter type\r\n     */\r\n    public static SphereImpostor = 1;\r\n    /**\r\n     * Box-Imposter type\r\n     */\r\n    public static BoxImpostor = 2;\r\n    /**\r\n     * Plane-Imposter type\r\n     */\r\n    public static PlaneImpostor = 3;\r\n    /**\r\n     * Mesh-imposter type (Only available to objects with vertices data)\r\n     */\r\n    public static MeshImpostor = 4;\r\n    /**\r\n     * Capsule-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static CapsuleImpostor = 6;\r\n    /**\r\n     * Cylinder-Imposter type\r\n     */\r\n    public static CylinderImpostor = 7;\r\n    /**\r\n     * Particle-Imposter type\r\n     */\r\n    public static ParticleImpostor = 8;\r\n    /**\r\n     * Heightmap-Imposter type\r\n     */\r\n    public static HeightmapImpostor = 9;\r\n    /**\r\n     * ConvexHull-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static ConvexHullImpostor = 10;\r\n    /**\r\n     * Custom-Imposter type (Ammo.js plugin only)\r\n     */\r\n    public static CustomImpostor = 100;\r\n    /**\r\n     * Rope-Imposter type\r\n     */\r\n    public static RopeImpostor = 101;\r\n    /**\r\n     * Cloth-Imposter type\r\n     */\r\n    public static ClothImpostor = 102;\r\n    /**\r\n     * Softbody-Imposter type\r\n     */\r\n    public static SoftbodyImpostor = 103;\r\n}\r\n","import type { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\n/**\r\n * Interface for Physics-Joint data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface PhysicsJointData {\r\n    //Important for some engines, optional!\r\n    /**\r\n     * The main pivot of the joint\r\n     */\r\n    mainPivot?: Vector3;\r\n    /**\r\n     * The connected pivot of the joint\r\n     */\r\n    connectedPivot?: Vector3;\r\n    /**\r\n     * The main axis of the joint\r\n     */\r\n    mainAxis?: Vector3;\r\n    /**\r\n     * The connected axis of the joint\r\n     */\r\n    connectedAxis?: Vector3;\r\n    /**\r\n     * The collision of the joint\r\n     */\r\n    collision?: boolean;\r\n    /**\r\n     * Native Oimo/Cannon/Energy data\r\n     */\r\n    nativeParams?: any;\r\n}\r\n\r\n/**\r\n * This is a holder class for the physics joint created by the physics plugin\r\n * It holds a set of functions to control the underlying joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsJoint {\r\n    private _physicsJoint: any;\r\n    protected _physicsPlugin: IPhysicsEnginePlugin;\r\n\r\n    /**\r\n     * Initializes the physics joint\r\n     * @param type The type of the physics joint\r\n     * @param jointData The data for the physics joint\r\n     */\r\n    constructor(\r\n        /**\r\n         * The type of the physics joint\r\n         */\r\n        public type: number,\r\n        /**\r\n         * The data for the physics joint\r\n         */\r\n        public jointData: PhysicsJointData\r\n    ) {\r\n        jointData.nativeParams = jointData.nativeParams || {};\r\n    }\r\n\r\n    /**\r\n     * Gets the physics joint\r\n     */\r\n    public get physicsJoint(): any {\r\n        return this._physicsJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics joint\r\n     */\r\n    public set physicsJoint(newJoint: any) {\r\n        if (this._physicsJoint) {\r\n            //remove from the world\r\n        }\r\n\r\n        this._physicsJoint = newJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics plugin\r\n     */\r\n    public set physicsPlugin(physicsPlugin: IPhysicsEnginePlugin) {\r\n        this._physicsPlugin = physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Execute a function that is physics-plugin specific.\r\n     * @param {Function} func the function that will be executed.\r\n     *                        It accepts two parameters: the physics world and the physics joint\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsJoint: any) => void) {\r\n        func(this._physicsPlugin.world, this._physicsJoint);\r\n    }\r\n\r\n    //TODO check if the native joints are the same\r\n\r\n    //Joint Types\r\n    /**\r\n     * Distance-Joint type\r\n     */\r\n    public static DistanceJoint = 0;\r\n    /**\r\n     * Hinge-Joint type\r\n     */\r\n    public static HingeJoint = 1;\r\n    /**\r\n     * Ball-and-Socket joint type\r\n     */\r\n    public static BallAndSocketJoint = 2;\r\n    /**\r\n     * Wheel-Joint type\r\n     */\r\n    public static WheelJoint = 3;\r\n    /**\r\n     * Slider-Joint type\r\n     */\r\n    public static SliderJoint = 4;\r\n    //OIMO\r\n    /**\r\n     * Prismatic-Joint type\r\n     */\r\n    public static PrismaticJoint = 5;\r\n    //\r\n    /**\r\n     * Universal-Joint type\r\n     * ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)\r\n     */\r\n    public static UniversalJoint = 6;\r\n    /**\r\n     * Hinge-Joint 2 type\r\n     */\r\n    public static Hinge2Joint = PhysicsJoint.WheelJoint;\r\n    //Cannon\r\n    /**\r\n     * Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters\r\n     */\r\n    public static PointToPointJoint = 8;\r\n    //Cannon only at the moment\r\n    /**\r\n     * Spring-Joint type\r\n     */\r\n    public static SpringJoint = 9;\r\n    /**\r\n     * Lock-Joint type\r\n     */\r\n    public static LockJoint = 10;\r\n}\r\n\r\n/**\r\n * A class representing a physics distance joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class DistanceJoint extends PhysicsJoint {\r\n    /**\r\n     *\r\n     * @param jointData The data for the Distance-Joint\r\n     */\r\n    constructor(jointData: DistanceJointData) {\r\n        super(PhysicsJoint.DistanceJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Update the predefined distance.\r\n     * @param maxDistance The maximum preferred distance\r\n     * @param minDistance The minimum preferred distance\r\n     */\r\n    public updateDistance(maxDistance: number, minDistance?: number) {\r\n        this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Motor-Enabled Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {\r\n    /**\r\n     * Initializes the Motor-Enabled Joint\r\n     * @param type The type of the joint\r\n     * @param jointData The physical joint data for the joint\r\n     */\r\n    constructor(type: number, jointData: PhysicsJointData) {\r\n        super(type, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param force the force to apply\r\n     * @param maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a single physics Hinge-Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class HingeJoint extends MotorEnabledJoint {\r\n    /**\r\n     * Initializes the Hinge-Joint\r\n     * @param jointData The joint data for the Hinge-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.HingeJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param {number} force the force to apply\r\n     * @param {number} maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a dual hinge physics joint (same as wheel joint)\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class Hinge2Joint extends MotorEnabledJoint {\r\n    /**\r\n     * Initializes the Hinge2-Joint\r\n     * @param jointData The joint data for the Hinge2-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.Hinge2Joint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param targetSpeed the speed the motor is to reach\r\n     * @param maxForce max force for this motor.\r\n     * @param motorIndex motor's index, 0 or 1.\r\n     */\r\n    public setMotor(targetSpeed?: number, maxForce?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);\r\n    }\r\n\r\n    /**\r\n     * Set the motor limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit the upper limit\r\n     * @param lowerLimit lower limit\r\n     * @param motorIndex the motor's index, 0 or 1.\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for a motor enabled joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface IMotorEnabledJoint {\r\n    /**\r\n     * Physics joint\r\n     */\r\n    physicsJoint: any;\r\n    /**\r\n     * Sets the motor of the motor-enabled joint\r\n     * @param force The force of the motor\r\n     * @param maxForce The maximum force of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setMotor(force?: number, maxForce?: number, motorIndex?: number): void;\r\n    /**\r\n     * Sets the limit of the motor\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;\r\n}\r\n\r\n/**\r\n * Joint data for a Distance-Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface DistanceJointData extends PhysicsJointData {\r\n    /**\r\n     * Max distance the 2 joint objects can be apart\r\n     */\r\n    maxDistance: number;\r\n    //Oimo - minDistance\r\n    //Cannon - maxForce\r\n}\r\n\r\n/**\r\n * Joint data from a spring joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface SpringJointData extends PhysicsJointData {\r\n    /**\r\n     * Length of the spring\r\n     */\r\n    length: number;\r\n    /**\r\n     * Stiffness of the spring\r\n     */\r\n    stiffness: number;\r\n    /**\r\n     * Damping of the spring\r\n     */\r\n    damping: number;\r\n    /** this callback will be called when applying the force to the impostors. */\r\n    forceApplicationCallback: () => void;\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"colorPixelShader\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\r#else\nuniform vec4 color;\r#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\r#else\ngl_FragColor=color;\r#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\n\nconst name = \"colorVertexShader\";\nconst shader = `attribute vec3 position;\r#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\r#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\r#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\rgl_Position=viewProjection*worldPos;\r} else {\rgl_Position=viewProjectionR*worldPos;\r}\r#else\ngl_Position=viewProjection*worldPos;\r#endif\n#include<clipPlaneVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorVertexShader = { name, shader };\n"],"names":["CreateLineSystemVertexData","options","indices","positions","lines","colors","vertexColors","idx","l","length","points","index","push","x","y","z","color","r","g","b","a","vertexData","CreateDashedLinesVertexData","dashSize","gapSize","dashNb","Array","curvect","lg","nb","shft","dashshft","curshft","i","subtractToRef","Math","floor","normalize","j","CreateLineSystem","name","scene","instance","getVerticesData","vertexColor","lineColors","c","p","updateVerticesData","useVertexColor","lineSystem","undefined","useVertexAlpha","material","applyToMesh","updatable","CreateLines","CreateDashedLines","positionFunction","nbSeg","_creationDataStorage","updateMeshPositions","dashedLines","LinesBuilder","CreateRibbonVertexData","pathArray","closeArray","closePath","invertUV","defaultOffset","offset","sideOrientation","customUV","uvs","customColors","normals","us","vs","uTotalDistance","vTotalDistance","minlg","ar1","ar2","idc","closePathCorr","path","vectlg","dist","path1","path2","subtract","u","v","vertex1","vertex2","pi","l1","l2","min","path1nb","indexFirst","indexLast","frontUVs","backUVs","Float32Array","positions32","normals32","uvs32","set","_idx","CreateRibbon","minimum","Number","MAX_VALUE","maximum","mesh","ns","_originalBuilderSideOrientation","si","pathPoint","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","hasBoundingInfo","getBoundingInfo","reConstruct","_worldMatrix","buildBoundingInfo","colorIndex","areNormalsFrozen","isFacetDataEnabled","getIndices","params","getFacetDataParameters","ribbon","RibbonBuilder","ExtrudeShape","shape","scale","rotation","cap","closeShape","_ExtrudeShapeGeneric","firstNormal","adjustFrame","ExtrudeShapeCustom","scaleFunction","rotationFunction","ribbonCloseArray","ribbonClosePath","curve","rotateFunction","rbCA","rbCP","custom","updtbl","side","extrusionPathArray","path3D","shapePaths","tangents","getTangents","getNormals","binormals","getBinormals","distances","getDistances","copyFrom","scaleInPlace","angle","rotate","scl","rotationMatrix","shapePath","angleStep","scaleRatio","planed","add","rotated","addInPlace","capPath","pointCap","barycenter","storage","update","extrudedGeneric","ShapeBuilder","InstancedMesh","instancedBuffers","key","constructor","source","super","getScene","_indexInSourceMeshInstanceArray","_distanceToCamera","addInstance","this","_sourceMesh","_unIndexed","position","scaling","rotationQuaternion","clone","animations","slice","range","getAnimationRanges","createAnimationRange","from","to","infiniteDistance","setPivotMatrix","getPivotMatrix","refreshBoundingInfo","_syncSubMeshes","getClassName","lightSources","_lightSources","_resyncLightSources","_resyncLightSource","_removeLightSource","receiveShadows","visibility","skeleton","renderingGroupId","value","getTotalVertices","getTotalIndices","sourceMesh","createInstance","isReady","completeCheck","kind","copyWhenShared","setVerticesData","data","stride","updateExtends","makeItUnique","setIndices","totalVertices","isVerticesDataPresent","_positions","applySkeleton","applyMorph","isLocked","bias","geometry","boundingBias","_refreshBoundingInfo","_getPositionData","_preActivate","_currentLOD","_activate","renderId","intermediateRendering","subMeshes","_getWorldMatrixDeterminant","_internalAbstractMeshDataInfo","_actAsRegularMesh","_registerInstanceForRenderId","_isActiveIntermediate","_onlyForInstancesIntermediate","_isActive","_onlyForInstances","_postActivate","edgesShareWithInstances","_edgesRenderer","isEnabled","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","getWorldMatrix","billboardMode","_masterMesh","_billboardWorldMatrix","tempMaster","computeWorldMatrix","isAnInstance","getLOD","camera","sourceMeshLODLevels","getLODLevels","boundingInfo","boundingSphere","_preActivateForIntermediateRendering","releaseSubMeshes","_generatePointsArray","_updateBoundingInfo","worldMatrixFromCache","absolutePosition","_updateSubMeshesBoundingInfo","newParent","doNotCloneChildren","newSourceMesh","result","parent","meshes","onClonedObservable","notifyObservers","dispose","doNotRecurse","disposeMaterialAndTextures","removeInstance","_serializeAsParent","serializationObject","parentId","uniqueId","parentInstanceIndex","instantiateHierarchy","onNewNodeCreated","id","newSourcedMesh","child","getChildTransformNodes","_userInstancedBuffersStorage","vertexBuffers","instances","strides","sizes","vertexArrayObjects","getEngine","getCaps","vertexArrayObject","_invalidateInstanceVertexArrayObject","_markSubMeshesAsAttributesDirty","visibleInstances","renderSelf","instanceCount","size","expectedSize","toArray","copyToArray","instanceIndex","updateDirectly","releaseVertexArrayObject","_instanceDataStorage","instancesBuffer","parsedMesh","LinesMesh","Parse","alpha","intersectionThreshold","attributes","uniforms","needAlphaBlending","defines","useClipPlane","_color4","_isShaderMaterial","shader","_lineMaterial","fillMode","checkCollisions","_bind","_geometry","colorEffect","getEffect","indexToBind","isUnIndexed","getIndexBuffer","setColor4","_draw","subMesh","instancesCount","getVertexBuffers","engine","drawArraysType","verticesStart","verticesCount","drawElementsType","indexStart","indexCount","InstancedLinesMesh","serialize","asArray","static","physicObject","jsonObject","PhysicsImpostor","physicsImpostor","mass","physicsMass","friction","physicsFriction","restitution","physicsRestitution","object","type","_options","_scene","_pluginData","_bodyUpdateRequired","_onBeforePhysicsStepCallbacks","_onAfterPhysicsStepCallbacks","_onPhysicsCollideCallbacks","_deltaPosition","_isDisposed","soft","segments","_tmpQuat","_tmpQuat2","beforeStep","_physicsEngine","translate","_deltaRotationConjugated","multiplyToRef","getParentsRotation","disableBidirectionalTransformation","getPhysicsPlugin","setPhysicsBodyTransformation","getAbsolutePosition","forEach","func","afterStep","setTransformationFromPhysicsBody","conjugateInPlace","setAbsolutePosition","_deltaRotation","applyRotationQuaternionToRef","_TmpVecs","onCollideEvent","onCollide","e","otherImpostor","getImpostorWithPhysicsBody","body","filter","obj","otherImpostors","indexOf","callback","point","distance","impulse","normal","getPhysicsEngine","pressure","stiffness","velocityIterations","positionIterations","fixedPoints","margin","damping","_joints","ignoreParent","_init","isDisposed","getBodyMass","setMass","getBodyFriction","setBodyFriction","getBodyRestitution","setBodyRestitution","plugin","setBodyPressure","getBodyPressure","getBodyStiffness","setBodyStiffness","getBodyVelocityIterations","setBodyVelocityIterations","getBodyPositionIterations","setBodyPositionIterations","removeImpostor","physicsBody","_parent","_getPhysicsParent","addImpostor","isBodyInitRequired","_physicsBody","setScalingUpdated","forceUpdate","removePhysicsBody","resetUpdateFlags","getObjectExtents","q","IDENTITY_QUATERNION","worldMatrix","decompose","boundingBox","extendSize","multiplyInPlace","abs","DEFAULT_OBJECT_SIZE","getObjectCenter","centerWorld","getParam","paramName","setParam","setBodyMass","getLinearVelocity","setLinearVelocity","velocity","getAngularVelocity","setAngularVelocity","executeNativeFunction","world","registerBeforePhysicsStep","unregisterBeforePhysicsStep","splice","registerAfterPhysicsStep","unregisterAfterPhysicsStep","registerOnPhysicsCollide","collideAgainst","collidedAgainstList","unregisterOnPhysicsCollide","some","cbDef","sameList","every","impostor","copyFromFloats","applyForce","force","contactPoint","applyImpulse","createJoint","jointType","jointData","joint","addJoint","addAnchor","width","height","influence","noCollisionBetweenLinkedBodies","appendAnchor","addHook","appendHook","sleep","sleepBody","wakeUp","wakeUpBody","newObject","removeJoint","setDeltaPosition","setDeltaRotation","conjugate","getBoxSizeToRef","getRadius","syncBoneWithImpostor","bone","boneMesh","jointPivot","distToJoint","adjustRotation","tempVec","tempQuat","_TmpQuat","setRotationQuaternion","getDirectionToRef","getParent","syncImpostorWithBone","boneAxis","getRotationQuaternionToRef","pos","boneDir","getAbsolutePositionToRef","NoImpostor","SphereImpostor","BoxImpostor","PlaneImpostor","MeshImpostor","CapsuleImpostor","CylinderImpostor","ParticleImpostor","HeightmapImpostor","ConvexHullImpostor","CustomImpostor","RopeImpostor","ClothImpostor","SoftbodyImpostor","PhysicsJoint","nativeParams","physicsJoint","_physicsJoint","newJoint","physicsPlugin","_physicsPlugin","DistanceJoint","HingeJoint","BallAndSocketJoint","WheelJoint","SliderJoint","PrismaticJoint","UniversalJoint","Hinge2Joint","PointToPointJoint","SpringJoint","LockJoint","updateDistance","maxDistance","minDistance","updateDistanceJoint","MotorEnabledJoint","setMotor","maxForce","setLimit","upperLimit","lowerLimit","targetSpeed","motorIndex"],"sourceRoot":""}