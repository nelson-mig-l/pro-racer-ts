{"version":3,"file":"js/907.babylonBundle.js","mappings":"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","sources":["webpack://pro-racer/../lts/core/generated/Physics/Plugins/ammoJSPlugin.ts","webpack://pro-racer/../lts/core/generated/Physics/physicsEngine.ts","webpack://pro-racer/../lts/core/generated/Physics/physicsEngineComponent.ts","webpack://pro-racer/../lts/core/generated/Physics/physicsRaycastResult.ts"],"sourcesContent":["import { Quaternion, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../../Physics/IPhysicsEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { IPhysicsEnabledObject } from \"../../Physics/physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData } from \"../../Physics/physicsJoint\";\r\nimport { PhysicsJoint } from \"../../Physics/physicsJoint\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { ExtrudeShape } from \"../../Meshes/Builders/shapeBuilder\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Ammo: any;\r\n\r\n/**\r\n * AmmoJS Physics plugin\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n * @see https://github.com/kripken/ammo.js/\r\n */\r\nexport class AmmoJSPlugin implements IPhysicsEnginePlugin {\r\n    /**\r\n     * Reference to the Ammo library\r\n     */\r\n    public bjsAMMO: any = {};\r\n    /**\r\n     * Created ammoJS world which physics bodies are added to\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"AmmoJSPlugin\";\r\n\r\n    private _timeStep: number = 1 / 60;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _maxSteps = 5;\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpAmmoTransform: any;\r\n    private _tmpAmmoQuaternion: any;\r\n    private _tmpAmmoConcreteContactResultCallback: any;\r\n    private _collisionConfiguration: any;\r\n    private _dispatcher: any;\r\n    private _overlappingPairCache: any;\r\n    private _solver: any;\r\n    private _softBodySolver: any;\r\n    private _tmpAmmoVectorA: any;\r\n    private _tmpAmmoVectorB: any;\r\n    private _tmpAmmoVectorC: any;\r\n    private _tmpAmmoVectorD: any;\r\n    private _tmpContactCallbackResult = false;\r\n    private _tmpAmmoVectorRCA: any;\r\n    private _tmpAmmoVectorRCB: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _tmpContactPoint = new Vector3();\r\n    private _tmpContactNormal = new Vector3();\r\n    private _tmpContactDistance: number;\r\n    private _tmpContactImpulse: number;\r\n    private _tmpVec3 = new Vector3();\r\n\r\n    private static readonly _DISABLE_COLLISION_FLAG = 4;\r\n    private static readonly _KINEMATIC_FLAG = 2;\r\n    private static readonly _DISABLE_DEACTIVATION_FLAG = 4;\r\n\r\n    /**\r\n     * Initializes the ammoJS plugin\r\n     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\r\n     * @param ammoInjection can be used to inject your own ammo reference\r\n     * @param overlappingPairCache can be used to specify your own overlapping pair cache\r\n     */\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, ammoInjection: any = Ammo, overlappingPairCache: any = null) {\r\n        if (typeof ammoInjection === \"function\") {\r\n            Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\r\n            return;\r\n        } else {\r\n            this.bjsAMMO = ammoInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        // Initialize the physics world\r\n        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\r\n        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\r\n        this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\r\n        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\r\n        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\r\n        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\r\n\r\n        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\r\n        this._tmpAmmoConcreteContactResultCallback.addSingleResult = (contactPoint: any) => {\r\n            contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);\r\n            const worldPoint = contactPoint.getPositionWorldOnA();\r\n            const worldNormal = contactPoint.m_normalWorldOnB;\r\n            this._tmpContactPoint.x = worldPoint.x();\r\n            this._tmpContactPoint.y = worldPoint.y();\r\n            this._tmpContactPoint.z = worldPoint.z();\r\n            this._tmpContactNormal.x = worldNormal.x();\r\n            this._tmpContactNormal.y = worldNormal.y();\r\n            this._tmpContactNormal.z = worldNormal.z();\r\n            this._tmpContactImpulse = contactPoint.getAppliedImpulse();\r\n            this._tmpContactDistance = contactPoint.getDistance();\r\n            this._tmpContactCallbackResult = true;\r\n        };\r\n\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n\r\n        // Create temp ammo variables\r\n        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\r\n        this._tmpAmmoTransform.setIdentity();\r\n        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\r\n        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world (m/(s^2))\r\n     * @param gravity Gravity to set\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\r\n        this.world.setGravity(this._tmpAmmoVectorA);\r\n        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\r\n    }\r\n\r\n    /**\r\n     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @param timeStep timestep to use in seconds\r\n     */\r\n    public setTimeStep(timeStep: number) {\r\n        this._timeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\r\n     * @param fixedTimeStep fixedTimeStep to use in seconds\r\n     */\r\n    public setFixedTimeStep(fixedTimeStep: number) {\r\n        this._fixedTimeStep = fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum number of steps by the physics engine per frame (Default: 5)\r\n     * @param maxSteps the maximum number of steps by the physics engine per frame\r\n     */\r\n    public setMaxSteps(maxSteps: number) {\r\n        this._maxSteps = maxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @returns the current timestep in seconds\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor\r\n     */\r\n    public onCreateCustomShape: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom mesh impostor handler function to support building custom mesh impostor vertex data\r\n     */\r\n    public onCreateCustomMeshImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom convex hull impostor handler function to support building custom convex hull impostor vertex data\r\n     */\r\n    public onCreateCustomConvexHullImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\r\n    private _isImpostorInContact(impostor: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n    // Ammo's collision events have some weird quirks\r\n    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\r\n    // so only fire event if both contactTest and contactPairTest have a hit\r\n    private _isImpostorPairInContact(impostorA: PhysicsImpostor, impostorB: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n\r\n    // Ammo's behavior when maxSteps > 0 does not behave as described in docs\r\n    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\r\n    //\r\n    // When maxSteps is 0 do the entire simulation in one step\r\n    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\r\n    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\r\n    private _stepSimulation(timeStep: number = 1 / 60, maxSteps: number = 10, fixedTimeStep: number = 1 / 60) {\r\n        if (maxSteps == 0) {\r\n            this.world.stepSimulation(timeStep, 0);\r\n        } else {\r\n            while (maxSteps > 0 && timeStep > 0) {\r\n                if (timeStep - fixedTimeStep < fixedTimeStep) {\r\n                    this.world.stepSimulation(timeStep, 0);\r\n                    timeStep = 0;\r\n                } else {\r\n                    timeStep -= fixedTimeStep;\r\n                    this.world.stepSimulation(fixedTimeStep, 0);\r\n                }\r\n                maxSteps--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves the physics simulation forward delta seconds and updates the given physics imposters\r\n     * Prior to the step the imposters physics location is set to the position of the babylon meshes\r\n     * After the step the babylon meshes are set to the position of the physics imposters\r\n     * @param delta amount of time to step forward\r\n     * @param impostors array of imposters to update before/after the step\r\n     */\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        for (const impostor of impostors) {\r\n            // Update physics world objects to match babylon world\r\n            if (!impostor.soft) {\r\n                impostor.beforeStep();\r\n            }\r\n        }\r\n\r\n        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\r\n\r\n        for (const mainImpostor of impostors) {\r\n            // After physics update make babylon world objects match physics world objects\r\n            if (mainImpostor.soft) {\r\n                this._afterSoftStep(mainImpostor);\r\n            } else {\r\n                mainImpostor.afterStep();\r\n            }\r\n\r\n            // Handle collision event\r\n            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\r\n                if (this._isImpostorInContact(mainImpostor)) {\r\n                    for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\r\n                        for (const otherImpostor of collideCallback.otherImpostors) {\r\n                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\r\n                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\r\n                                    mainImpostor.onCollide({\r\n                                        body: otherImpostor.physicsBody,\r\n                                        point: this._tmpContactPoint,\r\n                                        distance: this._tmpContactDistance,\r\n                                        impulse: this._tmpContactImpulse,\r\n                                        normal: this._tmpContactNormal,\r\n                                    });\r\n                                    otherImpostor.onCollide({\r\n                                        body: mainImpostor.physicsBody,\r\n                                        point: this._tmpContactPoint,\r\n                                        distance: this._tmpContactDistance,\r\n                                        impulse: this._tmpContactImpulse,\r\n                                        normal: this._tmpContactNormal,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh to match physics world object\r\n     * @param impostor imposter to match\r\n     */\r\n    private _afterSoftStep(impostor: PhysicsImpostor): void {\r\n        if (impostor.type === PhysicsImpostor.RopeImpostor) {\r\n            this._ropeStep(impostor);\r\n        } else {\r\n            this._softbodyOrClothStep(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _ropeStep(impostor: PhysicsImpostor): void {\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        const nbVertices = bodyVertices.size();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        const path: Array<Vector3> = new Array();\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z();\r\n            path.push(new Vector3(x, y, z));\r\n        }\r\n        const object = impostor.object;\r\n        const shape = impostor.getParam(\"shape\");\r\n        if (impostor._isFromLine) {\r\n            impostor.object = CreateLines(\"lines\", { points: path, instance: <LinesMesh>object });\r\n        } else {\r\n            impostor.object = ExtrudeShape(\"ext\", { shape: shape, path: path, instance: <Mesh>object });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _softbodyOrClothStep(impostor: PhysicsImpostor): void {\r\n        const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\r\n        const object = impostor.object;\r\n        let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!vertexPositions) {\r\n            vertexPositions = [];\r\n        }\r\n        let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n        if (!vertexNormals) {\r\n            vertexNormals = [];\r\n        }\r\n\r\n        const nbVertices = vertexPositions.length / 3;\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        let nx, ny, nz: number;\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z() * normalDirection;\r\n            const nodeNormals = node.get_m_n();\r\n            nx = nodeNormals.x();\r\n            ny = nodeNormals.y();\r\n            nz = nodeNormals.z() * normalDirection;\r\n\r\n            vertexPositions[3 * n] = x;\r\n            vertexPositions[3 * n + 1] = y;\r\n            vertexPositions[3 * n + 2] = z;\r\n            vertexNormals[3 * n] = nx;\r\n            vertexNormals[3 * n + 1] = ny;\r\n            vertexNormals[3 * n + 2] = nz;\r\n        }\r\n\r\n        const vertex_data = new VertexData();\r\n\r\n        vertex_data.positions = vertexPositions;\r\n        vertex_data.normals = vertexNormals;\r\n        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n        if (object && object.getIndices) {\r\n            vertex_data.indices = object.getIndices();\r\n        }\r\n\r\n        vertex_data.applyToMesh(<Mesh>object);\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * Applies an impulse on the imposter\r\n     * @param impostor imposter to apply impulse to\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the impulse on the imposter\r\n     */\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a force on the imposter\r\n     * @param impostor imposter to apply force\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the force on the imposter\r\n     */\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                const localTranslation = impostor.object.getWorldMatrix().getTranslation();\r\n                worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\r\n            } else {\r\n                worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            }\r\n\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyForce(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a physics body using the plugin\r\n     * @param impostor the imposter to create the physics body on\r\n     */\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // Note: this method will not be called on child imposotrs for compound impostors\r\n\r\n        impostor._pluginData.toDispose = [];\r\n\r\n        //parent-child relationship\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const colShape = this._createShape(impostor);\r\n            const mass = impostor.getParam(\"mass\");\r\n            impostor._pluginData.mass = mass;\r\n            if (impostor.soft) {\r\n                colShape.get_m_cfg().set_collisions(0x11);\r\n                colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\r\n                this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\r\n                colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                this.world.addSoftBody(colShape, 1, -1);\r\n                impostor.physicsBody = colShape;\r\n                impostor._pluginData.toDispose.push(colShape);\r\n                this.setBodyPressure(impostor, 0);\r\n                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                    this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\r\n                }\r\n                this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\r\n                this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\r\n                this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\r\n            } else {\r\n                const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\r\n                const startTransform = new this.bjsAMMO.btTransform();\r\n                impostor.object.computeWorldMatrix(true);\r\n                startTransform.setIdentity();\r\n                if (mass !== 0) {\r\n                    colShape.calculateLocalInertia(mass, localInertia);\r\n                }\r\n                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\r\n                this._tmpAmmoQuaternion.setValue(\r\n                    impostor.object.rotationQuaternion!.x,\r\n                    impostor.object.rotationQuaternion!.y,\r\n                    impostor.object.rotationQuaternion!.z,\r\n                    impostor.object.rotationQuaternion!.w\r\n                );\r\n                startTransform.setOrigin(this._tmpAmmoVectorA);\r\n                startTransform.setRotation(this._tmpAmmoQuaternion);\r\n                const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\r\n                const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\r\n                const body = new this.bjsAMMO.btRigidBody(rbInfo);\r\n\r\n                // Make objects kinematic if it's mass is 0\r\n                if (mass === 0) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\r\n                    body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                }\r\n\r\n                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\r\n                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\r\n                }\r\n\r\n                // compute delta position: compensate the difference between shape center and mesh origin\r\n                if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\r\n                    const boundingInfo = impostor.object.getBoundingInfo();\r\n                    this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\r\n                    this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\r\n                    this._tmpVec3.x /= impostor.object.scaling.x;\r\n                    this._tmpVec3.y /= impostor.object.scaling.y;\r\n                    this._tmpVec3.z /= impostor.object.scaling.z;\r\n                    impostor.setDeltaPosition(this._tmpVec3);\r\n                }\r\n\r\n                const group = impostor.getParam(\"group\");\r\n                const mask = impostor.getParam(\"mask\");\r\n                if (group && mask) {\r\n                    this.world.addRigidBody(body, group, mask);\r\n                } else {\r\n                    this.world.addRigidBody(body);\r\n                }\r\n                impostor.physicsBody = body;\r\n                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\r\n            }\r\n            this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\r\n            this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the physics body from the imposter and disposes of the body's memory\r\n     * @param impostor imposter to remove the physics body from\r\n     */\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        if (this.world) {\r\n            if (impostor.soft) {\r\n                this.world.removeSoftBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.removeRigidBody(impostor.physicsBody);\r\n            }\r\n\r\n            if (impostor._pluginData) {\r\n                impostor._pluginData.toDispose.forEach((d: any) => {\r\n                    this.bjsAMMO.destroy(d);\r\n                });\r\n                impostor._pluginData.toDispose = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a joint\r\n     * @param impostorJoint the imposter joint to create the joint with\r\n     */\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n\r\n        const jointData = impostorJoint.joint.jointData;\r\n        if (!jointData.mainPivot) {\r\n            jointData.mainPivot = new Vector3(0, 0, 0);\r\n        }\r\n        if (!jointData.connectedPivot) {\r\n            jointData.connectedPivot = new Vector3(0, 0, 0);\r\n        }\r\n\r\n        let joint: any;\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.DistanceJoint: {\r\n                const distance = (<DistanceJointData>jointData).maxDistance;\r\n                if (distance) {\r\n                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);\r\n                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);\r\n                }\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.HingeJoint: {\r\n                if (!jointData.mainAxis) {\r\n                    jointData.mainAxis = new Vector3(0, 0, 0);\r\n                }\r\n                if (!jointData.connectedAxis) {\r\n                    jointData.connectedAxis = new Vector3(0, 0, 0);\r\n                }\r\n                const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\r\n                const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\r\n                joint = new this.bjsAMMO.btHingeConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z),\r\n                    mainAxis,\r\n                    connectedAxis\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            default:\r\n                Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n        }\r\n        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\r\n        impostorJoint.joint.physicsJoint = joint;\r\n    }\r\n\r\n    /**\r\n     * Removes a joint\r\n     * @param impostorJoint the imposter joint to remove the joint from\r\n     */\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (this.world) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        }\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the triangle mesh\r\n    private _addMeshVerts(btTriangleMesh: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n\r\n            let localMatrix;\r\n\r\n            if (topLevelObject && topLevelObject !== object) {\r\n                // top level matrix used for shape transform doesn't take scale into account.\r\n                // Moreover, every children vertex position must be in that space.\r\n                // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\r\n                let topLevelQuaternion;\r\n                if (topLevelObject.rotationQuaternion) {\r\n                    topLevelQuaternion = topLevelObject.rotationQuaternion;\r\n                } else if (topLevelObject.rotation) {\r\n                    topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\r\n                } else {\r\n                    topLevelQuaternion = Quaternion.Identity();\r\n                }\r\n                const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\r\n                topLevelMatrix.invertToRef(this._tmpMatrix);\r\n                const wm = object.computeWorldMatrix(false);\r\n                localMatrix = wm.multiply(this._tmpMatrix);\r\n            } else {\r\n                // current top level is same as object level -> only use local scaling\r\n                Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                localMatrix = this._tmpMatrix;\r\n            }\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    v = Vector3.TransformCoordinates(v, localMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    /**\r\n     * Initialise the soft body vertices to match its object's (mesh) vertices\r\n     * Softbody vertices (nodes) are in world space and to match this\r\n     * The object's position and rotation is set to zero and so its vertices are also then set in world space\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _softVertexData(impostor: PhysicsImpostor): VertexData {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!vertexNormals) {\r\n                vertexNormals = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const newPoints = [];\r\n            const newNorms = [];\r\n            for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\r\n                n = Vector3.TransformNormal(n, object.getWorldMatrix());\r\n                newPoints.push(v.x, v.y, v.z);\r\n                newNorms.push(n.x, n.y, n.z);\r\n            }\r\n\r\n            const vertex_data = new VertexData();\r\n\r\n            vertex_data.positions = newPoints;\r\n            vertex_data.normals = newNorms;\r\n            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n            if (object && object.getIndices) {\r\n                vertex_data.indices = object.getIndices();\r\n            }\r\n\r\n            vertex_data.applyToMesh(<Mesh>object);\r\n\r\n            object.position = Vector3.Zero();\r\n            object.rotationQuaternion = null;\r\n            object.rotation = Vector3.Zero();\r\n            object.computeWorldMatrix(true);\r\n\r\n            return vertex_data;\r\n        }\r\n        return VertexData.ExtractFromMesh(<Mesh>object);\r\n    }\r\n\r\n    /**\r\n     * Create an impostor's soft body\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createSoftbody(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const triPoints = [];\r\n                const triNorms = [];\r\n                for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                    const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                    const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                    triPoints.push(v.x, v.y, -v.z);\r\n                    triNorms.push(n.x, n.y, -n.z);\r\n                }\r\n                const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\r\n\r\n                const nbVertices = vertexPositions.length / 3;\r\n                const bodyVertices = softBody.get_m_nodes();\r\n                let node: any;\r\n                let nodeNormals: any;\r\n                for (let i = 0; i < nbVertices; i++) {\r\n                    node = bodyVertices.at(i);\r\n                    nodeNormals = node.get_m_n();\r\n                    nodeNormals.setX(triNorms[3 * i]);\r\n                    nodeNormals.setY(triNorms[3 * i + 1]);\r\n                    nodeNormals.setZ(triNorms[3 * i + 2]);\r\n                }\r\n                return softBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create cloth for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createCloth(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const len = vertexPositions.length;\r\n                const segments = Math.sqrt(len / 3);\r\n                impostor.segments = segments;\r\n                const segs = segments - 1;\r\n                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\r\n                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\r\n\r\n                const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(\r\n                    this.world.getWorldInfo(),\r\n                    this._tmpAmmoVectorA,\r\n                    this._tmpAmmoVectorB,\r\n                    this._tmpAmmoVectorC,\r\n                    this._tmpAmmoVectorD,\r\n                    segments,\r\n                    segments,\r\n                    impostor.getParam(\"fixedPoints\"),\r\n                    true\r\n                );\r\n                return clothBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create rope for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createRope(impostor: PhysicsImpostor) {\r\n        let len: number;\r\n        let segments: number;\r\n        const vertex_data = this._softVertexData(impostor);\r\n        const vertexPositions = vertex_data.positions;\r\n        const vertexNormals = vertex_data.normals;\r\n\r\n        if (vertexPositions === null || vertexNormals === null) {\r\n            return new this.bjsAMMO.btCompoundShape();\r\n        }\r\n\r\n        //force the mesh to be updatable\r\n        vertex_data.applyToMesh(<Mesh>impostor.object, true);\r\n\r\n        impostor._isFromLine = true;\r\n\r\n        // If in lines mesh all normals will be zero\r\n        const vertexSquared: Array<number> = <Array<number>>vertexNormals.map((x: number) => x * x);\r\n        const reducer = (accumulator: number, currentValue: number): number => accumulator + currentValue;\r\n        const reduced: number = vertexSquared.reduce(reducer);\r\n\r\n        if (reduced === 0) {\r\n            // line mesh\r\n            len = vertexPositions.length;\r\n            segments = len / 3 - 1;\r\n            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n        } else {\r\n            //extruded mesh\r\n            impostor._isFromLine = false;\r\n            const pathVectors = impostor.getParam(\"path\");\r\n            const shape = impostor.getParam(\"shape\");\r\n            if (shape === null) {\r\n                Logger.Warn(\"No shape available for extruded mesh\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            len = pathVectors.length;\r\n            segments = len - 1;\r\n            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\r\n            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\r\n        }\r\n\r\n        impostor.segments = segments;\r\n\r\n        let fixedPoints = impostor.getParam(\"fixedPoints\");\r\n        fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\r\n\r\n        const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\r\n        ropeBody.get_m_cfg().set_collisions(0x11);\r\n        return ropeBody;\r\n    }\r\n\r\n    /**\r\n     * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\r\n     * @param impostor to create the custom physics shape for\r\n     */\r\n    private _createCustom(impostor: PhysicsImpostor): any {\r\n        let returnValue: any = null;\r\n        if (this.onCreateCustomShape) {\r\n            returnValue = this.onCreateCustomShape(impostor);\r\n        }\r\n        if (returnValue == null) {\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n        }\r\n        return returnValue;\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the convex hull shape\r\n    private _addHullVerts(btConvexHullShape: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btConvexHullShape.addPoint(triPoints[0], true);\r\n                btConvexHullShape.addPoint(triPoints[1], true);\r\n                btConvexHullShape.addPoint(triPoints[2], true);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor, ignoreChildren = false) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue: any;\r\n        const impostorExtents = impostor.getObjectExtents();\r\n\r\n        if (!ignoreChildren) {\r\n            const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n\r\n            // Add shape of all children to the compound shape\r\n            let childrenAdded = 0;\r\n            meshChildren.forEach((childMesh) => {\r\n                const childImpostor = childMesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\r\n                        throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\r\n                    }\r\n                    const shape = this._createShape(childImpostor);\r\n\r\n                    // Position needs to be scaled based on parent's scaling\r\n                    const parentMat = childMesh.parent!.getWorldMatrix().clone();\r\n                    const s = new Vector3();\r\n                    parentMat.decompose(s);\r\n                    this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\r\n\r\n                    this._tmpAmmoQuaternion.setValue(\r\n                        childMesh.rotationQuaternion!.x,\r\n                        childMesh.rotationQuaternion!.y,\r\n                        childMesh.rotationQuaternion!.z,\r\n                        childMesh.rotationQuaternion!.w\r\n                    );\r\n                    this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n                    returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    childImpostor.dispose();\r\n                    childrenAdded++;\r\n                }\r\n            });\r\n\r\n            if (childrenAdded > 0) {\r\n                // Add parents shape as a child if present\r\n                if (impostor.type != PhysicsImpostor.NoImpostor) {\r\n                    const shape = this._createShape(impostor, true);\r\n                    if (shape) {\r\n                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\r\n                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\r\n                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n\r\n                        returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    }\r\n                }\r\n                return returnValue;\r\n            } else {\r\n                // If no children with impostors create the actual shape below instead\r\n                this.bjsAMMO.destroy(returnValue);\r\n                returnValue = null;\r\n            }\r\n        }\r\n\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor:\r\n                // Is there a better way to compare floats number? With an epsilon or with a Math function\r\n                if (Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.y, 0.0001) && Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.z, 0.0001)) {\r\n                    returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\r\n                } else {\r\n                    // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\r\n                    const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\r\n                    const radii = [1];\r\n                    returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\r\n                    returnValue.setLocalScaling(new this.bjsAMMO.btVector3(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2));\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CapsuleImpostor:\r\n                {\r\n                    // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\r\n                    // Height is just the height between the center of each 'sphere' of the capsule caps\r\n                    const capRadius = impostorExtents.x / 2;\r\n                    returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, impostorExtents.y - capRadius * 2);\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor:\r\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\r\n                returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.PlaneImpostor:\r\n            case PhysicsImpostor.BoxImpostor:\r\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\r\n                returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                if (impostor.getParam(\"mass\") == 0) {\r\n                    // Only create btBvhTriangleMeshShape if the impostor is static\r\n                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\r\n                    if (this.onCreateCustomMeshImpostor) {\r\n                        returnValue = this.onCreateCustomMeshImpostor(impostor);\r\n                    } else {\r\n                        const triMesh = new this.bjsAMMO.btTriangleMesh();\r\n                        impostor._pluginData.toDispose.push(triMesh);\r\n                        const triangleCount = this._addMeshVerts(triMesh, object, object);\r\n                        if (triangleCount == 0) {\r\n                            returnValue = new this.bjsAMMO.btCompoundShape();\r\n                        } else {\r\n                            returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(triMesh);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            // Otherwise create convexHullImpostor\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsImpostor.ConvexHullImpostor: {\r\n                if (this.onCreateCustomConvexHullImpostor) {\r\n                    returnValue = this.onCreateCustomConvexHullImpostor(impostor);\r\n                } else {\r\n                    const convexHull = new this.bjsAMMO.btConvexHullShape();\r\n                    const triangleCount = this._addHullVerts(convexHull, object, object);\r\n                    if (triangleCount == 0) {\r\n                        // Cleanup Unused Convex Hull Shape\r\n                        impostor._pluginData.toDispose.push(convexHull);\r\n                        returnValue = new this.bjsAMMO.btCompoundShape();\r\n                    } else {\r\n                        returnValue = convexHull;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case PhysicsImpostor.NoImpostor:\r\n                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\r\n                returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\r\n                break;\r\n            case PhysicsImpostor.CustomImpostor:\r\n                // Only usable when the plugin's onCreateCustomShape is set\r\n                returnValue = this._createCustom(impostor);\r\n                break;\r\n            case PhysicsImpostor.SoftbodyImpostor:\r\n                // Only usable with a mesh that has sufficient and shared vertices\r\n                returnValue = this._createSoftbody(impostor);\r\n                break;\r\n            case PhysicsImpostor.ClothImpostor:\r\n                // Only usable with a ground mesh that has sufficient and shared vertices\r\n                returnValue = this._createCloth(impostor);\r\n                break;\r\n            case PhysicsImpostor.RopeImpostor:\r\n                // Only usable with a line mesh or an extruded mesh that is updatable\r\n                returnValue = this._createRope(impostor);\r\n                break;\r\n            default:\r\n                Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh body position/rotation from the babylon impostor\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     */\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\r\n\r\n        if (!impostor.object.rotationQuaternion) {\r\n            if (impostor.object.rotation) {\r\n                this._tmpQuaternion.set(\r\n                    this._tmpAmmoTransform.getRotation().x(),\r\n                    this._tmpAmmoTransform.getRotation().y(),\r\n                    this._tmpAmmoTransform.getRotation().z(),\r\n                    this._tmpAmmoTransform.getRotation().w()\r\n                );\r\n                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\r\n            }\r\n        } else {\r\n            impostor.object.rotationQuaternion.set(\r\n                this._tmpAmmoTransform.getRotation().x(),\r\n                this._tmpAmmoTransform.getRotation().y(),\r\n                this._tmpAmmoTransform.getRotation().z(),\r\n                this._tmpAmmoTransform.getRotation().w()\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the babylon object's position/rotation from the physics body's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     * @param newPosition new position\r\n     * @param newRotation new rotation\r\n     */\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const trans = impostor.physicsBody.getWorldTransform();\r\n\r\n        // If rotation/position has changed update and activate rigged body\r\n        if (\r\n            Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon ||\r\n            Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon ||\r\n            Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon ||\r\n            Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon ||\r\n            Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon\r\n        ) {\r\n            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\r\n            trans.setOrigin(this._tmpAmmoVectorA);\r\n\r\n            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n            trans.setRotation(this._tmpAmmoQuaternion);\r\n            impostor.physicsBody.setWorldTransform(trans);\r\n\r\n            if (impostor.mass == 0) {\r\n                // Kinematic objects must be updated using motion state\r\n                const motionState = impostor.physicsBody.getMotionState();\r\n                if (motionState) {\r\n                    motionState.setWorldTransform(trans);\r\n                }\r\n            } else {\r\n                impostor.physicsBody.activate();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsAMMO !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * gets the linear velocity\r\n     * @param impostor imposter to get linear velocity from\r\n     * @returns linear velocity\r\n     */\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.linearVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getLinearVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * gets the angular velocity\r\n     * @param impostor imposter to get angular velocity from\r\n     * @returns angular velocity\r\n     */\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.angularVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getAngularVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the mass of physics body\r\n     * @param impostor imposter to set the mass on\r\n     * @param mass mass to set\r\n     */\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.setTotalMass(mass, false);\r\n        } else {\r\n            impostor.physicsBody.setMassProps(mass);\r\n        }\r\n        impostor._pluginData.mass = mass;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics body\r\n     * @param impostor imposter to get the mass from\r\n     * @returns mass\r\n     */\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.mass || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets friction of the impostor\r\n     * @param impostor impostor to get friction from\r\n     * @returns friction value\r\n     */\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.friction || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets friction of the impostor\r\n     * @param impostor impostor to set friction on\r\n     * @param friction friction value\r\n     */\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.get_m_cfg().set_kDF(friction);\r\n        } else {\r\n            impostor.physicsBody.setFriction(friction);\r\n        }\r\n        impostor._pluginData.friction = friction;\r\n    }\r\n\r\n    /**\r\n     * Gets restitution of the impostor\r\n     * @param impostor impostor to get restitution from\r\n     * @returns restitution value\r\n     */\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.restitution || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets restitution of the impostor\r\n     * @param impostor impostor to set resitution on\r\n     * @param restitution resitution value\r\n     */\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.setRestitution(restitution);\r\n        impostor._pluginData.restitution = restitution;\r\n    }\r\n\r\n    /**\r\n     * Gets pressure inside the impostor\r\n     * @param impostor impostor to get pressure from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyPressure(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Pressure is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.pressure || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets pressure inside a soft body impostor\r\n     * Cloth and rope must remain 0 pressure\r\n     * @param impostor impostor to set pressure on\r\n     * @param pressure pressure value\r\n     */\r\n    public setBodyPressure(impostor: PhysicsImpostor, pressure: number) {\r\n        if (impostor.soft) {\r\n            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(pressure);\r\n                impostor._pluginData.pressure = pressure;\r\n            } else {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(0);\r\n                impostor._pluginData.pressure = 0;\r\n            }\r\n        } else {\r\n            Logger.Warn(\"Pressure can only be applied to a softbody\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets stiffness of the impostor\r\n     * @param impostor impostor to get stiffness from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyStiffness(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Stiffness is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.stiffness || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets stiffness of the impostor\r\n     * @param impostor impostor to set stiffness on\r\n     * @param stiffness stiffness value from 0 to 1\r\n     */\r\n    public setBodyStiffness(impostor: PhysicsImpostor, stiffness: number) {\r\n        if (impostor.soft) {\r\n            stiffness = stiffness < 0 ? 0 : stiffness;\r\n            stiffness = stiffness > 1 ? 1 : stiffness;\r\n            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\r\n            impostor._pluginData.stiffness = stiffness;\r\n        } else {\r\n            Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets velocityIterations of the impostor\r\n     * @param impostor impostor to get velocity iterations from\r\n     * @returns velocityIterations value\r\n     */\r\n    public getBodyVelocityIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.velocityIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets velocityIterations of the impostor\r\n     * @param impostor impostor to set velocity iterations on\r\n     * @param velocityIterations velocityIterations value\r\n     */\r\n    public setBodyVelocityIterations(impostor: PhysicsImpostor, velocityIterations: number) {\r\n        if (impostor.soft) {\r\n            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\r\n            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\r\n            impostor._pluginData.velocityIterations = velocityIterations;\r\n        } else {\r\n            Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets positionIterations of the impostor\r\n     * @param impostor impostor to get position iterations from\r\n     * @returns positionIterations value\r\n     */\r\n    public getBodyPositionIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Position iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.positionIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets positionIterations of the impostor\r\n     * @param impostor impostor to set position on\r\n     * @param positionIterations positionIterations value\r\n     */\r\n    public setBodyPositionIterations(impostor: PhysicsImpostor, positionIterations: number) {\r\n        if (impostor.soft) {\r\n            positionIterations = positionIterations < 0 ? 0 : positionIterations;\r\n            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\r\n            impostor._pluginData.positionIterations = positionIterations;\r\n        } else {\r\n            Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Append an anchor to a cloth object\r\n     * @param impostor is the cloth impostor to add anchor to\r\n     * @param otherImpostor is the rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendAnchor(\r\n        impostor: PhysicsImpostor,\r\n        otherImpostor: PhysicsImpostor,\r\n        width: number,\r\n        height: number,\r\n        influence: number = 1,\r\n        noCollisionBetweenLinkedBodies: boolean = false\r\n    ) {\r\n        const segs = impostor.segments;\r\n        const nbAcross = Math.round((segs - 1) * width);\r\n        const nbUp = Math.round((segs - 1) * height);\r\n        const nbDown = segs - 1 - nbUp;\r\n        const node = nbAcross + segs * nbDown;\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Append an hook to a rope object\r\n     * @param impostor is the rope impostor to add hook to\r\n     * @param otherImpostor is the rigid impostor to hook to\r\n     * @param length ratio along the rope from 0 to 1\r\n     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendHook(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        const node = Math.round(impostor.segments * length);\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Sleeps the physics body and stops it from being active\r\n     * @param impostor impostor to sleep\r\n     */\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.forceActivationState(0);\r\n    }\r\n\r\n    /**\r\n     * Activates the physics body\r\n     * @param impostor impostor to activate\r\n     */\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.activate();\r\n    }\r\n\r\n    /**\r\n     * Updates the distance parameters of the joint\r\n     */\r\n    public updateDistanceJoint() {\r\n        Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Sets a motor on the joint\r\n     * @param joint joint to set motor on\r\n     * @param speed speed of the motor\r\n     * @param maxForce maximum force of the motor\r\n     */\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number) {\r\n        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Sets the motors limit\r\n     */\r\n    public setLimit() {\r\n        Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Syncs the position and rotation of a mesh with the impostor\r\n     * @param mesh mesh to sync\r\n     * @param impostor impostor to update the mesh with\r\n     */\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n\r\n        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\r\n        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\r\n        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\r\n            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\r\n            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\r\n            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the impostor\r\n     * @param impostor impostor to get radius from\r\n     * @returns the radius\r\n     */\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const extents = impostor.getObjectExtents();\r\n        return extents.x / 2;\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the impostor\r\n     * @param impostor impostor to get box size from\r\n     * @param result the resulting box size\r\n     */\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const extents = impostor.getObjectExtents();\r\n        result.x = extents.x;\r\n        result.y = extents.y;\r\n        result.z = extents.z;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the impostor\r\n     */\r\n    public dispose() {\r\n        // Dispose of world\r\n        this.bjsAMMO.destroy(this.world);\r\n        this.bjsAMMO.destroy(this._solver);\r\n        this.bjsAMMO.destroy(this._overlappingPairCache);\r\n        this.bjsAMMO.destroy(this._dispatcher);\r\n        this.bjsAMMO.destroy(this._collisionConfiguration);\r\n\r\n        // Dispose of temp variables\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorB);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorC);\r\n        this.bjsAMMO.destroy(this._tmpAmmoTransform);\r\n        this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\r\n        this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\r\n\r\n        this.world = null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from where should the ray start?\r\n     * @param to where should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\r\n        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\r\n\r\n        const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\r\n        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\r\n\r\n        this._raycastResult.reset(from, to);\r\n        if (rayCallback.hasHit()) {\r\n            // TODO: do we want/need the body? If so, set all the data\r\n            /*\r\n            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\r\n                rayCallback.get_m_collisionObject()\r\n            );\r\n            var body = {};\r\n            */\r\n            this._raycastResult.setHitData(\r\n                {\r\n                    x: rayCallback.get_m_hitNormalWorld().x(),\r\n                    y: rayCallback.get_m_hitNormalWorld().y(),\r\n                    z: rayCallback.get_m_hitNormalWorld().z(),\r\n                },\r\n                {\r\n                    x: rayCallback.get_m_hitPointWorld().x(),\r\n                    y: rayCallback.get_m_hitPointWorld().y(),\r\n                    z: rayCallback.get_m_hitPointWorld().z(),\r\n                }\r\n            );\r\n            this._raycastResult.calculateHitDistance();\r\n        }\r\n        this.bjsAMMO.destroy(rayCallback);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\r\n        return this._raycastResult;\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IPhysicsEngine, PhysicsImpostorJoint, IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\nimport type { PhysicsImpostor, IPhysicsEnabledObject } from \"./physicsImpostor\";\r\nimport type { PhysicsJoint } from \"./physicsJoint\";\r\nimport type { PhysicsRaycastResult } from \"./physicsRaycastResult\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\n\r\n/**\r\n * Class used to control physics engine\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsEngine implements IPhysicsEngine {\r\n    /**\r\n     * Global value used to control the smallest number supported by the simulation\r\n     */\r\n    public static Epsilon = 0.001;\r\n\r\n    private _impostors: Array<PhysicsImpostor> = [];\r\n    private _joints: Array<PhysicsImpostorJoint> = [];\r\n    private _subTimeStep: number = 0;\r\n    private _uniqueIdCounter = 0;\r\n\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    public gravity: Vector3;\r\n\r\n    /**\r\n     * Factory used to create the default physics plugin.\r\n     * @returns The default physics plugin\r\n     */\r\n    public static DefaultPluginFactory(): IPhysicsEnginePlugin {\r\n        throw _WarnImport(\"CannonJSPlugin\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Physics Engine\r\n     * @param gravity defines the gravity vector used by the simulation\r\n     * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n     */\r\n    constructor(gravity: Nullable<Vector3>, private _physicsPlugin: IPhysicsEnginePlugin = PhysicsEngine.DefaultPluginFactory()) {\r\n        if (!this._physicsPlugin.isSupported()) {\r\n            throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \" + \"Please make sure it is included.\");\r\n        }\r\n        gravity = gravity || new Vector3(0, -9.807, 0);\r\n        this.setGravity(gravity);\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this.gravity = gravity;\r\n        this._physicsPlugin.setGravity(this.gravity);\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * @param newTimeStep defines the new timestep to apply to this world.\r\n     */\r\n    public setTimeStep(newTimeStep: number = 1 / 60) {\r\n        this._physicsPlugin.setTimeStep(newTimeStep);\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._physicsPlugin.getTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    public setSubTimeStep(subTimeStep: number = 0) {\r\n        this._subTimeStep = subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    public getSubTimeStep() {\r\n        return this._subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this._impostors.forEach(function (impostor) {\r\n            impostor.dispose();\r\n        });\r\n        this._physicsPlugin.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    public getPhysicsPluginName(): string {\r\n        return this._physicsPlugin.name;\r\n    }\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n    public addImpostor(impostor: PhysicsImpostor) {\r\n        this._impostors.push(impostor);\r\n        impostor.uniqueId = this._uniqueIdCounter++;\r\n        //if no parent, generate the body\r\n        if (!impostor.parent) {\r\n            this._physicsPlugin.generatePhysicsBody(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an impostor from the engine.\r\n     * This impostor and its mesh will not longer be updated by the physics engine.\r\n     * @param impostor the impostor to remove\r\n     */\r\n    public removeImpostor(impostor: PhysicsImpostor) {\r\n        const index = this._impostors.indexOf(impostor);\r\n        if (index > -1) {\r\n            const removed = this._impostors.splice(index, 1);\r\n            //Is it needed?\r\n            if (removed.length) {\r\n                this.getPhysicsPlugin().removePhysicsBody(impostor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a joint to the physics engine\r\n     * @param mainImpostor defines the main impostor to which the joint is added.\r\n     * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\r\n     * @param joint defines the joint that will connect both impostors.\r\n     */\r\n    public addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        const impostorJoint = {\r\n            mainImpostor: mainImpostor,\r\n            connectedImpostor: connectedImpostor,\r\n            joint: joint,\r\n        };\r\n        joint.physicsPlugin = this._physicsPlugin;\r\n        this._joints.push(impostorJoint);\r\n        this._physicsPlugin.generateJoint(impostorJoint);\r\n    }\r\n\r\n    /**\r\n     * Removes a joint from the simulation\r\n     * @param mainImpostor defines the impostor used with the joint\r\n     * @param connectedImpostor defines the other impostor connected to the main one by the joint\r\n     * @param joint defines the joint to remove\r\n     */\r\n    public removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        const matchingJoints = this._joints.filter(function (impostorJoint) {\r\n            return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;\r\n        });\r\n        if (matchingJoints.length) {\r\n            this._physicsPlugin.removeJoint(matchingJoints[0]);\r\n            //TODO remove it from the list as well\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespan between frames\r\n     */\r\n    public _step(delta: number) {\r\n        //check if any mesh has no body / requires an update\r\n        this._impostors.forEach((impostor) => {\r\n            if (impostor.isBodyInitRequired()) {\r\n                this._physicsPlugin.generatePhysicsBody(impostor);\r\n            }\r\n        });\r\n\r\n        if (delta > 0.1) {\r\n            delta = 0.1;\r\n        } else if (delta <= 0) {\r\n            delta = 1.0 / 60.0;\r\n        }\r\n\r\n        this._physicsPlugin.executeStep(delta, this._impostors);\r\n    }\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    public getPhysicsPlugin(): IPhysicsEnginePlugin {\r\n        return this._physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of physic impostors\r\n     * @returns an array of PhysicsImpostor\r\n     */\r\n    public getImpostors(): Array<PhysicsImpostor> {\r\n        return this._impostors;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics enabled object\r\n     * @param object defines the object impersonated by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        for (let i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].object === object) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics body object\r\n     * @param body defines physics body used by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor> {\r\n        for (let i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].physicsBody === body) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        return this._physicsPlugin.raycast(from, to);\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Node } from \"../node\";\r\n\r\nimport type { IPhysicsEngine, IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\nimport { PhysicsEngine } from \"./physicsEngine\";\r\nimport type { PhysicsImpostor } from \"./physicsImpostor\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _physicsEngine: Nullable<IPhysicsEngine>;\r\n        /** @internal */\r\n        _physicsTimeAccumulator: number;\r\n\r\n        /**\r\n         * Gets the current physics engine\r\n         * @returns a IPhysicsEngine or null if none attached\r\n         */\r\n        getPhysicsEngine(): Nullable<IPhysicsEngine>;\r\n\r\n        /**\r\n         * Enables physics to the current scene\r\n         * @param gravity defines the scene's gravity for the physics engine. defaults to real earth gravity : (0, -9.81, 0)\r\n         * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n         * @returns a boolean indicating if the physics engine was initialized\r\n         */\r\n        enablePhysics(gravity?: Nullable<Vector3>, plugin?: IPhysicsEnginePlugin): boolean;\r\n\r\n        /**\r\n         * Disables and disposes the physics engine associated with the scene\r\n         */\r\n        disablePhysicsEngine(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if there is an active physics engine\r\n         * @returns a boolean indicating if there is an active physics engine\r\n         */\r\n        isPhysicsEnabled(): boolean;\r\n\r\n        /**\r\n         * Deletes a physics compound impostor\r\n         * @param compound defines the compound to delete\r\n         */\r\n        deleteCompoundImpostor(compound: any): void;\r\n\r\n        /**\r\n         * An event triggered when physic simulation is about to be run\r\n         */\r\n        onBeforePhysicsObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when physic simulation has been done\r\n         */\r\n        onAfterPhysicsObservable: Observable<Scene>;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\r\nScene.prototype.getPhysicsEngine = function (): Nullable<IPhysicsEngine> {\r\n    return this._physicsEngine;\r\n};\r\n\r\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n * @returns a boolean indicating if the physics engine was initialized\r\n */\r\nScene.prototype.enablePhysics = function (gravity: Nullable<Vector3> = null, plugin?: IPhysicsEnginePlugin): boolean {\r\n    if (this._physicsEngine) {\r\n        return true;\r\n    }\r\n\r\n    // Register the component to the scene\r\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE) as PhysicsEngineSceneComponent;\r\n    if (!component) {\r\n        component = new PhysicsEngineSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    try {\r\n        this._physicsEngine = new PhysicsEngine(gravity, plugin);\r\n        this._physicsTimeAccumulator = 0;\r\n        return true;\r\n    } catch (e) {\r\n        Logger.Error(e.message);\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\r\nScene.prototype.disablePhysicsEngine = function (): void {\r\n    if (!this._physicsEngine) {\r\n        return;\r\n    }\r\n\r\n    this._physicsEngine.dispose();\r\n    this._physicsEngine = null;\r\n};\r\n\r\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\r\nScene.prototype.isPhysicsEnabled = function (): boolean {\r\n    return this._physicsEngine !== undefined;\r\n};\r\n\r\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\r\nScene.prototype.deleteCompoundImpostor = function (compound: any): void {\r\n    const mesh: AbstractMesh = compound.parts[0].mesh;\r\n\r\n    if (mesh.physicsImpostor) {\r\n        mesh.physicsImpostor.dispose(/*true*/);\r\n        mesh.physicsImpostor = null;\r\n    }\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nScene.prototype._advancePhysicsEngineStep = function (step: number) {\r\n    if (this._physicsEngine) {\r\n        const subTime = this._physicsEngine.getSubTimeStep();\r\n        if (subTime > 0) {\r\n            this._physicsTimeAccumulator += step;\r\n            while (this._physicsTimeAccumulator > subTime) {\r\n                this.onBeforePhysicsObservable.notifyObservers(this);\r\n                this._physicsEngine._step(subTime / 1000);\r\n                this.onAfterPhysicsObservable.notifyObservers(this);\r\n                this._physicsTimeAccumulator -= subTime;\r\n            }\r\n        } else {\r\n            this.onBeforePhysicsObservable.notifyObservers(this);\r\n            this._physicsEngine._step(step / 1000);\r\n            this.onAfterPhysicsObservable.notifyObservers(this);\r\n        }\r\n    }\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @internal */\r\n        _physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets or sets impostor used for physic simulation\r\n         * @see https://doc.babylonjs.com/features/physics_engine\r\n         */\r\n        physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets the current physics impostor\r\n         * @see https://doc.babylonjs.com/features/physics_engine\r\n         * @returns a physics impostor or null\r\n         */\r\n        getPhysicsImpostor(): Nullable<PhysicsImpostor>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;\r\n\r\n        /**\r\n         * Creates a physic joint between two meshes\r\n         * @param otherMesh defines the other mesh to use\r\n         * @param pivot1 defines the pivot to use on this mesh\r\n         * @param pivot2 defines the pivot to use on the other mesh\r\n         * @param options defines additional options (can be plugin dependent)\r\n         * @returns the current mesh\r\n         * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n         */\r\n        setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;\r\n\r\n        /** @internal */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._physicsImpostor;\r\n    },\r\n    set: function (this: AbstractMesh, value: Nullable<PhysicsImpostor>) {\r\n        if (this._physicsImpostor === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsImpostor = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsImpostor) {\r\n                    this.physicsImpostor.dispose(/*!doNotRecurse*/);\r\n                    this.physicsImpostor = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Gets the current physics impostor\r\n * @see https://doc.babylonjs.com/features/physics_engine\r\n * @returns a physics impostor or null\r\n */\r\nAbstractMesh.prototype.getPhysicsImpostor = function (): Nullable<PhysicsImpostor> {\r\n    return this.physicsImpostor;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nAbstractMesh.prototype.applyImpulse = function (force: Vector3, contactPoint: Vector3): AbstractMesh {\r\n    if (!this.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\r\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh {\r\n    if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\r\n        mainPivot: pivot1,\r\n        connectedPivot: pivot2,\r\n        nativeParams: options,\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\r\nexport class PhysicsEngineSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PHYSICSENGINE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.onBeforePhysicsObservable = new Observable<Scene>();\r\n        this.scene.onAfterPhysicsObservable = new Observable<Scene>();\r\n\r\n        // Replace the function used to get the deterministic frame time\r\n        this.scene.getDeterministicFrameTime = () => {\r\n            if (this.scene._physicsEngine) {\r\n                return this.scene._physicsEngine.getTimeStep() * 1000;\r\n            }\r\n\r\n            return 1000.0 / 60.0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {}\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforePhysicsObservable.clear();\r\n        this.scene.onAfterPhysicsObservable.clear();\r\n\r\n        if (this.scene._physicsEngine) {\r\n            this.scene.disablePhysicsEngine();\r\n        }\r\n    }\r\n}\r\n","import { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Holds the data for the raycast result\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsRaycastResult {\r\n    private _hasHit: boolean = false;\r\n\r\n    private _hitDistance: number = 0;\r\n    private _hitNormalWorld: Vector3 = Vector3.Zero();\r\n    private _hitPointWorld: Vector3 = Vector3.Zero();\r\n    private _rayFromWorld: Vector3 = Vector3.Zero();\r\n    private _rayToWorld: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets if there was a hit\r\n     */\r\n    get hasHit(): boolean {\r\n        return this._hasHit;\r\n    }\r\n\r\n    /**\r\n     * Gets the distance from the hit\r\n     */\r\n    get hitDistance(): number {\r\n        return this._hitDistance;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit normal/direction in the world\r\n     */\r\n    get hitNormalWorld(): Vector3 {\r\n        return this._hitNormalWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit point in the world\r\n     */\r\n    get hitPointWorld(): Vector3 {\r\n        return this._hitPointWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"start point\" of the ray in the world\r\n     */\r\n    get rayFromWorld(): Vector3 {\r\n        return this._rayFromWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"end point\" of the ray in the world\r\n     */\r\n    get rayToWorld(): Vector3 {\r\n        return this._rayToWorld;\r\n    }\r\n\r\n    /**\r\n     * Sets the hit data (normal & point in world space)\r\n     * @param hitNormalWorld defines the normal in world space\r\n     * @param hitPointWorld defines the point in world space\r\n     */\r\n    public setHitData(hitNormalWorld: IXYZ, hitPointWorld: IXYZ) {\r\n        this._hasHit = true;\r\n        this._hitNormalWorld = new Vector3(hitNormalWorld.x, hitNormalWorld.y, hitNormalWorld.z);\r\n        this._hitPointWorld = new Vector3(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z);\r\n    }\r\n\r\n    /**\r\n     * Sets the distance from the start point to the hit point\r\n     * @param distance\r\n     */\r\n    public setHitDistance(distance: number) {\r\n        this._hitDistance = distance;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance manually\r\n     */\r\n    public calculateHitDistance() {\r\n        this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPointWorld);\r\n    }\r\n\r\n    /**\r\n     * Resets all the values to default\r\n     * @param from The from point on world space\r\n     * @param to The to point on world space\r\n     */\r\n    public reset(from: Vector3 = Vector3.Zero(), to: Vector3 = Vector3.Zero()) {\r\n        this._rayFromWorld = from;\r\n        this._rayToWorld = to;\r\n\r\n        this._hasHit = false;\r\n        this._hitDistance = 0;\r\n\r\n        this._hitNormalWorld = Vector3.Zero();\r\n        this._hitPointWorld = Vector3.Zero();\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for the size containing width and height\r\n */\r\ninterface IXYZ {\r\n    /**\r\n     * X\r\n     */\r\n    x: number;\r\n\r\n    /**\r\n     * Y\r\n     */\r\n    y: number;\r\n\r\n    /**\r\n     * Z\r\n     */\r\n    z: number;\r\n}\r\n"],"names":["AmmoJSPlugin","_useDeltaForWorldStep","ammoInjection","Ammo","overlappingPairCache","bjsAMMO","name","_timeStep","_fixedTimeStep","_maxSteps","_tmpQuaternion","_tmpContactCallbackResult","_tmpContactPoint","_tmpContactNormal","_tmpVec3","_tmpMatrix","this","isSupported","_collisionConfiguration","btSoftBodyRigidBodyCollisionConfiguration","_dispatcher","btCollisionDispatcher","_overlappingPairCache","btDbvtBroadphase","_solver","btSequentialImpulseConstraintSolver","_softBodySolver","btDefaultSoftBodySolver","world","btSoftRigidDynamicsWorld","_tmpAmmoConcreteContactResultCallback","ConcreteContactResultCallback","addSingleResult","contactPoint","worldPoint","wrapPointer","btManifoldPoint","getPositionWorldOnA","worldNormal","m_normalWorldOnB","x","y","z","_tmpContactImpulse","getAppliedImpulse","_tmpContactDistance","getDistance","_raycastResult","_tmpAmmoTransform","btTransform","setIdentity","_tmpAmmoQuaternion","btQuaternion","_tmpAmmoVectorA","btVector3","_tmpAmmoVectorB","_tmpAmmoVectorC","_tmpAmmoVectorD","setGravity","gravity","setValue","getWorldInfo","set_m_gravity","setTimeStep","timeStep","setFixedTimeStep","fixedTimeStep","setMaxSteps","maxSteps","getTimeStep","_isImpostorInContact","impostor","contactTest","physicsBody","_isImpostorPairInContact","impostorA","impostorB","contactPairTest","_stepSimulation","stepSimulation","executeStep","delta","impostors","soft","beforeStep","mainImpostor","_afterSoftStep","afterStep","_onPhysicsCollideCallbacks","length","collideCallback","otherImpostor","otherImpostors","isActive","onCollide","body","point","distance","impulse","normal","type","_ropeStep","_softbodyOrClothStep","bodyVertices","get_m_nodes","nbVertices","size","node","nodePositions","path","Array","n","at","get_m_x","push","object","shape","getParam","_isFromLine","points","instance","normalDirection","vertexPositions","getVerticesData","vertexNormals","nx","ny","nz","nodeNormals","get_m_n","vertex_data","positions","normals","uvs","colors","getIndices","indices","applyToMesh","applyImpulse","force","activate","getWorldMatrix","subtractInPlace","getTranslation","applyForce","localTranslation","generatePhysicsBody","_pluginData","toDispose","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","colShape","_createShape","mass","get_m_cfg","set_collisions","set_kDP","castObject","btCollisionObject","getCollisionShape","setMargin","setActivationState","_DISABLE_DEACTIVATION_FLAG","addSoftBody","setBodyPressure","setBodyStiffness","setBodyVelocityIterations","setBodyPositionIterations","localInertia","startTransform","computeWorldMatrix","calculateLocalInertia","position","rotationQuaternion","w","setOrigin","setRotation","myMotionState","btDefaultMotionState","rbInfo","btRigidBodyConstructionInfo","btRigidBody","setCollisionFlags","getCollisionFlags","_KINEMATIC_FLAG","getChildShape","_DISABLE_COLLISION_FLAG","boundingInfo","getBoundingInfo","copyFrom","getAbsolutePosition","boundingBox","centerWorld","scaling","setDeltaPosition","group","mask","addRigidBody","concat","setBodyRestitution","setBodyFriction","removeSoftBody","removeRigidBody","forEach","d","destroy","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","mainPivot","connectedPivot","maxDistance","btPoint2PointConstraint","mainAxis","connectedAxis","btHingeConstraint","addConstraint","collision","physicsJoint","removeJoint","removeConstraint","_addMeshVerts","btTriangleMesh","topLevelObject","triangleCount","getChildMeshes","localMatrix","topLevelQuaternion","rotation","invertToRef","multiply","faceCount","i","triPoints","vec","v","addTriangle","m","_softVertexData","newPoints","newNorms","_createSoftbody","btCompoundShape","triNorms","softBody","btSoftBodyHelpers","CreateFromTriMesh","setX","setY","setZ","_createCloth","len","segments","Math","sqrt","segs","CreatePatch","_createRope","map","reduce","accumulator","currentValue","pathVectors","fixedPoints","ropeBody","CreateRope","_createCustom","returnValue","onCreateCustomShape","_addHullVerts","btConvexHullShape","addPoint","ignoreChildren","impostorExtents","getObjectExtents","meshChildren","childrenAdded","childMesh","childImpostor","getPhysicsImpostor","parentMat","clone","s","decompose","getOrigin","addChildShape","dispose","btSphereShape","radii","btMultiSphereShape","setLocalScaling","capRadius","btCapsuleShape","btCylinderShape","btBoxShape","onCreateCustomMeshImpostor","triMesh","btBvhTriangleMeshShape","onCreateCustomConvexHullImpostor","convexHull","setTransformationFromPhysicsBody","getMotionState","getWorldTransform","set","getRotation","toEulerAnglesToRef","setPhysicsBodyTransformation","newPosition","newRotation","trans","abs","setWorldTransform","motionState","undefined","setLinearVelocity","velocity","linearVelocity","setAngularVelocity","angularVelocity","getLinearVelocity","result","getAngularVelocity","setBodyMass","setTotalMass","setMassProps","getBodyMass","getBodyFriction","friction","set_kDF","setFriction","getBodyRestitution","restitution","setRestitution","getBodyPressure","pressure","set_kPR","getBodyStiffness","stiffness","get_m_materials","set_m_kLST","getBodyVelocityIterations","velocityIterations","set_viterations","getBodyPositionIterations","positionIterations","set_piterations","appendAnchor","width","height","influence","noCollisionBetweenLinkedBodies","round","appendHook","sleepBody","forceActivationState","wakeUpBody","updateDistanceJoint","setMotor","speed","maxForce","enableAngularMotor","setLimit","syncMeshWithImpostor","mesh","getRadius","getBoxSizeToRef","extents","raycast","from","to","_tmpAmmoVectorRCA","_tmpAmmoVectorRCB","rayCallback","ClosestRayResultCallback","rayTest","reset","hasHit","setHitData","get_m_hitNormalWorld","get_m_hitPointWorld","calculateHitDistance","PhysicsEngine","constructor","_physicsPlugin","DefaultPluginFactory","_impostors","_joints","_subTimeStep","_uniqueIdCounter","Error","static","newTimeStep","setSubTimeStep","subTimeStep","getSubTimeStep","getPhysicsPluginName","addImpostor","uniqueId","removeImpostor","index","indexOf","splice","getPhysicsPlugin","addJoint","physicsPlugin","matchingJoints","filter","_step","getImpostors","getImpostorForPhysicsObject","getImpostorWithPhysicsBody","Epsilon","_physicsEngine","plugin","component","_getComponent","PhysicsEngineSceneComponent","_addComponent","_physicsTimeAccumulator","e","message","compound","parts","physicsImpostor","step","subTime","onBeforePhysicsObservable","notifyObservers","onAfterPhysicsObservable","Object","defineProperty","get","_physicsImpostor","value","_disposePhysicsObserver","onDisposeObservable","remove","add","enumerable","configurable","otherMesh","pivot1","pivot2","options","createJoint","nativeParams","scene","getDeterministicFrameTime","register","rebuild","clear","disablePhysicsEngine","PhysicsRaycastResult","_hasHit","_hitDistance","_hitNormalWorld","_hitPointWorld","_rayFromWorld","_rayToWorld","hitDistance","hitNormalWorld","hitPointWorld","rayFromWorld","rayToWorld","setHitDistance"],"sourceRoot":""}