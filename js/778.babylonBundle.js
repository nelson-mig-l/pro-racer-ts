"use strict";(self.webpackChunkpro_racer=self.webpackChunkpro_racer||[]).push([[778],{3778:(s,t,e)=>{e.d(t,{j:()=>d});var r=e(6786),i=e(972),o=e(7959),n=e(4684),a=e(6721),h=e(9827),c=e(9859),f=e(3092),u=e(2059),l=e(569),_=e(78);const p={effect:null,subMesh:null};class d extends l.a{constructor(s,t,e,r={},o=!0){super(s,t,o),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new i.y3,this._cachedWorldViewProjectionMatrix=new i.y3,this._multiview=!1,this._shaderPath=e,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...r}}get shaderPath(){return this._shaderPath}set shaderPath(s){this._shaderPath=s}get options(){return this._options}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(s){-1===this._options.uniforms.indexOf(s)&&this._options.uniforms.push(s)}setTexture(s,t){return-1===this._options.samplers.indexOf(s)&&this._options.samplers.push(s),this._textures[s]=t,this}setTextureArray(s,t){return-1===this._options.samplers.indexOf(s)&&this._options.samplers.push(s),this._checkUniform(s),this._textureArrays[s]=t,this}setExternalTexture(s,t){return-1===this._options.externalTextures.indexOf(s)&&this._options.externalTextures.push(s),this._externalTextures[s]=t,this}setFloat(s,t){return this._checkUniform(s),this._floats[s]=t,this}setInt(s,t){return this._checkUniform(s),this._ints[s]=t,this}setFloats(s,t){return this._checkUniform(s),this._floatsArrays[s]=t,this}setColor3(s,t){return this._checkUniform(s),this._colors3[s]=t,this}setColor3Array(s,t){return this._checkUniform(s),this._colors3Arrays[s]=t.reduce(((s,t)=>(t.toArray(s,s.length),s)),[]),this}setColor4(s,t){return this._checkUniform(s),this._colors4[s]=t,this}setColor4Array(s,t){return this._checkUniform(s),this._colors4Arrays[s]=t.reduce(((s,t)=>(t.toArray(s,s.length),s)),[]),this}setVector2(s,t){return this._checkUniform(s),this._vectors2[s]=t,this}setVector3(s,t){return this._checkUniform(s),this._vectors3[s]=t,this}setVector4(s,t){return this._checkUniform(s),this._vectors4[s]=t,this}setQuaternion(s,t){return this._checkUniform(s),this._quaternions[s]=t,this}setQuaternionArray(s,t){return this._checkUniform(s),this._quaternionsArrays[s]=t.reduce(((s,t)=>(t.toArray(s,s.length),s)),[]),this}setMatrix(s,t){return this._checkUniform(s),this._matrices[s]=t,this}setMatrices(s,t){this._checkUniform(s);const e=new Float32Array(16*t.length);for(let s=0;s<t.length;s++)t[s].copyToArray(e,16*s);return this._matrixArrays[s]=e,this}setMatrix3x3(s,t){return this._checkUniform(s),this._matrices3x3[s]=t,this}setMatrix2x2(s,t){return this._checkUniform(s),this._matrices2x2[s]=t,this}setArray2(s,t){return this._checkUniform(s),this._vectors2Arrays[s]=t,this}setArray3(s,t){return this._checkUniform(s),this._vectors3Arrays[s]=t,this}setArray4(s,t){return this._checkUniform(s),this._vectors4Arrays[s]=t,this}setUniformBuffer(s,t){return-1===this._options.uniformBuffers.indexOf(s)&&this._options.uniformBuffers.push(s),this._uniformBuffers[s]=t,this}setTextureSampler(s,t){return-1===this._options.samplerObjects.indexOf(s)&&this._options.samplerObjects.push(s),this._textureSamplers[s]=t,this}setStorageBuffer(s,t){return-1===this._options.storageBuffers.indexOf(s)&&this._options.storageBuffers.push(s),this._storageBuffers[s]=t,this}isReadyForSubMesh(s,t,e){return this.isReady(s,e,t)}isReady(s,t,e){var r,i,n,h;const c=e&&this._storeEffectOnSubMeshes;if(this.isFrozen)if(c){if(e.effect&&e.effect._wasPreviouslyReady)return!0}else{const s=this._drawWrapper.effect;if(s&&s._wasPreviouslyReady&&s._wasPreviouslyUsingInstances===t)return!0}const u=this.getScene(),l=u.getEngine(),_=[],d=[],x=new f.L;let m=this._shaderPath,A=this._options.uniforms,y=this._options.uniformBuffers,v=this._options.samplers;l.getCaps().multiview&&u.activeCamera&&u.activeCamera.outputRenderTarget&&u.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,_.push("#define MULTIVIEW"),-1!==this._options.uniforms.indexOf("viewProjection")&&-1===this._options.uniforms.indexOf("viewProjectionR")&&this._options.uniforms.push("viewProjectionR"));for(let s=0;s<this._options.defines.length;s++){const t=0===this._options.defines[s].indexOf("#define")?this._options.defines[s]:`#define ${this._options.defines[s]}`;_.push(t)}for(let s=0;s<this._options.attributes.length;s++)d.push(this._options.attributes[s]);if(s&&s.isVerticesDataPresent(o.o.ColorKind)&&(d.push(o.o.ColorKind),_.push("#define VERTEXCOLOR")),t&&(_.push("#define INSTANCES"),a.G.PushAttributesForInstances(d),(null==s?void 0:s.hasThinInstances)&&(_.push("#define THIN_INSTANCES"),s&&s.isVerticesDataPresent(o.o.ColorInstanceKind)&&(d.push(o.o.ColorInstanceKind),_.push("#define INSTANCESCOLOR")))),s&&s.useBones&&s.computeBonesUsingShaders&&s.skeleton){d.push(o.o.MatricesIndicesKind),d.push(o.o.MatricesWeightsKind),s.numBoneInfluencers>4&&(d.push(o.o.MatricesIndicesExtraKind),d.push(o.o.MatricesWeightsExtraKind));const t=s.skeleton;_.push("#define NUM_BONE_INFLUENCERS "+s.numBoneInfluencers),x.addCPUSkinningFallback(0,s),t.isUsingTextureForMatrices?(_.push("#define BONETEXTURE"),-1===this._options.uniforms.indexOf("boneTextureWidth")&&this._options.uniforms.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(_.push("#define BonesPerMesh "+(t.bones.length+1)),-1===this._options.uniforms.indexOf("mBones")&&this._options.uniforms.push("mBones"))}else _.push("#define NUM_BONE_INFLUENCERS 0");let g=0;const P=s?s.morphTargetManager:null;if(P){const s=P.supportsUVs&&-1!==_.indexOf("#define UV1"),t=P.supportsTangents&&-1!==_.indexOf("#define TANGENT"),e=P.supportsNormals&&-1!==_.indexOf("#define NORMAL");g=P.numInfluencers,s&&_.push("#define MORPHTARGETS_UV"),t&&_.push("#define MORPHTARGETS_TANGENT"),e&&_.push("#define MORPHTARGETS_NORMAL"),g>0&&_.push("#define MORPHTARGETS"),P.isUsingTextureForTargets&&(_.push("#define MORPHTARGETS_TEXTURE"),-1===this._options.uniforms.indexOf("morphTargetTextureIndices")&&this._options.uniforms.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),_.push("#define NUM_MORPH_INFLUENCERS "+g);for(let r=0;r<g;r++)d.push(o.o.PositionKind+r),e&&d.push(o.o.NormalKind+r),t&&d.push(o.o.TangentKind+r),s&&d.push(o.o.UVKind+"_"+r);g>0&&(A=A.slice(),A.push("morphTargetInfluences"),A.push("morphTargetTextureInfo"),A.push("morphTargetTextureIndices"))}else _.push("#define NUM_MORPH_INFLUENCERS 0");if(s){const t=s.bakedVertexAnimationManager;t&&t.isEnabled&&(_.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===this._options.uniforms.indexOf("bakedVertexAnimationSettings")&&this._options.uniforms.push("bakedVertexAnimationSettings"),-1===this._options.uniforms.indexOf("bakedVertexAnimationTextureSizeInverted")&&this._options.uniforms.push("bakedVertexAnimationTextureSizeInverted"),-1===this._options.uniforms.indexOf("bakedVertexAnimationTime")&&this._options.uniforms.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),a.G.PrepareAttributesForBakedVertexAnimation(d,s,_)}for(const s in this._textures)if(!this._textures[s].isReady())return!1;s&&this._shouldTurnAlphaTestOn(s)&&_.push("#define ALPHATEST"),(null===this._options.useClipPlane&&u.clipPlane||this._options.useClipPlane)&&(_.push("#define CLIPPLANE"),-1===A.indexOf("vClipPlane")&&A.push("vClipPlane")),(null===this._options.useClipPlane&&u.clipPlane2||this._options.useClipPlane)&&(_.push("#define CLIPPLANE2"),-1===A.indexOf("vClipPlane2")&&A.push("vClipPlane2")),(null===this._options.useClipPlane&&u.clipPlane3||this._options.useClipPlane)&&(_.push("#define CLIPPLANE3"),-1===A.indexOf("vClipPlane3")&&A.push("vClipPlane3")),(null===this._options.useClipPlane&&u.clipPlane4||this._options.useClipPlane)&&(_.push("#define CLIPPLANE4"),-1===A.indexOf("vClipPlane4")&&A.push("vClipPlane4")),(null===this._options.useClipPlane&&u.clipPlane5||this._options.useClipPlane)&&(_.push("#define CLIPPLANE5"),-1===A.indexOf("vClipPlane5")&&A.push("vClipPlane5")),(null===this._options.useClipPlane&&u.clipPlane6||this._options.useClipPlane)&&(_.push("#define CLIPPLANE6"),-1===A.indexOf("vClipPlane6")&&A.push("vClipPlane6")),this.customShaderNameResolve&&(A=A.slice(),y=y.slice(),v=v.slice(),m=this.customShaderNameResolve(m,A,y,v,_,d));const T=c?e._getDrawWrapper():this._drawWrapper,M=null!==(r=null==T?void 0:T.effect)&&void 0!==r?r:null,S=null!==(i=null==T?void 0:T.defines)&&void 0!==i?i:null,C=_.join("\n");let O=M;return S!==C&&(O=l.createEffect(m,{attributes:d,uniformsNames:A,uniformBuffersNames:y,samplers:v,defines:C,fallbacks:x,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:g},shaderLanguage:this._options.shaderLanguage},l),c?e.setEffect(O,C,this._materialContext):T&&T.setEffect(O,C),this._onEffectCreatedObservable&&(p.effect=O,p.subMesh=null!==(n=null!=e?e:null==s?void 0:s.subMeshes[0])&&void 0!==n?n:null,this._onEffectCreatedObservable.notifyObservers(p))),O._wasPreviouslyUsingInstances=!!t,null!==(h=!(null==O?void 0:O.isReady()))&&void 0!==h&&!h&&(M!==O&&u.resetCachedMaterial(),O._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(s,t){const e=this.getScene(),r=null!=t?t:this.getEffect();r&&(-1!==this._options.uniforms.indexOf("world")&&r.setMatrix("world",s),-1!==this._options.uniforms.indexOf("worldView")&&(s.multiplyToRef(e.getViewMatrix(),this._cachedWorldViewMatrix),r.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==this._options.uniforms.indexOf("worldViewProjection")&&(s.multiplyToRef(e.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),r.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)))}bindForSubMesh(s,t,e){var r;this.bind(s,t,null===(r=e._drawWrapperOverride)||void 0===r?void 0:r.effect,e)}bind(s,t,e,r){var i;const o=r&&this._storeEffectOnSubMeshes,n=null!=e?e:o?r.effect:this.getEffect();if(!n)return;this._activeEffect=n,this.bindOnlyWorldMatrix(s,e);const h=this._options.uniformBuffers;let c=!1;if(n&&h&&h.length>0&&this.getScene().getEngine().supportsUniformBuffers)for(let e=0;e<h.length;++e)switch(h[e]){case"Mesh":t&&(t.getMeshUniformBuffer().bindToEffect(n,"Mesh"),t.transferToEffect(s));break;case"Scene":a.G.BindSceneUniformBuffer(n,this.getScene().getSceneUniformBuffer()),this.getScene().finalizeSceneUbo(),c=!0}const f=t&&o?this._mustRebind(this.getScene(),n,t.visibility):this.getScene().getCachedMaterial()!==this;if(n&&f){let s;for(s in c||-1===this._options.uniforms.indexOf("view")||n.setMatrix("view",this.getScene().getViewMatrix()),c||-1===this._options.uniforms.indexOf("projection")||n.setMatrix("projection",this.getScene().getProjectionMatrix()),c||-1===this._options.uniforms.indexOf("viewProjection")||(n.setMatrix("viewProjection",this.getScene().getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",this.getScene()._transformMatrixR)),this.getScene().activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&n.setVector3("cameraPosition",this.getScene().activeCamera.globalPosition),a.G.BindBonesParameters(t,n),a.G.BindClipPlane(n,this.getScene()),this._textures)n.setTexture(s,this._textures[s]);for(s in this._textureArrays)n.setTextureArray(s,this._textureArrays[s]);for(s in this._externalTextures)n.setExternalTexture(s,this._externalTextures[s]);for(s in this._ints)n.setInt(s,this._ints[s]);for(s in this._floats)n.setFloat(s,this._floats[s]);for(s in this._floatsArrays)n.setArray(s,this._floatsArrays[s]);for(s in this._colors3)n.setColor3(s,this._colors3[s]);for(s in this._colors3Arrays)n.setArray3(s,this._colors3Arrays[s]);for(s in this._colors4){const t=this._colors4[s];n.setFloat4(s,t.r,t.g,t.b,t.a)}for(s in this._colors4Arrays)n.setArray4(s,this._colors4Arrays[s]);for(s in this._vectors2)n.setVector2(s,this._vectors2[s]);for(s in this._vectors3)n.setVector3(s,this._vectors3[s]);for(s in this._vectors4)n.setVector4(s,this._vectors4[s]);for(s in this._quaternions)n.setQuaternion(s,this._quaternions[s]);for(s in this._matrices)n.setMatrix(s,this._matrices[s]);for(s in this._matrixArrays)n.setMatrices(s,this._matrixArrays[s]);for(s in this._matrices3x3)n.setMatrix3x3(s,this._matrices3x3[s]);for(s in this._matrices2x2)n.setMatrix2x2(s,this._matrices2x2[s]);for(s in this._vectors2Arrays)n.setArray2(s,this._vectors2Arrays[s]);for(s in this._vectors3Arrays)n.setArray3(s,this._vectors3Arrays[s]);for(s in this._vectors4Arrays)n.setArray4(s,this._vectors4Arrays[s]);for(s in this._quaternionsArrays)n.setArray4(s,this._quaternionsArrays[s]);for(s in this._uniformBuffers){const t=this._uniformBuffers[s].getBuffer();t&&n.bindUniformBuffer(t,s)}for(s in this._textureSamplers)n.setTextureSampler(s,this._textureSamplers[s]);for(s in this._storageBuffers)n.setStorageBuffer(s,this._storageBuffers[s])}if(n&&t&&(f||!this.isFrozen)){const s=t.morphTargetManager;s&&s.numInfluencers>0&&a.G.BindMorphTargetParameters(t,n);const e=t.bakedVertexAnimationManager;e&&e.isEnabled&&(null===(i=t.bakedVertexAnimationManager)||void 0===i||i.bind(n,!!n._wasPreviouslyUsingInstances))}this._afterBind(t,n)}getActiveTextures(){const s=super.getActiveTextures();for(const t in this._textures)s.push(this._textures[t]);for(const t in this._textureArrays){const e=this._textureArrays[t];for(let t=0;t<e.length;t++)s.push(e[t])}return s}hasTexture(s){if(super.hasTexture(s))return!0;for(const t in this._textures)if(this._textures[t]===s)return!0;for(const t in this._textureArrays){const e=this._textureArrays[t];for(let t=0;t<e.length;t++)if(e[t]===s)return!0}return!1}clone(s){const t=r.p4.Clone((()=>new d(s,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);t.name=s,t.id=s,"object"==typeof t._shaderPath&&(t._shaderPath={...t._shaderPath}),this._options={...this._options},Object.keys(this._options).forEach((s=>{const t=this._options[s];Array.isArray(t)&&(this._options[s]=t.slice(0))})),this.stencil.copyTo(t.stencil);for(const s in this._textures)t.setTexture(s,this._textures[s]);for(const s in this._textureArrays)t.setTextureArray(s,this._textureArrays[s]);for(const s in this._externalTextures)t.setExternalTexture(s,this._externalTextures[s]);for(const s in this._ints)t.setInt(s,this._ints[s]);for(const s in this._floats)t.setFloat(s,this._floats[s]);for(const s in this._floatsArrays)t.setFloats(s,this._floatsArrays[s]);for(const s in this._colors3)t.setColor3(s,this._colors3[s]);for(const s in this._colors3Arrays)t._colors3Arrays[s]=this._colors3Arrays[s];for(const s in this._colors4)t.setColor4(s,this._colors4[s]);for(const s in this._colors4Arrays)t._colors4Arrays[s]=this._colors4Arrays[s];for(const s in this._vectors2)t.setVector2(s,this._vectors2[s]);for(const s in this._vectors3)t.setVector3(s,this._vectors3[s]);for(const s in this._vectors4)t.setVector4(s,this._vectors4[s]);for(const s in this._quaternions)t.setQuaternion(s,this._quaternions[s]);for(const s in this._quaternionsArrays)t._quaternionsArrays[s]=this._quaternionsArrays[s];for(const s in this._matrices)t.setMatrix(s,this._matrices[s]);for(const s in this._matrixArrays)t._matrixArrays[s]=this._matrixArrays[s].slice();for(const s in this._matrices3x3)t.setMatrix3x3(s,this._matrices3x3[s]);for(const s in this._matrices2x2)t.setMatrix2x2(s,this._matrices2x2[s]);for(const s in this._vectors2Arrays)t.setArray2(s,this._vectors2Arrays[s]);for(const s in this._vectors3Arrays)t.setArray3(s,this._vectors3Arrays[s]);for(const s in this._vectors4Arrays)t.setArray4(s,this._vectors4Arrays[s]);for(const s in this._uniformBuffers)t.setUniformBuffer(s,this._uniformBuffers[s]);for(const s in this._textureSamplers)t.setTextureSampler(s,this._textureSamplers[s]);for(const s in this._storageBuffers)t.setStorageBuffer(s,this._storageBuffers[s]);return t}dispose(s,t,e){if(t){let s;for(s in this._textures)this._textures[s].dispose();for(s in this._textureArrays){const t=this._textureArrays[s];for(let s=0;s<t.length;s++)t[s].dispose()}}this._textures={},super.dispose(s,t,e)}serialize(){const s=r.p4.Serialize(this);let t;for(t in s.customType="BABYLON.ShaderMaterial",s.uniqueId=this.uniqueId,s.options=this._options,s.shaderPath=this._shaderPath,s.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,s.stencil=this.stencil.serialize(),s.textures={},this._textures)s.textures[t]=this._textures[t].serialize();for(t in s.textureArrays={},this._textureArrays){s.textureArrays[t]=[];const e=this._textureArrays[t];for(let r=0;r<e.length;r++)s.textureArrays[t].push(e[r].serialize())}for(t in s.ints={},this._ints)s.ints[t]=this._ints[t];for(t in s.floats={},this._floats)s.floats[t]=this._floats[t];for(t in s.FloatArrays={},this._floatsArrays)s.FloatArrays[t]=this._floatsArrays[t];for(t in s.colors3={},this._colors3)s.colors3[t]=this._colors3[t].asArray();for(t in s.colors3Arrays={},this._colors3Arrays)s.colors3Arrays[t]=this._colors3Arrays[t];for(t in s.colors4={},this._colors4)s.colors4[t]=this._colors4[t].asArray();for(t in s.colors4Arrays={},this._colors4Arrays)s.colors4Arrays[t]=this._colors4Arrays[t];for(t in s.vectors2={},this._vectors2)s.vectors2[t]=this._vectors2[t].asArray();for(t in s.vectors3={},this._vectors3)s.vectors3[t]=this._vectors3[t].asArray();for(t in s.vectors4={},this._vectors4)s.vectors4[t]=this._vectors4[t].asArray();for(t in s.quaternions={},this._quaternions)s.quaternions[t]=this._quaternions[t].asArray();for(t in s.matrices={},this._matrices)s.matrices[t]=this._matrices[t].asArray();for(t in s.matrixArray={},this._matrixArrays)s.matrixArray[t]=this._matrixArrays[t];for(t in s.matrices3x3={},this._matrices3x3)s.matrices3x3[t]=this._matrices3x3[t];for(t in s.matrices2x2={},this._matrices2x2)s.matrices2x2[t]=this._matrices2x2[t];for(t in s.vectors2Arrays={},this._vectors2Arrays)s.vectors2Arrays[t]=this._vectors2Arrays[t];for(t in s.vectors3Arrays={},this._vectors3Arrays)s.vectors3Arrays[t]=this._vectors3Arrays[t];for(t in s.vectors4Arrays={},this._vectors4Arrays)s.vectors4Arrays[t]=this._vectors4Arrays[t];for(t in s.quaternionsArrays={},this._quaternionsArrays)s.quaternionsArrays[t]=this._quaternionsArrays[t];return s}static Parse(s,t,e){const o=r.p4.Parse((()=>new d(s.name,t,s.shaderPath,s.options,s.storeEffectOnSubMeshes)),s,t,e);let a;for(a in s.stencil&&o.stencil.parse(s.stencil,t,e),s.textures)o.setTexture(a,n.x.Parse(s.textures[a],t,e));for(a in s.textureArrays){const r=s.textureArrays[a],i=new Array;for(let s=0;s<r.length;s++)i.push(n.x.Parse(r[s],t,e));o.setTextureArray(a,i)}for(a in s.ints)o.setInt(a,s.ints[a]);for(a in s.floats)o.setFloat(a,s.floats[a]);for(a in s.floatsArrays)o.setFloats(a,s.floatsArrays[a]);for(a in s.colors3)o.setColor3(a,c.Wo.FromArray(s.colors3[a]));for(a in s.colors3Arrays){const t=s.colors3Arrays[a].reduce(((s,t,e)=>(e%3==0?s.push([t]):s[s.length-1].push(t),s)),[]).map((s=>c.Wo.FromArray(s)));o.setColor3Array(a,t)}for(a in s.colors4)o.setColor4(a,c.HE.FromArray(s.colors4[a]));for(a in s.colors4Arrays){const t=s.colors4Arrays[a].reduce(((s,t,e)=>(e%4==0?s.push([t]):s[s.length-1].push(t),s)),[]).map((s=>c.HE.FromArray(s)));o.setColor4Array(a,t)}for(a in s.vectors2)o.setVector2(a,i.FM.FromArray(s.vectors2[a]));for(a in s.vectors3)o.setVector3(a,i.P.FromArray(s.vectors3[a]));for(a in s.vectors4)o.setVector4(a,i.Lt.FromArray(s.vectors4[a]));for(a in s.quaternions)o.setQuaternion(a,i._f.FromArray(s.quaternions[a]));for(a in s.matrices)o.setMatrix(a,i.y3.FromArray(s.matrices[a]));for(a in s.matrixArray)o._matrixArrays[a]=new Float32Array(s.matrixArray[a]);for(a in s.matrices3x3)o.setMatrix3x3(a,s.matrices3x3[a]);for(a in s.matrices2x2)o.setMatrix2x2(a,s.matrices2x2[a]);for(a in s.vectors2Arrays)o.setArray2(a,s.vectors2Arrays[a]);for(a in s.vectors3Arrays)o.setArray3(a,s.vectors3Arrays[a]);for(a in s.vectors4Arrays)o.setArray4(a,s.vectors4Arrays[a]);for(a in s.quaternionsArrays)o.setArray4(a,s.quaternionsArrays[a]);return o}static ParseFromFileAsync(s,t,e,r=""){return new Promise(((i,o)=>{const n=new u.g;n.addEventListener("readystatechange",(()=>{if(4==n.readyState)if(200==n.status){const t=JSON.parse(n.responseText),o=this.Parse(t,e||_.l.LastCreatedScene,r);s&&(o.name=s),i(o)}else o("Unable to load the ShaderMaterial")})),n.open("GET",t),n.send()}))}static ParseFromSnippetAsync(s,t,e=""){return new Promise(((r,i)=>{const o=new u.g;o.addEventListener("readystatechange",(()=>{if(4==o.readyState)if(200==o.status){const i=JSON.parse(JSON.parse(o.responseText).jsonPayload),n=JSON.parse(i.shaderMaterial),a=this.Parse(n,t||_.l.LastCreatedScene,e);a.snippetId=s,r(a)}else i("Unable to load the snippet "+s)})),o.open("GET",this.SnippetUrl+"/"+s.replace(/#/g,"/")),o.send()}))}}d.SnippetUrl="https://snippet.babylonjs.com",d.CreateFromSnippetAsync=d.ParseFromSnippetAsync,(0,h.H)("BABYLON.ShaderMaterial",d)}}]);
//# sourceMappingURL=778.babylonBundle.js.map